/* tslint:disable */
/* eslint-disable */
/**
 * User Service
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: DEVELOPMENT
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ApplicationInfo
 */
export interface ApplicationInfo {
    /**
     * 
     * @type {string}
     * @memberof ApplicationInfo
     */
    'app_name': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationInfo
     */
    'app_version': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationInfo
     */
    'host_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationInfo
     */
    'app_time': string;
}
/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface AuthorizeByTelegramRestResponse
 */
export interface AuthorizeByTelegramRestResponse {
    /**
     * 
     * @type {string}
     * @memberof AuthorizeByTelegramRestResponse
     */
    'jwtToken': string;
}
/**
 * 
 * @export
 * @interface Blocked
 */
export interface Blocked extends KycStatus {
}
/**
 * 
 * @export
 * @interface ByLevel
 */
export interface ByLevel {
    /**
     * 
     * @type {Limits}
     * @memberof ByLevel
     */
    'incomingTransactions': Limits;
    /**
     * 
     * @type {Limits}
     * @memberof ByLevel
     */
    'cardPurchase': Limits;
    /**
     * 
     * @type {Limits}
     * @memberof ByLevel
     */
    'p2pPurchase': Limits;
}
/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface CompanyDto
 */
export interface CompanyDto {
    /**
     * 
     * @type {number}
     * @memberof CompanyDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof CompanyDto
     */
    'kybCountryCodeAlpha3'?: string;
    /**
     * 
     * @type {Blocked | NotVerified | Verified}
     * @memberof CompanyDto
     */
    'kybStatus': Blocked | NotVerified | Verified;
    /**
     * 
     * @type {CompanyVerificationStateDto}
     * @memberof CompanyDto
     */
    'verificationState'?: CompanyVerificationStateDto;
}
/**
 * 
 * @export
 * @interface CompanyVerificationStateDto
 */
export interface CompanyVerificationStateDto {
    /**
     * 
     * @type {string}
     * @memberof CompanyVerificationStateDto
     */
    'updatedDateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof CompanyVerificationStateDto
     */
    'reviewStatus'?: CompanyVerificationStateDtoReviewStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof CompanyVerificationStateDto
     */
    'isFinalReject': boolean;
    /**
     * 
     * @type {string}
     * @memberof CompanyVerificationStateDto
     */
    'currentLevel'?: CompanyVerificationStateDtoCurrentLevelEnum;
    /**
     * 
     * @type {string}
     * @memberof CompanyVerificationStateDto
     */
    'forcedLevel'?: CompanyVerificationStateDtoForcedLevelEnum;
}

export const CompanyVerificationStateDtoReviewStatusEnum = {
    Init: 'init',
    Pending: 'pending',
    Prechecked: 'prechecked',
    Queued: 'queued',
    Completed: 'completed',
    OnHold: 'onHold'
} as const;

export type CompanyVerificationStateDtoReviewStatusEnum = typeof CompanyVerificationStateDtoReviewStatusEnum[keyof typeof CompanyVerificationStateDtoReviewStatusEnum];
export const CompanyVerificationStateDtoCurrentLevelEnum = {
    Standard: 'WALLET_PAY_STANDARD',
    Enhanced: 'WALLET_PAY_ENHANCED'
} as const;

export type CompanyVerificationStateDtoCurrentLevelEnum = typeof CompanyVerificationStateDtoCurrentLevelEnum[keyof typeof CompanyVerificationStateDtoCurrentLevelEnum];
export const CompanyVerificationStateDtoForcedLevelEnum = {
    Standard: 'WALLET_PAY_STANDARD',
    Enhanced: 'WALLET_PAY_ENHANCED'
} as const;

export type CompanyVerificationStateDtoForcedLevelEnum = typeof CompanyVerificationStateDtoForcedLevelEnum[keyof typeof CompanyVerificationStateDtoForcedLevelEnum];

/**
 * 
 * @export
 * @interface CreateTestUserRequest
 */
export interface CreateTestUserRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateTestUserRequest
     */
    'phoneNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTestUserRequest
     */
    'countryCodeAlpha2'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateTestUserRequest
     */
    'deviceIds': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateTestUserRequest
     */
    'ipAddresses': Array<string>;
}
/**
 * 
 * @export
 * @interface DisableP2PUserRequest
 */
export interface DisableP2PUserRequest {
    /**
     * 
     * @type {number}
     * @memberof DisableP2PUserRequest
     */
    'userId': number;
    /**
     * 
     * @type {string}
     * @memberof DisableP2PUserRequest
     */
    'comment': string;
}
/**
 * 
 * @export
 * @interface DisableUserPermissionsRestRequest
 */
export interface DisableUserPermissionsRestRequest {
    /**
     * 
     * @type {number}
     * @memberof DisableUserPermissionsRestRequest
     */
    'userId': number;
    /**
     * 
     * @type {string}
     * @memberof DisableUserPermissionsRestRequest
     */
    'comment': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DisableUserPermissionsRestRequest
     */
    'disablePermissions': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof DisableUserPermissionsRestRequest
     */
    'disableAll': boolean;
}
/**
 * 
 * @export
 * @interface GetUserRequest
 */
export interface GetUserRequest {
    /**
     * 
     * @type {string}
     * @memberof GetUserRequest
     */
    'deviceId': string;
}
/**
 * 
 * @export
 * @interface HealthStatusResponse
 */
export interface HealthStatusResponse {
    /**
     * 
     * @type {string}
     * @memberof HealthStatusResponse
     */
    'instance_id': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof HealthStatusResponse
     */
    'resources_status': { [key: string]: string; };
}

export const HealthStatusResponseResourcesStatusEnum = {
    Ok: 'OK',
    ConnectionFailed: 'CONNECTION_FAILED'
} as const;

export type HealthStatusResponseResourcesStatusEnum = typeof HealthStatusResponseResourcesStatusEnum[keyof typeof HealthStatusResponseResourcesStatusEnum];

/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface KybDataDto
 */
export interface KybDataDto {
    /**
     * 
     * @type {number}
     * @memberof KybDataDto
     */
    'companyId': number;
    /**
     * 
     * @type {Blocked | NotVerified | Verified}
     * @memberof KybDataDto
     */
    'kybStatus': Blocked | NotVerified | Verified;
    /**
     * 
     * @type {VerificationProcessDto}
     * @memberof KybDataDto
     */
    'verificationProcess': VerificationProcessDto;
}
/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface KycDataDto
 */
export interface KycDataDto {
    /**
     * 
     * @type {number}
     * @memberof KycDataDto
     */
    'userId': number;
    /**
     * 
     * @type {Blocked | Verified}
     * @memberof KycDataDto
     */
    'kycStatus': Blocked | Verified;
    /**
     * 
     * @type {VerificationProcessDto}
     * @memberof KycDataDto
     */
    'verificationProcess'?: VerificationProcessDto;
}
/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface KycDataPublicDto
 */
export interface KycDataPublicDto {
    /**
     * 
     * @type {number}
     * @memberof KycDataPublicDto
     */
    'userId': number;
    /**
     * 
     * @type {KycStatusPublicDto}
     * @memberof KycDataPublicDto
     */
    'kycStatus': KycStatusPublicDto;
    /**
     * 
     * @type {VerificationProcessPublicDto}
     * @memberof KycDataPublicDto
     */
    'verificationProcess'?: VerificationProcessPublicDto;
}
/**
 * 
 * @export
 * @interface KycStatus
 */
export interface KycStatus {
    /**
     * 
     * @type {string}
     * @memberof KycStatus
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface KycStatusPublicDto
 */
export interface KycStatusPublicDto {
    /**
     * 
     * @type {string}
     * @memberof KycStatusPublicDto
     */
    'status': KycStatusPublicDtoStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof KycStatusPublicDto
     */
    'level'?: KycStatusPublicDtoLevelEnum;
}

export const KycStatusPublicDtoStatusEnum = {
    Verified: 'VERIFIED',
    Blocked: 'BLOCKED'
} as const;

export type KycStatusPublicDtoStatusEnum = typeof KycStatusPublicDtoStatusEnum[keyof typeof KycStatusPublicDtoStatusEnum];
export const KycStatusPublicDtoLevelEnum = {
    _0: 'LEVEL_0',
    _1: 'LEVEL_1',
    _2: 'LEVEL_2',
    _3: 'LEVEL_3',
    _4: 'LEVEL_4'
} as const;

export type KycStatusPublicDtoLevelEnum = typeof KycStatusPublicDtoLevelEnum[keyof typeof KycStatusPublicDtoLevelEnum];

/**
 * 
 * @export
 * @interface Limits
 */
export interface Limits {
    /**
     * 
     * @type {string}
     * @memberof Limits
     */
    'daily': string;
    /**
     * 
     * @type {string}
     * @memberof Limits
     */
    'monthly': string;
}
/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface LimitsInfoResponse
 */
export interface LimitsInfoResponse {
    /**
     * 
     * @type {ByLevel}
     * @memberof LimitsInfoResponse
     */
    'level0': ByLevel;
    /**
     * 
     * @type {ByLevel}
     * @memberof LimitsInfoResponse
     */
    'level1': ByLevel;
    /**
     * 
     * @type {ByLevel}
     * @memberof LimitsInfoResponse
     */
    'level2': ByLevel;
    /**
     * 
     * @type {ByLevel}
     * @memberof LimitsInfoResponse
     */
    'level3': ByLevel;
    /**
     * 
     * @type {ByLevel}
     * @memberof LimitsInfoResponse
     */
    'level4'?: ByLevel;
    /**
     * 
     * @type {string}
     * @memberof LimitsInfoResponse
     */
    'currencyCode': string;
}
/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface NewTokenForCompanyResponse
 */
export interface NewTokenForCompanyResponse {
    /**
     * 
     * @type {string}
     * @memberof NewTokenForCompanyResponse
     */
    'token': string;
    /**
     * 
     * @type {number}
     * @memberof NewTokenForCompanyResponse
     */
    'companyId': number;
}
/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface NewTokenForUserResponse
 */
export interface NewTokenForUserResponse {
    /**
     * 
     * @type {string}
     * @memberof NewTokenForUserResponse
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface NotVerified
 */
export interface NotVerified extends KycStatus {
}
/**
 * 
 * @export
 * @interface P2PUserPublicRestDto
 */
export interface P2PUserPublicRestDto {
    /**
     * 
     * @type {number}
     * @memberof P2PUserPublicRestDto
     */
    'userId': number;
    /**
     * 
     * @type {number}
     * @memberof P2PUserPublicRestDto
     */
    'telegramUserId': number;
    /**
     * 
     * @type {string}
     * @memberof P2PUserPublicRestDto
     */
    'nickname': string;
    /**
     * 
     * @type {string}
     * @memberof P2PUserPublicRestDto
     */
    'displayNickname': string;
    /**
     * 
     * @type {string}
     * @memberof P2PUserPublicRestDto
     */
    'avatarCode': string;
    /**
     * 
     * @type {string}
     * @memberof P2PUserPublicRestDto
     */
    'locale': string;
    /**
     * 
     * @type {boolean}
     * @memberof P2PUserPublicRestDto
     */
    'canUseP2p': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof P2PUserPublicRestDto
     */
    'isBanned': boolean;
}
/**
 * 
 * @export
 * @interface P2PUserRestDto
 */
export interface P2PUserRestDto {
    /**
     * 
     * @type {number}
     * @memberof P2PUserRestDto
     */
    'userId': number;
    /**
     * 
     * @type {number}
     * @memberof P2PUserRestDto
     */
    'telegramUserId': number;
    /**
     * 
     * @type {string}
     * @memberof P2PUserRestDto
     */
    'nickname': string;
    /**
     * 
     * @type {string}
     * @memberof P2PUserRestDto
     */
    'displayNickname': string;
    /**
     * 
     * @type {string}
     * @memberof P2PUserRestDto
     */
    'avatarCode': string;
    /**
     * 
     * @type {string}
     * @memberof P2PUserRestDto
     */
    'locale': string;
    /**
     * 
     * @type {boolean}
     * @memberof P2PUserRestDto
     */
    'canUseP2p': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof P2PUserRestDto
     */
    'isBanned': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof P2PUserRestDto
     */
    'isEligibleForTokens'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof P2PUserRestDto
     */
    'eligibilityForTokensCheckDateTime'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof P2PUserRestDto
     */
    'isAnAnonymousFragmentPhoneNumber': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof P2PUserRestDto
     */
    'deviceIds': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof P2PUserRestDto
     */
    'ipAddresses': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof P2PUserRestDto
     */
    'isPhoneNumberPresent': boolean;
    /**
     * 
     * @type {string}
     * @memberof P2PUserRestDto
     */
    'countryCodeAlpha2'?: string;
}
/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface P2PUserSearchResultPublicRestDto
 */
export interface P2PUserSearchResultPublicRestDto {
    /**
     * 
     * @type {string}
     * @memberof P2PUserSearchResultPublicRestDto
     */
    'status': P2PUserSearchResultPublicRestDtoStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof P2PUserSearchResultPublicRestDto
     */
    'userId': number;
    /**
     * 
     * @type {P2PUserPublicRestDto}
     * @memberof P2PUserSearchResultPublicRestDto
     */
    'user'?: P2PUserPublicRestDto;
}

export const P2PUserSearchResultPublicRestDtoStatusEnum = {
    Success: 'SUCCESS',
    NotInitialized: 'NOT_INITIALIZED',
    NotFound: 'NOT_FOUND'
} as const;

export type P2PUserSearchResultPublicRestDtoStatusEnum = typeof P2PUserSearchResultPublicRestDtoStatusEnum[keyof typeof P2PUserSearchResultPublicRestDtoStatusEnum];

/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface P2PUserSearchResultRestDto
 */
export interface P2PUserSearchResultRestDto {
    /**
     * 
     * @type {string}
     * @memberof P2PUserSearchResultRestDto
     */
    'status': P2PUserSearchResultRestDtoStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof P2PUserSearchResultRestDto
     */
    'userId': number;
    /**
     * 
     * @type {P2PUserRestDto}
     * @memberof P2PUserSearchResultRestDto
     */
    'user'?: P2PUserRestDto;
}

export const P2PUserSearchResultRestDtoStatusEnum = {
    Success: 'SUCCESS',
    NotInitialized: 'NOT_INITIALIZED',
    NotFound: 'NOT_FOUND'
} as const;

export type P2PUserSearchResultRestDtoStatusEnum = typeof P2PUserSearchResultRestDtoStatusEnum[keyof typeof P2PUserSearchResultRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseAuthorizeByTelegramStatusAuthorizeByTelegramRestResponse
 */
export interface RestDataResponseAuthorizeByTelegramStatusAuthorizeByTelegramRestResponse {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseAuthorizeByTelegramStatusAuthorizeByTelegramRestResponse
     */
    'status': RestDataResponseAuthorizeByTelegramStatusAuthorizeByTelegramRestResponseStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseAuthorizeByTelegramStatusAuthorizeByTelegramRestResponse
     */
    'message'?: string;
    /**
     * 
     * @type {AuthorizeByTelegramRestResponse}
     * @memberof RestDataResponseAuthorizeByTelegramStatusAuthorizeByTelegramRestResponse
     */
    'data'?: AuthorizeByTelegramRestResponse;
}

export const RestDataResponseAuthorizeByTelegramStatusAuthorizeByTelegramRestResponseStatusEnum = {
    Success: 'SUCCESS',
    FailedVerification: 'FAILED_VERIFICATION',
    NotWalletUser: 'NOT_WALLET_USER'
} as const;

export type RestDataResponseAuthorizeByTelegramStatusAuthorizeByTelegramRestResponseStatusEnum = typeof RestDataResponseAuthorizeByTelegramStatusAuthorizeByTelegramRestResponseStatusEnum[keyof typeof RestDataResponseAuthorizeByTelegramStatusAuthorizeByTelegramRestResponseStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseCheckIsUserEligibleForTokensRestStatusUserEligibleForTokensValidationResultRestDto
 */
export interface RestDataResponseCheckIsUserEligibleForTokensRestStatusUserEligibleForTokensValidationResultRestDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseCheckIsUserEligibleForTokensRestStatusUserEligibleForTokensValidationResultRestDto
     */
    'status': RestDataResponseCheckIsUserEligibleForTokensRestStatusUserEligibleForTokensValidationResultRestDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseCheckIsUserEligibleForTokensRestStatusUserEligibleForTokensValidationResultRestDto
     */
    'message'?: string;
    /**
     * 
     * @type {UserEligibleForTokensValidationResultRestDto}
     * @memberof RestDataResponseCheckIsUserEligibleForTokensRestStatusUserEligibleForTokensValidationResultRestDto
     */
    'data'?: UserEligibleForTokensValidationResultRestDto;
}

export const RestDataResponseCheckIsUserEligibleForTokensRestStatusUserEligibleForTokensValidationResultRestDtoStatusEnum = {
    Success: 'SUCCESS',
    Failed: 'FAILED'
} as const;

export type RestDataResponseCheckIsUserEligibleForTokensRestStatusUserEligibleForTokensValidationResultRestDtoStatusEnum = typeof RestDataResponseCheckIsUserEligibleForTokensRestStatusUserEligibleForTokensValidationResultRestDtoStatusEnum[keyof typeof RestDataResponseCheckIsUserEligibleForTokensRestStatusUserEligibleForTokensValidationResultRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseCreateCompanyRestResultCompanyDto
 */
export interface RestDataResponseCreateCompanyRestResultCompanyDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseCreateCompanyRestResultCompanyDto
     */
    'status': RestDataResponseCreateCompanyRestResultCompanyDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseCreateCompanyRestResultCompanyDto
     */
    'message'?: string;
    /**
     * 
     * @type {CompanyDto}
     * @memberof RestDataResponseCreateCompanyRestResultCompanyDto
     */
    'data'?: CompanyDto;
}

export const RestDataResponseCreateCompanyRestResultCompanyDtoStatusEnum = {
    Success: 'SUCCESS'
} as const;

export type RestDataResponseCreateCompanyRestResultCompanyDtoStatusEnum = typeof RestDataResponseCreateCompanyRestResultCompanyDtoStatusEnum[keyof typeof RestDataResponseCreateCompanyRestResultCompanyDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseCreateUserStatusUser
 */
export interface RestDataResponseCreateUserStatusUser {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseCreateUserStatusUser
     */
    'status': RestDataResponseCreateUserStatusUserStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseCreateUserStatusUser
     */
    'message'?: string;
    /**
     * 
     * @type {User}
     * @memberof RestDataResponseCreateUserStatusUser
     */
    'data'?: User;
}

export const RestDataResponseCreateUserStatusUserStatusEnum = {
    Success: 'SUCCESS'
} as const;

export type RestDataResponseCreateUserStatusUserStatusEnum = typeof RestDataResponseCreateUserStatusUserStatusEnum[keyof typeof RestDataResponseCreateUserStatusUserStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseGetCompanyRestResultCompanyDto
 */
export interface RestDataResponseGetCompanyRestResultCompanyDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseGetCompanyRestResultCompanyDto
     */
    'status': RestDataResponseGetCompanyRestResultCompanyDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseGetCompanyRestResultCompanyDto
     */
    'message'?: string;
    /**
     * 
     * @type {CompanyDto}
     * @memberof RestDataResponseGetCompanyRestResultCompanyDto
     */
    'data'?: CompanyDto;
}

export const RestDataResponseGetCompanyRestResultCompanyDtoStatusEnum = {
    Success: 'SUCCESS',
    NotFound: 'NOT_FOUND'
} as const;

export type RestDataResponseGetCompanyRestResultCompanyDtoStatusEnum = typeof RestDataResponseGetCompanyRestResultCompanyDtoStatusEnum[keyof typeof RestDataResponseGetCompanyRestResultCompanyDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseGetCompanyRestResultKybDataDto
 */
export interface RestDataResponseGetCompanyRestResultKybDataDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseGetCompanyRestResultKybDataDto
     */
    'status': RestDataResponseGetCompanyRestResultKybDataDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseGetCompanyRestResultKybDataDto
     */
    'message'?: string;
    /**
     * 
     * @type {KybDataDto}
     * @memberof RestDataResponseGetCompanyRestResultKybDataDto
     */
    'data'?: KybDataDto;
}

export const RestDataResponseGetCompanyRestResultKybDataDtoStatusEnum = {
    Success: 'SUCCESS',
    NotFound: 'NOT_FOUND'
} as const;

export type RestDataResponseGetCompanyRestResultKybDataDtoStatusEnum = typeof RestDataResponseGetCompanyRestResultKybDataDtoStatusEnum[keyof typeof RestDataResponseGetCompanyRestResultKybDataDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseGetP2PUserStatusP2PUserSearchResultPublicRestDto
 */
export interface RestDataResponseGetP2PUserStatusP2PUserSearchResultPublicRestDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseGetP2PUserStatusP2PUserSearchResultPublicRestDto
     */
    'status': RestDataResponseGetP2PUserStatusP2PUserSearchResultPublicRestDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseGetP2PUserStatusP2PUserSearchResultPublicRestDto
     */
    'message'?: string;
    /**
     * 
     * @type {P2PUserSearchResultPublicRestDto}
     * @memberof RestDataResponseGetP2PUserStatusP2PUserSearchResultPublicRestDto
     */
    'data'?: P2PUserSearchResultPublicRestDto;
}

export const RestDataResponseGetP2PUserStatusP2PUserSearchResultPublicRestDtoStatusEnum = {
    Success: 'SUCCESS'
} as const;

export type RestDataResponseGetP2PUserStatusP2PUserSearchResultPublicRestDtoStatusEnum = typeof RestDataResponseGetP2PUserStatusP2PUserSearchResultPublicRestDtoStatusEnum[keyof typeof RestDataResponseGetP2PUserStatusP2PUserSearchResultPublicRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseGetUserStatusUserPublicRestDto
 */
export interface RestDataResponseGetUserStatusUserPublicRestDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseGetUserStatusUserPublicRestDto
     */
    'status': RestDataResponseGetUserStatusUserPublicRestDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseGetUserStatusUserPublicRestDto
     */
    'message'?: string;
    /**
     * 
     * @type {UserPublicRestDto}
     * @memberof RestDataResponseGetUserStatusUserPublicRestDto
     */
    'data'?: UserPublicRestDto;
}

export const RestDataResponseGetUserStatusUserPublicRestDtoStatusEnum = {
    Success: 'SUCCESS'
} as const;

export type RestDataResponseGetUserStatusUserPublicRestDtoStatusEnum = typeof RestDataResponseGetUserStatusUserPublicRestDtoStatusEnum[keyof typeof RestDataResponseGetUserStatusUserPublicRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseLimitsInfoStatusLimitsInfoResponse
 */
export interface RestDataResponseLimitsInfoStatusLimitsInfoResponse {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseLimitsInfoStatusLimitsInfoResponse
     */
    'status': RestDataResponseLimitsInfoStatusLimitsInfoResponseStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseLimitsInfoStatusLimitsInfoResponse
     */
    'message'?: string;
    /**
     * 
     * @type {LimitsInfoResponse}
     * @memberof RestDataResponseLimitsInfoStatusLimitsInfoResponse
     */
    'data'?: LimitsInfoResponse;
}

export const RestDataResponseLimitsInfoStatusLimitsInfoResponseStatusEnum = {
    Success: 'SUCCESS'
} as const;

export type RestDataResponseLimitsInfoStatusLimitsInfoResponseStatusEnum = typeof RestDataResponseLimitsInfoStatusLimitsInfoResponseStatusEnum[keyof typeof RestDataResponseLimitsInfoStatusLimitsInfoResponseStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseNewTokenForCompanyStatusNewTokenForCompanyResponse
 */
export interface RestDataResponseNewTokenForCompanyStatusNewTokenForCompanyResponse {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseNewTokenForCompanyStatusNewTokenForCompanyResponse
     */
    'status': RestDataResponseNewTokenForCompanyStatusNewTokenForCompanyResponseStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseNewTokenForCompanyStatusNewTokenForCompanyResponse
     */
    'message'?: string;
    /**
     * 
     * @type {NewTokenForCompanyResponse}
     * @memberof RestDataResponseNewTokenForCompanyStatusNewTokenForCompanyResponse
     */
    'data'?: NewTokenForCompanyResponse;
}

export const RestDataResponseNewTokenForCompanyStatusNewTokenForCompanyResponseStatusEnum = {
    Success: 'SUCCESS',
    CompanyNotFound: 'COMPANY_NOT_FOUND'
} as const;

export type RestDataResponseNewTokenForCompanyStatusNewTokenForCompanyResponseStatusEnum = typeof RestDataResponseNewTokenForCompanyStatusNewTokenForCompanyResponseStatusEnum[keyof typeof RestDataResponseNewTokenForCompanyStatusNewTokenForCompanyResponseStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseNewTokenForUserStatusNewTokenForUserResponse
 */
export interface RestDataResponseNewTokenForUserStatusNewTokenForUserResponse {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseNewTokenForUserStatusNewTokenForUserResponse
     */
    'status': RestDataResponseNewTokenForUserStatusNewTokenForUserResponseStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseNewTokenForUserStatusNewTokenForUserResponse
     */
    'message'?: string;
    /**
     * 
     * @type {NewTokenForUserResponse}
     * @memberof RestDataResponseNewTokenForUserStatusNewTokenForUserResponse
     */
    'data'?: NewTokenForUserResponse;
}

export const RestDataResponseNewTokenForUserStatusNewTokenForUserResponseStatusEnum = {
    Success: 'SUCCESS',
    UserNotFound: 'USER_NOT_FOUND'
} as const;

export type RestDataResponseNewTokenForUserStatusNewTokenForUserResponseStatusEnum = typeof RestDataResponseNewTokenForUserStatusNewTokenForUserResponseStatusEnum[keyof typeof RestDataResponseNewTokenForUserStatusNewTokenForUserResponseStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseP2PUserRequestResultListP2PUserSearchResultRestDto
 */
export interface RestDataResponseP2PUserRequestResultListP2PUserSearchResultRestDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseP2PUserRequestResultListP2PUserSearchResultRestDto
     */
    'status': RestDataResponseP2PUserRequestResultListP2PUserSearchResultRestDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseP2PUserRequestResultListP2PUserSearchResultRestDto
     */
    'message'?: string;
    /**
     * Response payload, present if status is SUCCESS
     * @type {Array<P2PUserSearchResultRestDto>}
     * @memberof RestDataResponseP2PUserRequestResultListP2PUserSearchResultRestDto
     */
    'data'?: Array<P2PUserSearchResultRestDto>;
}

export const RestDataResponseP2PUserRequestResultListP2PUserSearchResultRestDtoStatusEnum = {
    Success: 'SUCCESS'
} as const;

export type RestDataResponseP2PUserRequestResultListP2PUserSearchResultRestDtoStatusEnum = typeof RestDataResponseP2PUserRequestResultListP2PUserSearchResultRestDtoStatusEnum[keyof typeof RestDataResponseP2PUserRequestResultListP2PUserSearchResultRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseP2PUserRequestResultP2PUserSearchResultRestDto
 */
export interface RestDataResponseP2PUserRequestResultP2PUserSearchResultRestDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseP2PUserRequestResultP2PUserSearchResultRestDto
     */
    'status': RestDataResponseP2PUserRequestResultP2PUserSearchResultRestDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseP2PUserRequestResultP2PUserSearchResultRestDto
     */
    'message'?: string;
    /**
     * 
     * @type {P2PUserSearchResultRestDto}
     * @memberof RestDataResponseP2PUserRequestResultP2PUserSearchResultRestDto
     */
    'data'?: P2PUserSearchResultRestDto;
}

export const RestDataResponseP2PUserRequestResultP2PUserSearchResultRestDtoStatusEnum = {
    Success: 'SUCCESS'
} as const;

export type RestDataResponseP2PUserRequestResultP2PUserSearchResultRestDtoStatusEnum = typeof RestDataResponseP2PUserRequestResultP2PUserSearchResultRestDtoStatusEnum[keyof typeof RestDataResponseP2PUserRequestResultP2PUserSearchResultRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseStartKycResultStatusStartKycResponse
 */
export interface RestDataResponseStartKycResultStatusStartKycResponse {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseStartKycResultStatusStartKycResponse
     */
    'status': RestDataResponseStartKycResultStatusStartKycResponseStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseStartKycResultStatusStartKycResponse
     */
    'message'?: string;
    /**
     * 
     * @type {StartKycResponse}
     * @memberof RestDataResponseStartKycResultStatusStartKycResponse
     */
    'data'?: StartKycResponse;
}

export const RestDataResponseStartKycResultStatusStartKycResponseStatusEnum = {
    Sumsub: 'SUMSUB',
    Already: 'ALREADY'
} as const;

export type RestDataResponseStartKycResultStatusStartKycResponseStatusEnum = typeof RestDataResponseStartKycResultStatusStartKycResponseStatusEnum[keyof typeof RestDataResponseStartKycResultStatusStartKycResponseStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseUserKycResultKycDataPublicDto
 */
export interface RestDataResponseUserKycResultKycDataPublicDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseUserKycResultKycDataPublicDto
     */
    'status': RestDataResponseUserKycResultKycDataPublicDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseUserKycResultKycDataPublicDto
     */
    'message'?: string;
    /**
     * 
     * @type {KycDataPublicDto}
     * @memberof RestDataResponseUserKycResultKycDataPublicDto
     */
    'data'?: KycDataPublicDto;
}

export const RestDataResponseUserKycResultKycDataPublicDtoStatusEnum = {
    Success: 'SUCCESS',
    NotFound: 'NOT_FOUND'
} as const;

export type RestDataResponseUserKycResultKycDataPublicDtoStatusEnum = typeof RestDataResponseUserKycResultKycDataPublicDtoStatusEnum[keyof typeof RestDataResponseUserKycResultKycDataPublicDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseUserRequestResultKycDataDto
 */
export interface RestDataResponseUserRequestResultKycDataDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseUserRequestResultKycDataDto
     */
    'status': RestDataResponseUserRequestResultKycDataDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseUserRequestResultKycDataDto
     */
    'message'?: string;
    /**
     * 
     * @type {KycDataDto}
     * @memberof RestDataResponseUserRequestResultKycDataDto
     */
    'data'?: KycDataDto;
}

export const RestDataResponseUserRequestResultKycDataDtoStatusEnum = {
    Success: 'SUCCESS',
    NotFound: 'NOT_FOUND'
} as const;

export type RestDataResponseUserRequestResultKycDataDtoStatusEnum = typeof RestDataResponseUserRequestResultKycDataDtoStatusEnum[keyof typeof RestDataResponseUserRequestResultKycDataDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseUserRequestResultListUserRestDto
 */
export interface RestDataResponseUserRequestResultListUserRestDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseUserRequestResultListUserRestDto
     */
    'status': RestDataResponseUserRequestResultListUserRestDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseUserRequestResultListUserRestDto
     */
    'message'?: string;
    /**
     * Response payload, present if status is SUCCESS
     * @type {Array<UserRestDto>}
     * @memberof RestDataResponseUserRequestResultListUserRestDto
     */
    'data'?: Array<UserRestDto>;
}

export const RestDataResponseUserRequestResultListUserRestDtoStatusEnum = {
    Success: 'SUCCESS',
    NotFound: 'NOT_FOUND'
} as const;

export type RestDataResponseUserRequestResultListUserRestDtoStatusEnum = typeof RestDataResponseUserRequestResultListUserRestDtoStatusEnum[keyof typeof RestDataResponseUserRequestResultListUserRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseUserRequestResultUserRestDto
 */
export interface RestDataResponseUserRequestResultUserRestDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseUserRequestResultUserRestDto
     */
    'status': RestDataResponseUserRequestResultUserRestDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseUserRequestResultUserRestDto
     */
    'message'?: string;
    /**
     * 
     * @type {UserRestDto}
     * @memberof RestDataResponseUserRequestResultUserRestDto
     */
    'data'?: UserRestDto;
}

export const RestDataResponseUserRequestResultUserRestDtoStatusEnum = {
    Success: 'SUCCESS',
    NotFound: 'NOT_FOUND'
} as const;

export type RestDataResponseUserRequestResultUserRestDtoStatusEnum = typeof RestDataResponseUserRequestResultUserRestDtoStatusEnum[keyof typeof RestDataResponseUserRequestResultUserRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestResponseDisableP2PUserRequestResult
 */
export interface RestResponseDisableP2PUserRequestResult {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestResponseDisableP2PUserRequestResult
     */
    'status': RestResponseDisableP2PUserRequestResultStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestResponseDisableP2PUserRequestResult
     */
    'message'?: string;
}

export const RestResponseDisableP2PUserRequestResultStatusEnum = {
    Success: 'SUCCESS'
} as const;

export type RestResponseDisableP2PUserRequestResultStatusEnum = typeof RestResponseDisableP2PUserRequestResultStatusEnum[keyof typeof RestResponseDisableP2PUserRequestResultStatusEnum];

/**
 * 
 * @export
 * @interface RestResponseDisableUserPermissionsRequestResult
 */
export interface RestResponseDisableUserPermissionsRequestResult {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestResponseDisableUserPermissionsRequestResult
     */
    'status': RestResponseDisableUserPermissionsRequestResultStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestResponseDisableUserPermissionsRequestResult
     */
    'message'?: string;
}

export const RestResponseDisableUserPermissionsRequestResultStatusEnum = {
    Success: 'SUCCESS',
    UserNotFound: 'USER_NOT_FOUND',
    PermissionsNotFound: 'PERMISSIONS_NOT_FOUND'
} as const;

export type RestResponseDisableUserPermissionsRequestResultStatusEnum = typeof RestResponseDisableUserPermissionsRequestResultStatusEnum[keyof typeof RestResponseDisableUserPermissionsRequestResultStatusEnum];

/**
 * 
 * @export
 * @interface RestResponseInitializeP2PUserRestStatus
 */
export interface RestResponseInitializeP2PUserRestStatus {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestResponseInitializeP2PUserRestStatus
     */
    'status': RestResponseInitializeP2PUserRestStatusStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestResponseInitializeP2PUserRestStatus
     */
    'message'?: string;
}

export const RestResponseInitializeP2PUserRestStatusStatusEnum = {
    Success: 'SUCCESS',
    UnableToChooseNickname: 'UNABLE_TO_CHOOSE_NICKNAME'
} as const;

export type RestResponseInitializeP2PUserRestStatusStatusEnum = typeof RestResponseInitializeP2PUserRestStatusStatusEnum[keyof typeof RestResponseInitializeP2PUserRestStatusStatusEnum];

/**
 * 
 * @export
 * @interface RestResponseUpdatePhoneNumberStatus
 */
export interface RestResponseUpdatePhoneNumberStatus {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestResponseUpdatePhoneNumberStatus
     */
    'status': RestResponseUpdatePhoneNumberStatusStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestResponseUpdatePhoneNumberStatus
     */
    'message'?: string;
}

export const RestResponseUpdatePhoneNumberStatusStatusEnum = {
    Success: 'SUCCESS',
    Failure: 'FAILURE'
} as const;

export type RestResponseUpdatePhoneNumberStatusStatusEnum = typeof RestResponseUpdatePhoneNumberStatusStatusEnum[keyof typeof RestResponseUpdatePhoneNumberStatusStatusEnum];

/**
 * 
 * @export
 * @interface StartKycRequest
 */
export interface StartKycRequest {
    /**
     * 
     * @type {string}
     * @memberof StartKycRequest
     */
    'level': StartKycRequestLevelEnum;
}

export const StartKycRequestLevelEnum = {
    _0: 'LEVEL_0',
    _1: 'LEVEL_1',
    _2: 'LEVEL_2',
    _3: 'LEVEL_3',
    _4: 'LEVEL_4'
} as const;

export type StartKycRequestLevelEnum = typeof StartKycRequestLevelEnum[keyof typeof StartKycRequestLevelEnum];

/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface StartKycResponse
 */
export interface StartKycResponse {
    /**
     * 
     * @type {string}
     * @memberof StartKycResponse
     */
    'accessToken': string;
}
/**
 * 
 * @export
 * @interface StateSnapshot
 */
export interface StateSnapshot {
    /**
     * 
     * @type {string}
     * @memberof StateSnapshot
     */
    'updatedDateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof StateSnapshot
     */
    'reviewStatus'?: StateSnapshotReviewStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof StateSnapshot
     */
    'isFinalReject': boolean;
    /**
     * 
     * @type {string}
     * @memberof StateSnapshot
     */
    'currentLevel'?: string;
    /**
     * 
     * @type {string}
     * @memberof StateSnapshot
     */
    'forcedLevel'?: string;
}

export const StateSnapshotReviewStatusEnum = {
    Init: 'init',
    Pending: 'pending',
    Prechecked: 'prechecked',
    Queued: 'queued',
    Completed: 'completed',
    OnHold: 'onHold'
} as const;

export type StateSnapshotReviewStatusEnum = typeof StateSnapshotReviewStatusEnum[keyof typeof StateSnapshotReviewStatusEnum];

/**
 * 
 * @export
 * @interface TokenForCompanyRequest
 */
export interface TokenForCompanyRequest {
    /**
     * 
     * @type {number}
     * @memberof TokenForCompanyRequest
     */
    'companyId': number;
    /**
     * 
     * @type {string}
     * @memberof TokenForCompanyRequest
     */
    'level': TokenForCompanyRequestLevelEnum;
    /**
     * 
     * @type {string}
     * @memberof TokenForCompanyRequest
     */
    'ttl'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenForCompanyRequest
     */
    'externalActionId'?: string;
}

export const TokenForCompanyRequestLevelEnum = {
    Standard: 'WALLET_PAY_STANDARD',
    Enhanced: 'WALLET_PAY_ENHANCED'
} as const;

export type TokenForCompanyRequestLevelEnum = typeof TokenForCompanyRequestLevelEnum[keyof typeof TokenForCompanyRequestLevelEnum];

/**
 * 
 * @export
 * @interface TokenForUserRequest
 */
export interface TokenForUserRequest {
    /**
     * 
     * @type {number}
     * @memberof TokenForUserRequest
     */
    'userId': number;
    /**
     * 
     * @type {string}
     * @memberof TokenForUserRequest
     */
    'level': TokenForUserRequestLevelEnum;
    /**
     * 
     * @type {string}
     * @memberof TokenForUserRequest
     */
    'ttl'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenForUserRequest
     */
    'externalActionId'?: string;
}

export const TokenForUserRequestLevelEnum = {
    _0: 'LEVEL_0',
    _1: 'LEVEL_1',
    _2: 'LEVEL_2',
    _3: 'LEVEL_3',
    _4: 'LEVEL_4'
} as const;

export type TokenForUserRequestLevelEnum = typeof TokenForUserRequestLevelEnum[keyof typeof TokenForUserRequestLevelEnum];

/**
 * 
 * @export
 * @interface UpdatePhoneNumberRequest
 */
export interface UpdatePhoneNumberRequest {
    /**
     * 
     * @type {number}
     * @memberof UpdatePhoneNumberRequest
     */
    'userId': number;
    /**
     * 
     * @type {string}
     * @memberof UpdatePhoneNumberRequest
     */
    'phoneNumber': string;
}
/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'userId': number;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'telegramUserId': number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'externalId': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'displayNickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'avatarCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'locale': string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'p2pInitialized': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'canUseP2p': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'isBanned': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof User
     */
    'disabledFeatureFlags': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof User
     */
    'bannedPermissions': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'isEligibleForTokens'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'eligibilityForTokensCheckDateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'phoneNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'countryCodeAlpha2'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'comment'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'isAnAnonymousFragmentPhoneNumber': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof User
     */
    'deviceIds': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof User
     */
    'ipAddresses': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'kycCountryCodeAlpha3'?: string;
    /**
     * 
     * @type {VerificationStateUserKycLevel}
     * @memberof User
     */
    'verificationState'?: VerificationStateUserKycLevel;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'allowedToSendMessages': boolean;
}
/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface UserEligibleForTokensValidationResultRestDto
 */
export interface UserEligibleForTokensValidationResultRestDto {
    /**
     * 
     * @type {number}
     * @memberof UserEligibleForTokensValidationResultRestDto
     */
    'userId': number;
    /**
     * 
     * @type {boolean}
     * @memberof UserEligibleForTokensValidationResultRestDto
     */
    'valid': boolean;
}
/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface UserPublicRestDto
 */
export interface UserPublicRestDto {
    /**
     * 
     * @type {number}
     * @memberof UserPublicRestDto
     */
    'userId': number;
    /**
     * 
     * @type {number}
     * @memberof UserPublicRestDto
     */
    'telegramUserId': number;
    /**
     * 
     * @type {string}
     * @memberof UserPublicRestDto
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserPublicRestDto
     */
    'displayNickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserPublicRestDto
     */
    'avatarCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserPublicRestDto
     */
    'locale': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserPublicRestDto
     */
    'p2pInitialized': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPublicRestDto
     */
    'canUseP2p': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPublicRestDto
     */
    'isBanned': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserPublicRestDto
     */
    'disabledFeatureFlags': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserPublicRestDto
     */
    'bannedPermissions': Array<string>;
}
/**
 * 
 * @export
 * @interface UserRequest
 */
export interface UserRequest {
    /**
     * 
     * @type {number}
     * @memberof UserRequest
     */
    'userId': number;
}
/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface UserRestDto
 */
export interface UserRestDto {
    /**
     * 
     * @type {number}
     * @memberof UserRestDto
     */
    'userId': number;
    /**
     * 
     * @type {number}
     * @memberof UserRestDto
     */
    'telegramUserId': number;
    /**
     * 
     * @type {string}
     * @memberof UserRestDto
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRestDto
     */
    'displayNickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRestDto
     */
    'avatarCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRestDto
     */
    'locale': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserRestDto
     */
    'p2pInitialized': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserRestDto
     */
    'canUseP2p': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserRestDto
     */
    'isBanned': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserRestDto
     */
    'disabledFeatureFlags': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserRestDto
     */
    'bannedPermissions': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof UserRestDto
     */
    'isEligibleForTokens'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserRestDto
     */
    'eligibilityForTokensCheckDateTime'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserRestDto
     */
    'isPhoneNumberPresent': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserRestDto
     */
    'isAnAnonymousFragmentPhoneNumber': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserRestDto
     */
    'deviceIds': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserRestDto
     */
    'ipAddresses': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UserRestDto
     */
    'countryCodeAlpha2'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRestDto
     */
    'kycCountryCodeAlpha3'?: string;
    /**
     * 
     * @type {Blocked | Verified}
     * @memberof UserRestDto
     */
    'kycStatus': Blocked | Verified;
}
/**
 * 
 * @export
 * @interface UsersByDeviceIdsRequest
 */
export interface UsersByDeviceIdsRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof UsersByDeviceIdsRequest
     */
    'deviceIds': Array<string>;
}
/**
 * 
 * @export
 * @interface UsersRequest
 */
export interface UsersRequest {
    /**
     * 
     * @type {Array<number>}
     * @memberof UsersRequest
     */
    'userIds': Array<number>;
}
/**
 * 
 * @export
 * @interface VerificationProcessDto
 */
export interface VerificationProcessDto {
    /**
     * 
     * @type {string}
     * @memberof VerificationProcessDto
     */
    'updatedDateTime': string;
    /**
     * 
     * @type {string}
     * @memberof VerificationProcessDto
     */
    'expirationDateTime': string;
    /**
     * 
     * @type {string}
     * @memberof VerificationProcessDto
     */
    'status': VerificationProcessDtoStatusEnum;
}

export const VerificationProcessDtoStatusEnum = {
    Requested: 'REQUESTED',
    Started: 'STARTED',
    Completed: 'COMPLETED'
} as const;

export type VerificationProcessDtoStatusEnum = typeof VerificationProcessDtoStatusEnum[keyof typeof VerificationProcessDtoStatusEnum];

/**
 * 
 * @export
 * @interface VerificationProcessPublicDto
 */
export interface VerificationProcessPublicDto {
    /**
     * 
     * @type {string}
     * @memberof VerificationProcessPublicDto
     */
    'updatedDateTime': string;
    /**
     * 
     * @type {string}
     * @memberof VerificationProcessPublicDto
     */
    'expirationDateTime': string;
    /**
     * 
     * @type {string}
     * @memberof VerificationProcessPublicDto
     */
    'status': VerificationProcessPublicDtoStatusEnum;
}

export const VerificationProcessPublicDtoStatusEnum = {
    Requested: 'REQUESTED',
    Started: 'STARTED',
    Completed: 'COMPLETED'
} as const;

export type VerificationProcessPublicDtoStatusEnum = typeof VerificationProcessPublicDtoStatusEnum[keyof typeof VerificationProcessPublicDtoStatusEnum];

/**
 * 
 * @export
 * @interface VerificationStateUserKycLevel
 */
export interface VerificationStateUserKycLevel {
    /**
     * 
     * @type {string}
     * @memberof VerificationStateUserKycLevel
     */
    'updatedDateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof VerificationStateUserKycLevel
     */
    'reviewStatus'?: VerificationStateUserKycLevelReviewStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof VerificationStateUserKycLevel
     */
    'isFinalReject': boolean;
    /**
     * 
     * @type {string}
     * @memberof VerificationStateUserKycLevel
     */
    'currentLevel'?: VerificationStateUserKycLevelCurrentLevelEnum;
    /**
     * 
     * @type {string}
     * @memberof VerificationStateUserKycLevel
     */
    'forcedLevel'?: VerificationStateUserKycLevelForcedLevelEnum;
    /**
     * 
     * @type {StateSnapshot}
     * @memberof VerificationStateUserKycLevel
     */
    'changelogSnapshot': StateSnapshot;
}

export const VerificationStateUserKycLevelReviewStatusEnum = {
    Init: 'init',
    Pending: 'pending',
    Prechecked: 'prechecked',
    Queued: 'queued',
    Completed: 'completed',
    OnHold: 'onHold'
} as const;

export type VerificationStateUserKycLevelReviewStatusEnum = typeof VerificationStateUserKycLevelReviewStatusEnum[keyof typeof VerificationStateUserKycLevelReviewStatusEnum];
export const VerificationStateUserKycLevelCurrentLevelEnum = {
    Poi: 'POI',
    PoiSelfie: 'POI_SELFIE',
    PoiSelfiePoa: 'POI_SELFIE_POA'
} as const;

export type VerificationStateUserKycLevelCurrentLevelEnum = typeof VerificationStateUserKycLevelCurrentLevelEnum[keyof typeof VerificationStateUserKycLevelCurrentLevelEnum];
export const VerificationStateUserKycLevelForcedLevelEnum = {
    Poi: 'POI',
    PoiSelfie: 'POI_SELFIE',
    PoiSelfiePoa: 'POI_SELFIE_POA'
} as const;

export type VerificationStateUserKycLevelForcedLevelEnum = typeof VerificationStateUserKycLevelForcedLevelEnum[keyof typeof VerificationStateUserKycLevelForcedLevelEnum];

/**
 * 
 * @export
 * @interface Verified
 */
export interface Verified extends KycStatus {
    /**
     * 
     * @type {string}
     * @memberof Verified
     */
    'level': VerifiedLevelEnum;
}

export const VerifiedLevelEnum = {
    _0: 'LEVEL_0',
    _1: 'LEVEL_1',
    _2: 'LEVEL_2',
    _3: 'LEVEL_3',
    _4: 'LEVEL_4'
} as const;

export type VerifiedLevelEnum = typeof VerifiedLevelEnum[keyof typeof VerifiedLevelEnum];

/**
 * 
 * @export
 * @interface VerifiedAllOf
 */
export interface VerifiedAllOf {
    /**
     * 
     * @type {string}
     * @memberof VerifiedAllOf
     */
    'level'?: VerifiedAllOfLevelEnum;
}

export const VerifiedAllOfLevelEnum = {
    _0: 'LEVEL_0',
    _1: 'LEVEL_1',
    _2: 'LEVEL_2',
    _3: 'LEVEL_3',
    _4: 'LEVEL_4'
} as const;

export type VerifiedAllOfLevelEnum = typeof VerifiedAllOfLevelEnum[keyof typeof VerifiedAllOfLevelEnum];


/**
 * ApplicationRestApi - axios parameter creator
 * @export
 */
export const ApplicationRestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationRestApi - functional programming interface
 * @export
 */
export const ApplicationRestApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationRestApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatus(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationRestApi - factory interface
 * @export
 */
export const ApplicationRestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationRestApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(options?: any): AxiosPromise<ApplicationInfo> {
            return localVarFp.getStatus(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationRestApi - object-oriented interface
 * @export
 * @class ApplicationRestApi
 * @extends {BaseAPI}
 */
export class ApplicationRestApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationRestApi
     */
    public getStatus(options?: AxiosRequestConfig) {
        return ApplicationRestApiFp(this.configuration).getStatus(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authorize Wallet user by telegram authorization data 
         * @param {{ [key: string]: string; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizeByTelegram: async (requestBody: { [key: string]: string; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('authorizeByTelegram', 'requestBody', requestBody)
            const localVarPath = `/users/public-api/v1/auth/authorize-by-telegram`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Authorize Wallet user by telegram authorization data 
         * @param {{ [key: string]: string; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorizeByTelegram(requestBody: { [key: string]: string; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseAuthorizeByTelegramStatusAuthorizeByTelegramRestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorizeByTelegram(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Authorize Wallet user by telegram authorization data 
         * @param {{ [key: string]: string; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizeByTelegram(requestBody: { [key: string]: string; }, options?: any): AxiosPromise<RestDataResponseAuthorizeByTelegramStatusAuthorizeByTelegramRestResponse> {
            return localVarFp.authorizeByTelegram(requestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Authorize Wallet user by telegram authorization data 
     * @param {{ [key: string]: string; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authorizeByTelegram(requestBody: { [key: string]: string; }, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authorizeByTelegram(requestBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CompanyApi - axios parameter creator
 * @export
 */
export const CompanyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/internal-api/v1/company/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} companyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (companyId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('get', 'companyId', companyId)
            const localVarPath = `/users/internal-api/v1/company/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (companyId !== undefined) {
                localVarQueryParameter['company-id'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * KYB polling method
         * @param {number} companyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKyb: async (companyId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getKyb', 'companyId', companyId)
            const localVarPath = `/users/internal-api/v1/company/get-kyb`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (companyId !== undefined) {
                localVarQueryParameter['company-id'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CompanyApi - functional programming interface
 * @export
 */
export const CompanyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CompanyApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseCreateCompanyRestResultCompanyDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} companyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(companyId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseGetCompanyRestResultCompanyDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get(companyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * KYB polling method
         * @param {number} companyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKyb(companyId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseGetCompanyRestResultKybDataDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKyb(companyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CompanyApi - factory interface
 * @export
 */
export const CompanyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CompanyApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(options?: any): AxiosPromise<RestDataResponseCreateCompanyRestResultCompanyDto> {
            return localVarFp.create(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} companyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(companyId: number, options?: any): AxiosPromise<RestDataResponseGetCompanyRestResultCompanyDto> {
            return localVarFp.get(companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * KYB polling method
         * @param {number} companyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKyb(companyId: number, options?: any): AxiosPromise<RestDataResponseGetCompanyRestResultKybDataDto> {
            return localVarFp.getKyb(companyId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CompanyApi - object-oriented interface
 * @export
 * @class CompanyApi
 * @extends {BaseAPI}
 */
export class CompanyApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyApi
     */
    public create(options?: AxiosRequestConfig) {
        return CompanyApiFp(this.configuration).create(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} companyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyApi
     */
    public get(companyId: number, options?: AxiosRequestConfig) {
        return CompanyApiFp(this.configuration).get(companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * KYB polling method
     * @param {number} companyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyApi
     */
    public getKyb(companyId: number, options?: AxiosRequestConfig) {
        return CompanyApiFp(this.configuration).getKyb(companyId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HealthCheckRestApi - axios parameter creator
 * @export
 */
export const HealthCheckRestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourcesHealthStatus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthCheckRestApi - functional programming interface
 * @export
 */
export const HealthCheckRestApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthCheckRestApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resourcesHealthStatus(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resourcesHealthStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HealthCheckRestApi - factory interface
 * @export
 */
export const HealthCheckRestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthCheckRestApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourcesHealthStatus(options?: any): AxiosPromise<HealthStatusResponse> {
            return localVarFp.resourcesHealthStatus(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthCheckRestApi - object-oriented interface
 * @export
 * @class HealthCheckRestApi
 * @extends {BaseAPI}
 */
export class HealthCheckRestApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthCheckRestApi
     */
    public resourcesHealthStatus(options?: AxiosRequestConfig) {
        return HealthCheckRestApiFp(this.configuration).resourcesHealthStatus(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InternalApi - axios parameter creator
 * @export
 */
export const InternalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Создать тестового пользователя
         * @param {CreateTestUserRequest} createTestUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTestUser: async (createTestUserRequest: CreateTestUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTestUserRequest' is not null or undefined
            assertParamExists('createTestUser', 'createTestUserRequest', createTestUserRequest)
            const localVarPath = `/system/user/create-test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTestUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InternalApi - functional programming interface
 * @export
 */
export const InternalApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InternalApiAxiosParamCreator(configuration)
    return {
        /**
         * Создать тестового пользователя
         * @param {CreateTestUserRequest} createTestUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTestUser(createTestUserRequest: CreateTestUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseCreateUserStatusUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTestUser(createTestUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InternalApi - factory interface
 * @export
 */
export const InternalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InternalApiFp(configuration)
    return {
        /**
         * Создать тестового пользователя
         * @param {CreateTestUserRequest} createTestUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTestUser(createTestUserRequest: CreateTestUserRequest, options?: any): AxiosPromise<RestDataResponseCreateUserStatusUser> {
            return localVarFp.createTestUser(createTestUserRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InternalApi - object-oriented interface
 * @export
 * @class InternalApi
 * @extends {BaseAPI}
 */
export class InternalApi extends BaseAPI {
    /**
     * Создать тестового пользователя
     * @param {CreateTestUserRequest} createTestUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public createTestUser(createTestUserRequest: CreateTestUserRequest, options?: AxiosRequestConfig) {
        return InternalApiFp(this.configuration).createTestUser(createTestUserRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProfilerReporterRestApi - axios parameter creator
 * @export
 */
export const ProfilerReporterRestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metrics: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system/prometheus/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfilerReporterRestApi - functional programming interface
 * @export
 */
export const ProfilerReporterRestApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfilerReporterRestApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metrics(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metrics(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProfilerReporterRestApi - factory interface
 * @export
 */
export const ProfilerReporterRestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfilerReporterRestApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metrics(options?: any): AxiosPromise<string> {
            return localVarFp.metrics(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProfilerReporterRestApi - object-oriented interface
 * @export
 * @class ProfilerReporterRestApi
 * @extends {BaseAPI}
 */
export class ProfilerReporterRestApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilerReporterRestApi
     */
    public metrics(options?: AxiosRequestConfig) {
        return ProfilerReporterRestApiFp(this.configuration).metrics(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SumsubWebhookApi - axios parameter creator
 * @export
 */
export const SumsubWebhookApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} xPayloadDigest 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receiveWebhook: async (xPayloadDigest: string, body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xPayloadDigest' is not null or undefined
            assertParamExists('receiveWebhook', 'xPayloadDigest', xPayloadDigest)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('receiveWebhook', 'body', body)
            const localVarPath = `/users/webhook/sumsub`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xPayloadDigest !== undefined && xPayloadDigest !== null) {
                localVarHeaderParameter['x-payload-digest'] = String(xPayloadDigest);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SumsubWebhookApi - functional programming interface
 * @export
 */
export const SumsubWebhookApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SumsubWebhookApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} xPayloadDigest 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async receiveWebhook(xPayloadDigest: string, body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.receiveWebhook(xPayloadDigest, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SumsubWebhookApi - factory interface
 * @export
 */
export const SumsubWebhookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SumsubWebhookApiFp(configuration)
    return {
        /**
         * 
         * @param {string} xPayloadDigest 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receiveWebhook(xPayloadDigest: string, body: string, options?: any): AxiosPromise<object> {
            return localVarFp.receiveWebhook(xPayloadDigest, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SumsubWebhookApi - object-oriented interface
 * @export
 * @class SumsubWebhookApi
 * @extends {BaseAPI}
 */
export class SumsubWebhookApi extends BaseAPI {
    /**
     * 
     * @param {string} xPayloadDigest 
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SumsubWebhookApi
     */
    public receiveWebhook(xPayloadDigest: string, body: string, options?: AxiosRequestConfig) {
        return SumsubWebhookApiFp(this.configuration).receiveWebhook(xPayloadDigest, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Проверить пользователя на антифрод методами Telegram
         * @param {UserRequest} userRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkIsUserEligibleForTokens: async (userRequest: UserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userRequest' is not null or undefined
            assertParamExists('checkIsUserEligibleForTokens', 'userRequest', userRequest)
            const localVarPath = `/users/internal-api/v2/user/check-is-user-eligible-for-tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Проверить пользователя на антифрод методами Telegram
         * @param {UserRequest} userRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkIsUserEligibleForTokens1: async (userRequest: UserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userRequest' is not null or undefined
            assertParamExists('checkIsUserEligibleForTokens1', 'userRequest', userRequest)
            const localVarPath = `/users/internal-api/v1/user/check-is-user-eligible-for-tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Заблокировать P2P для пользователя
         * @param {DisableP2PUserRequest} disableP2PUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableP2PUser: async (disableP2PUserRequest: DisableP2PUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'disableP2PUserRequest' is not null or undefined
            assertParamExists('disableP2PUser', 'disableP2PUserRequest', disableP2PUserRequest)
            const localVarPath = `/users/internal-api/v2/user/disable-p2p-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(disableP2PUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Заблокировать P2P для пользователя
         * @param {DisableP2PUserRequest} disableP2PUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableP2PUser1: async (disableP2PUserRequest: DisableP2PUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'disableP2PUserRequest' is not null or undefined
            assertParamExists('disableP2PUser1', 'disableP2PUserRequest', disableP2PUserRequest)
            const localVarPath = `/users/internal-api/v1/user/disable-p2p-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(disableP2PUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disable user permissions
         * @param {DisableUserPermissionsRestRequest} disableUserPermissionsRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableUser: async (disableUserPermissionsRestRequest: DisableUserPermissionsRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'disableUserPermissionsRestRequest' is not null or undefined
            assertParamExists('disableUser', 'disableUserPermissionsRestRequest', disableUserPermissionsRestRequest)
            const localVarPath = `/users/internal-api/v2/user/disable-user-permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(disableUserPermissionsRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disable user permissions
         * @param {DisableUserPermissionsRestRequest} disableUserPermissionsRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableUser1: async (disableUserPermissionsRestRequest: DisableUserPermissionsRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'disableUserPermissionsRestRequest' is not null or undefined
            assertParamExists('disableUser1', 'disableUserPermissionsRestRequest', disableUserPermissionsRestRequest)
            const localVarPath = `/users/internal-api/v1/user/disable-user-permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(disableUserPermissionsRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * KYC polling method
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKyc: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/public-api/v2/user/get-kyc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * KYC polling method
         * @param {UserRequest} userRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKyc1: async (userRequest: UserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userRequest' is not null or undefined
            assertParamExists('getKyc1', 'userRequest', userRequest)
            const localVarPath = `/users/internal-api/v2/user/get-kyc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * KYC polling method
         * @param {UserRequest} userRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKyc2: async (userRequest: UserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userRequest' is not null or undefined
            assertParamExists('getKyc2', 'userRequest', userRequest)
            const localVarPath = `/users/internal-api/v1/user/get-kyc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получить лимиты для пользователя по KYC-уровням
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLimits: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/public-api/v2/user/limitsSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получить P2P пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getP2PUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/public-api/v1/user/get-p2p-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получить пользователя
         * @param {GetUserRequest} getUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (getUserRequest: GetUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getUserRequest' is not null or undefined
            assertParamExists('getUser', 'getUserRequest', getUserRequest)
            const localVarPath = `/users/public-api/v2/user/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получить пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser1: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/public-api/v1/user/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получить пользователя
         * @param {UserRequest} userRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser2: async (userRequest: UserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userRequest' is not null or undefined
            assertParamExists('getUser2', 'userRequest', userRequest)
            const localVarPath = `/users/internal-api/v2/user/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получить пользователя
         * @param {UserRequest} userRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser3: async (userRequest: UserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userRequest' is not null or undefined
            assertParamExists('getUser3', 'userRequest', userRequest)
            const localVarPath = `/users/internal-api/v1/user/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Найти wallet пользователя по telegram id
         * @param {number} telegramId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByTelegramId: async (telegramId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'telegramId' is not null or undefined
            assertParamExists('getUserByTelegramId', 'telegramId', telegramId)
            const localVarPath = `/users/internal-api/v2/user/get-by-tg-id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (telegramId !== undefined) {
                localVarQueryParameter['telegram-id'] = telegramId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Найти wallet пользователя по telegram id
         * @param {number} telegramId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByTelegramId1: async (telegramId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'telegramId' is not null or undefined
            assertParamExists('getUserByTelegramId1', 'telegramId', telegramId)
            const localVarPath = `/users/internal-api/v1/user/get-by-tg-id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (telegramId !== undefined) {
                localVarQueryParameter['telegram-id'] = telegramId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получить P2P пользователя
         * @param {UserRequest} userRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (userRequest: UserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userRequest' is not null or undefined
            assertParamExists('getUsers', 'userRequest', userRequest)
            const localVarPath = `/users/internal-api/v2/user/get-p2p-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получить P2P пользователей
         * @param {UsersRequest} usersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers1: async (usersRequest: UsersRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usersRequest' is not null or undefined
            assertParamExists('getUsers1', 'usersRequest', usersRequest)
            const localVarPath = `/users/internal-api/v2/user/get-p2p-users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получить P2P пользователя
         * @param {UserRequest} userRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers2: async (userRequest: UserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userRequest' is not null or undefined
            assertParamExists('getUsers2', 'userRequest', userRequest)
            const localVarPath = `/users/internal-api/v1/user/get-p2p-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получить P2P пользователей
         * @param {UsersRequest} usersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers3: async (usersRequest: UsersRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usersRequest' is not null or undefined
            assertParamExists('getUsers3', 'usersRequest', usersRequest)
            const localVarPath = `/users/internal-api/v1/user/get-p2p-users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получить пользователей по device ids
         * @param {UsersByDeviceIdsRequest} usersByDeviceIdsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersByDeviceIds: async (usersByDeviceIdsRequest: UsersByDeviceIdsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usersByDeviceIdsRequest' is not null or undefined
            assertParamExists('getUsersByDeviceIds', 'usersByDeviceIdsRequest', usersByDeviceIdsRequest)
            const localVarPath = `/users/internal-api/v2/user/get-users-by-device-ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersByDeviceIdsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получить пользователей по device ids
         * @param {UsersByDeviceIdsRequest} usersByDeviceIdsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersByDeviceIds1: async (usersByDeviceIdsRequest: UsersByDeviceIdsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usersByDeviceIdsRequest' is not null or undefined
            assertParamExists('getUsersByDeviceIds1', 'usersByDeviceIdsRequest', usersByDeviceIdsRequest)
            const localVarPath = `/users/internal-api/v1/user/get-users-by-device-ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersByDeviceIdsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Инициализировать P2P пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initializeP2PUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/public-api/v1/user/initialize-p2p-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * start KYC process
         * @param {StartKycRequest} startKycRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startKyc: async (startKycRequest: StartKycRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startKycRequest' is not null or undefined
            assertParamExists('startKyc', 'startKycRequest', startKycRequest)
            const localVarPath = `/users/public-api/v2/user/start-kyc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(startKycRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Обновить телефон пользователя
         * @param {UpdatePhoneNumberRequest} updatePhoneNumberRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePhoneNumber: async (updatePhoneNumberRequest: UpdatePhoneNumberRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updatePhoneNumberRequest' is not null or undefined
            assertParamExists('updatePhoneNumber', 'updatePhoneNumberRequest', updatePhoneNumberRequest)
            const localVarPath = `/users/internal-api/v2/user/update-phone-number`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePhoneNumberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Обновить телефон пользователя
         * @param {UpdatePhoneNumberRequest} updatePhoneNumberRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePhoneNumber1: async (updatePhoneNumberRequest: UpdatePhoneNumberRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updatePhoneNumberRequest' is not null or undefined
            assertParamExists('updatePhoneNumber1', 'updatePhoneNumberRequest', updatePhoneNumberRequest)
            const localVarPath = `/users/internal-api/v1/user/update-phone-number`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePhoneNumberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Проверить пользователя на антифрод методами Telegram
         * @param {UserRequest} userRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkIsUserEligibleForTokens(userRequest: UserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseCheckIsUserEligibleForTokensRestStatusUserEligibleForTokensValidationResultRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkIsUserEligibleForTokens(userRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Проверить пользователя на антифрод методами Telegram
         * @param {UserRequest} userRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkIsUserEligibleForTokens1(userRequest: UserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseCheckIsUserEligibleForTokensRestStatusUserEligibleForTokensValidationResultRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkIsUserEligibleForTokens1(userRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Заблокировать P2P для пользователя
         * @param {DisableP2PUserRequest} disableP2PUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableP2PUser(disableP2PUserRequest: DisableP2PUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseDisableP2PUserRequestResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableP2PUser(disableP2PUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Заблокировать P2P для пользователя
         * @param {DisableP2PUserRequest} disableP2PUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableP2PUser1(disableP2PUserRequest: DisableP2PUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseDisableP2PUserRequestResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableP2PUser1(disableP2PUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Disable user permissions
         * @param {DisableUserPermissionsRestRequest} disableUserPermissionsRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableUser(disableUserPermissionsRestRequest: DisableUserPermissionsRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseDisableUserPermissionsRequestResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableUser(disableUserPermissionsRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Disable user permissions
         * @param {DisableUserPermissionsRestRequest} disableUserPermissionsRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableUser1(disableUserPermissionsRestRequest: DisableUserPermissionsRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseDisableUserPermissionsRequestResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableUser1(disableUserPermissionsRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * KYC polling method
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKyc(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseUserKycResultKycDataPublicDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKyc(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * KYC polling method
         * @param {UserRequest} userRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKyc1(userRequest: UserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseUserRequestResultKycDataDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKyc1(userRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * KYC polling method
         * @param {UserRequest} userRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKyc2(userRequest: UserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseUserRequestResultKycDataDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKyc2(userRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Получить лимиты для пользователя по KYC-уровням
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLimits(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseLimitsInfoStatusLimitsInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLimits(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Получить P2P пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getP2PUser(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseGetP2PUserStatusP2PUserSearchResultPublicRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getP2PUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Получить пользователя
         * @param {GetUserRequest} getUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(getUserRequest: GetUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseGetUserStatusUserPublicRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(getUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Получить пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser1(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseGetUserStatusUserPublicRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser1(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Получить пользователя
         * @param {UserRequest} userRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser2(userRequest: UserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseUserRequestResultUserRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser2(userRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Получить пользователя
         * @param {UserRequest} userRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser3(userRequest: UserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseUserRequestResultUserRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser3(userRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Найти wallet пользователя по telegram id
         * @param {number} telegramId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserByTelegramId(telegramId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseUserRequestResultUserRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserByTelegramId(telegramId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Найти wallet пользователя по telegram id
         * @param {number} telegramId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserByTelegramId1(telegramId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseUserRequestResultUserRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserByTelegramId1(telegramId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Получить P2P пользователя
         * @param {UserRequest} userRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(userRequest: UserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseP2PUserRequestResultP2PUserSearchResultRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(userRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Получить P2P пользователей
         * @param {UsersRequest} usersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers1(usersRequest: UsersRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseP2PUserRequestResultListP2PUserSearchResultRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers1(usersRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Получить P2P пользователя
         * @param {UserRequest} userRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers2(userRequest: UserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseP2PUserRequestResultP2PUserSearchResultRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers2(userRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Получить P2P пользователей
         * @param {UsersRequest} usersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers3(usersRequest: UsersRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseP2PUserRequestResultListP2PUserSearchResultRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers3(usersRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Получить пользователей по device ids
         * @param {UsersByDeviceIdsRequest} usersByDeviceIdsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersByDeviceIds(usersByDeviceIdsRequest: UsersByDeviceIdsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseUserRequestResultListUserRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersByDeviceIds(usersByDeviceIdsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Получить пользователей по device ids
         * @param {UsersByDeviceIdsRequest} usersByDeviceIdsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersByDeviceIds1(usersByDeviceIdsRequest: UsersByDeviceIdsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseUserRequestResultListUserRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersByDeviceIds1(usersByDeviceIdsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Инициализировать P2P пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initializeP2PUser(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseInitializeP2PUserRestStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initializeP2PUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * start KYC process
         * @param {StartKycRequest} startKycRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startKyc(startKycRequest: StartKycRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseStartKycResultStatusStartKycResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startKyc(startKycRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Обновить телефон пользователя
         * @param {UpdatePhoneNumberRequest} updatePhoneNumberRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePhoneNumber(updatePhoneNumberRequest: UpdatePhoneNumberRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseUpdatePhoneNumberStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePhoneNumber(updatePhoneNumberRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Обновить телефон пользователя
         * @param {UpdatePhoneNumberRequest} updatePhoneNumberRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePhoneNumber1(updatePhoneNumberRequest: UpdatePhoneNumberRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseUpdatePhoneNumberStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePhoneNumber1(updatePhoneNumberRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Проверить пользователя на антифрод методами Telegram
         * @param {UserRequest} userRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkIsUserEligibleForTokens(userRequest: UserRequest, options?: any): AxiosPromise<RestDataResponseCheckIsUserEligibleForTokensRestStatusUserEligibleForTokensValidationResultRestDto> {
            return localVarFp.checkIsUserEligibleForTokens(userRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Проверить пользователя на антифрод методами Telegram
         * @param {UserRequest} userRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkIsUserEligibleForTokens1(userRequest: UserRequest, options?: any): AxiosPromise<RestDataResponseCheckIsUserEligibleForTokensRestStatusUserEligibleForTokensValidationResultRestDto> {
            return localVarFp.checkIsUserEligibleForTokens1(userRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Заблокировать P2P для пользователя
         * @param {DisableP2PUserRequest} disableP2PUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableP2PUser(disableP2PUserRequest: DisableP2PUserRequest, options?: any): AxiosPromise<RestResponseDisableP2PUserRequestResult> {
            return localVarFp.disableP2PUser(disableP2PUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Заблокировать P2P для пользователя
         * @param {DisableP2PUserRequest} disableP2PUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableP2PUser1(disableP2PUserRequest: DisableP2PUserRequest, options?: any): AxiosPromise<RestResponseDisableP2PUserRequestResult> {
            return localVarFp.disableP2PUser1(disableP2PUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Disable user permissions
         * @param {DisableUserPermissionsRestRequest} disableUserPermissionsRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableUser(disableUserPermissionsRestRequest: DisableUserPermissionsRestRequest, options?: any): AxiosPromise<RestResponseDisableUserPermissionsRequestResult> {
            return localVarFp.disableUser(disableUserPermissionsRestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Disable user permissions
         * @param {DisableUserPermissionsRestRequest} disableUserPermissionsRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableUser1(disableUserPermissionsRestRequest: DisableUserPermissionsRestRequest, options?: any): AxiosPromise<RestResponseDisableUserPermissionsRequestResult> {
            return localVarFp.disableUser1(disableUserPermissionsRestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * KYC polling method
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKyc(options?: any): AxiosPromise<RestDataResponseUserKycResultKycDataPublicDto> {
            return localVarFp.getKyc(options).then((request) => request(axios, basePath));
        },
        /**
         * KYC polling method
         * @param {UserRequest} userRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKyc1(userRequest: UserRequest, options?: any): AxiosPromise<RestDataResponseUserRequestResultKycDataDto> {
            return localVarFp.getKyc1(userRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * KYC polling method
         * @param {UserRequest} userRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKyc2(userRequest: UserRequest, options?: any): AxiosPromise<RestDataResponseUserRequestResultKycDataDto> {
            return localVarFp.getKyc2(userRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Получить лимиты для пользователя по KYC-уровням
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLimits(options?: any): AxiosPromise<RestDataResponseLimitsInfoStatusLimitsInfoResponse> {
            return localVarFp.getLimits(options).then((request) => request(axios, basePath));
        },
        /**
         * Получить P2P пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getP2PUser(options?: any): AxiosPromise<RestDataResponseGetP2PUserStatusP2PUserSearchResultPublicRestDto> {
            return localVarFp.getP2PUser(options).then((request) => request(axios, basePath));
        },
        /**
         * Получить пользователя
         * @param {GetUserRequest} getUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(getUserRequest: GetUserRequest, options?: any): AxiosPromise<RestDataResponseGetUserStatusUserPublicRestDto> {
            return localVarFp.getUser(getUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Получить пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser1(options?: any): AxiosPromise<RestDataResponseGetUserStatusUserPublicRestDto> {
            return localVarFp.getUser1(options).then((request) => request(axios, basePath));
        },
        /**
         * Получить пользователя
         * @param {UserRequest} userRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser2(userRequest: UserRequest, options?: any): AxiosPromise<RestDataResponseUserRequestResultUserRestDto> {
            return localVarFp.getUser2(userRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Получить пользователя
         * @param {UserRequest} userRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser3(userRequest: UserRequest, options?: any): AxiosPromise<RestDataResponseUserRequestResultUserRestDto> {
            return localVarFp.getUser3(userRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Найти wallet пользователя по telegram id
         * @param {number} telegramId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByTelegramId(telegramId: number, options?: any): AxiosPromise<RestDataResponseUserRequestResultUserRestDto> {
            return localVarFp.getUserByTelegramId(telegramId, options).then((request) => request(axios, basePath));
        },
        /**
         * Найти wallet пользователя по telegram id
         * @param {number} telegramId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByTelegramId1(telegramId: number, options?: any): AxiosPromise<RestDataResponseUserRequestResultUserRestDto> {
            return localVarFp.getUserByTelegramId1(telegramId, options).then((request) => request(axios, basePath));
        },
        /**
         * Получить P2P пользователя
         * @param {UserRequest} userRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(userRequest: UserRequest, options?: any): AxiosPromise<RestDataResponseP2PUserRequestResultP2PUserSearchResultRestDto> {
            return localVarFp.getUsers(userRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Получить P2P пользователей
         * @param {UsersRequest} usersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers1(usersRequest: UsersRequest, options?: any): AxiosPromise<RestDataResponseP2PUserRequestResultListP2PUserSearchResultRestDto> {
            return localVarFp.getUsers1(usersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Получить P2P пользователя
         * @param {UserRequest} userRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers2(userRequest: UserRequest, options?: any): AxiosPromise<RestDataResponseP2PUserRequestResultP2PUserSearchResultRestDto> {
            return localVarFp.getUsers2(userRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Получить P2P пользователей
         * @param {UsersRequest} usersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers3(usersRequest: UsersRequest, options?: any): AxiosPromise<RestDataResponseP2PUserRequestResultListP2PUserSearchResultRestDto> {
            return localVarFp.getUsers3(usersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Получить пользователей по device ids
         * @param {UsersByDeviceIdsRequest} usersByDeviceIdsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersByDeviceIds(usersByDeviceIdsRequest: UsersByDeviceIdsRequest, options?: any): AxiosPromise<RestDataResponseUserRequestResultListUserRestDto> {
            return localVarFp.getUsersByDeviceIds(usersByDeviceIdsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Получить пользователей по device ids
         * @param {UsersByDeviceIdsRequest} usersByDeviceIdsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersByDeviceIds1(usersByDeviceIdsRequest: UsersByDeviceIdsRequest, options?: any): AxiosPromise<RestDataResponseUserRequestResultListUserRestDto> {
            return localVarFp.getUsersByDeviceIds1(usersByDeviceIdsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Инициализировать P2P пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initializeP2PUser(options?: any): AxiosPromise<RestResponseInitializeP2PUserRestStatus> {
            return localVarFp.initializeP2PUser(options).then((request) => request(axios, basePath));
        },
        /**
         * start KYC process
         * @param {StartKycRequest} startKycRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startKyc(startKycRequest: StartKycRequest, options?: any): AxiosPromise<RestDataResponseStartKycResultStatusStartKycResponse> {
            return localVarFp.startKyc(startKycRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Обновить телефон пользователя
         * @param {UpdatePhoneNumberRequest} updatePhoneNumberRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePhoneNumber(updatePhoneNumberRequest: UpdatePhoneNumberRequest, options?: any): AxiosPromise<RestResponseUpdatePhoneNumberStatus> {
            return localVarFp.updatePhoneNumber(updatePhoneNumberRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Обновить телефон пользователя
         * @param {UpdatePhoneNumberRequest} updatePhoneNumberRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePhoneNumber1(updatePhoneNumberRequest: UpdatePhoneNumberRequest, options?: any): AxiosPromise<RestResponseUpdatePhoneNumberStatus> {
            return localVarFp.updatePhoneNumber1(updatePhoneNumberRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Проверить пользователя на антифрод методами Telegram
     * @param {UserRequest} userRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public checkIsUserEligibleForTokens(userRequest: UserRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).checkIsUserEligibleForTokens(userRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Проверить пользователя на антифрод методами Telegram
     * @param {UserRequest} userRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public checkIsUserEligibleForTokens1(userRequest: UserRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).checkIsUserEligibleForTokens1(userRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Заблокировать P2P для пользователя
     * @param {DisableP2PUserRequest} disableP2PUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public disableP2PUser(disableP2PUserRequest: DisableP2PUserRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).disableP2PUser(disableP2PUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Заблокировать P2P для пользователя
     * @param {DisableP2PUserRequest} disableP2PUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public disableP2PUser1(disableP2PUserRequest: DisableP2PUserRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).disableP2PUser1(disableP2PUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disable user permissions
     * @param {DisableUserPermissionsRestRequest} disableUserPermissionsRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public disableUser(disableUserPermissionsRestRequest: DisableUserPermissionsRestRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).disableUser(disableUserPermissionsRestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disable user permissions
     * @param {DisableUserPermissionsRestRequest} disableUserPermissionsRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public disableUser1(disableUserPermissionsRestRequest: DisableUserPermissionsRestRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).disableUser1(disableUserPermissionsRestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * KYC polling method
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getKyc(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getKyc(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * KYC polling method
     * @param {UserRequest} userRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getKyc1(userRequest: UserRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getKyc1(userRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * KYC polling method
     * @param {UserRequest} userRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getKyc2(userRequest: UserRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getKyc2(userRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получить лимиты для пользователя по KYC-уровням
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getLimits(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getLimits(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получить P2P пользователя
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getP2PUser(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getP2PUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получить пользователя
     * @param {GetUserRequest} getUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser(getUserRequest: GetUserRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUser(getUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получить пользователя
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser1(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUser1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получить пользователя
     * @param {UserRequest} userRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser2(userRequest: UserRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUser2(userRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получить пользователя
     * @param {UserRequest} userRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser3(userRequest: UserRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUser3(userRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Найти wallet пользователя по telegram id
     * @param {number} telegramId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserByTelegramId(telegramId: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserByTelegramId(telegramId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Найти wallet пользователя по telegram id
     * @param {number} telegramId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserByTelegramId1(telegramId: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserByTelegramId1(telegramId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получить P2P пользователя
     * @param {UserRequest} userRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUsers(userRequest: UserRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUsers(userRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получить P2P пользователей
     * @param {UsersRequest} usersRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUsers1(usersRequest: UsersRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUsers1(usersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получить P2P пользователя
     * @param {UserRequest} userRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUsers2(userRequest: UserRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUsers2(userRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получить P2P пользователей
     * @param {UsersRequest} usersRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUsers3(usersRequest: UsersRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUsers3(usersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получить пользователей по device ids
     * @param {UsersByDeviceIdsRequest} usersByDeviceIdsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUsersByDeviceIds(usersByDeviceIdsRequest: UsersByDeviceIdsRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUsersByDeviceIds(usersByDeviceIdsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получить пользователей по device ids
     * @param {UsersByDeviceIdsRequest} usersByDeviceIdsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUsersByDeviceIds1(usersByDeviceIdsRequest: UsersByDeviceIdsRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUsersByDeviceIds1(usersByDeviceIdsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Инициализировать P2P пользователя
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public initializeP2PUser(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).initializeP2PUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * start KYC process
     * @param {StartKycRequest} startKycRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public startKyc(startKycRequest: StartKycRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).startKyc(startKycRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Обновить телефон пользователя
     * @param {UpdatePhoneNumberRequest} updatePhoneNumberRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updatePhoneNumber(updatePhoneNumberRequest: UpdatePhoneNumberRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).updatePhoneNumber(updatePhoneNumberRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Обновить телефон пользователя
     * @param {UpdatePhoneNumberRequest} updatePhoneNumberRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updatePhoneNumber1(updatePhoneNumberRequest: UpdatePhoneNumberRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).updatePhoneNumber1(updatePhoneNumberRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VerificationApi - axios parameter creator
 * @export
 */
export const VerificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {TokenForCompanyRequest} tokenForCompanyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewTokenForCompany: async (tokenForCompanyRequest: TokenForCompanyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenForCompanyRequest' is not null or undefined
            assertParamExists('getNewTokenForCompany', 'tokenForCompanyRequest', tokenForCompanyRequest)
            const localVarPath = `/users/internal-api/v2/verification/kyb/get-new-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenForCompanyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TokenForCompanyRequest} tokenForCompanyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewTokenForCompany1: async (tokenForCompanyRequest: TokenForCompanyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenForCompanyRequest' is not null or undefined
            assertParamExists('getNewTokenForCompany1', 'tokenForCompanyRequest', tokenForCompanyRequest)
            const localVarPath = `/users/internal-api/v1/verification/kyb/get-new-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenForCompanyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TokenForUserRequest} tokenForUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewTokenForUser: async (tokenForUserRequest: TokenForUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenForUserRequest' is not null or undefined
            assertParamExists('getNewTokenForUser', 'tokenForUserRequest', tokenForUserRequest)
            const localVarPath = `/users/internal-api/v2/verification/kyc/get-new-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenForUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TokenForUserRequest} tokenForUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewTokenForUser1: async (tokenForUserRequest: TokenForUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenForUserRequest' is not null or undefined
            assertParamExists('getNewTokenForUser1', 'tokenForUserRequest', tokenForUserRequest)
            const localVarPath = `/users/internal-api/v1/verification/kyc/get-new-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenForUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VerificationApi - functional programming interface
 * @export
 */
export const VerificationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VerificationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {TokenForCompanyRequest} tokenForCompanyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNewTokenForCompany(tokenForCompanyRequest: TokenForCompanyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseNewTokenForCompanyStatusNewTokenForCompanyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNewTokenForCompany(tokenForCompanyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {TokenForCompanyRequest} tokenForCompanyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNewTokenForCompany1(tokenForCompanyRequest: TokenForCompanyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseNewTokenForCompanyStatusNewTokenForCompanyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNewTokenForCompany1(tokenForCompanyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {TokenForUserRequest} tokenForUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNewTokenForUser(tokenForUserRequest: TokenForUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseNewTokenForUserStatusNewTokenForUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNewTokenForUser(tokenForUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {TokenForUserRequest} tokenForUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNewTokenForUser1(tokenForUserRequest: TokenForUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseNewTokenForUserStatusNewTokenForUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNewTokenForUser1(tokenForUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VerificationApi - factory interface
 * @export
 */
export const VerificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VerificationApiFp(configuration)
    return {
        /**
         * 
         * @param {TokenForCompanyRequest} tokenForCompanyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewTokenForCompany(tokenForCompanyRequest: TokenForCompanyRequest, options?: any): AxiosPromise<RestDataResponseNewTokenForCompanyStatusNewTokenForCompanyResponse> {
            return localVarFp.getNewTokenForCompany(tokenForCompanyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TokenForCompanyRequest} tokenForCompanyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewTokenForCompany1(tokenForCompanyRequest: TokenForCompanyRequest, options?: any): AxiosPromise<RestDataResponseNewTokenForCompanyStatusNewTokenForCompanyResponse> {
            return localVarFp.getNewTokenForCompany1(tokenForCompanyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TokenForUserRequest} tokenForUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewTokenForUser(tokenForUserRequest: TokenForUserRequest, options?: any): AxiosPromise<RestDataResponseNewTokenForUserStatusNewTokenForUserResponse> {
            return localVarFp.getNewTokenForUser(tokenForUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TokenForUserRequest} tokenForUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewTokenForUser1(tokenForUserRequest: TokenForUserRequest, options?: any): AxiosPromise<RestDataResponseNewTokenForUserStatusNewTokenForUserResponse> {
            return localVarFp.getNewTokenForUser1(tokenForUserRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VerificationApi - object-oriented interface
 * @export
 * @class VerificationApi
 * @extends {BaseAPI}
 */
export class VerificationApi extends BaseAPI {
    /**
     * 
     * @param {TokenForCompanyRequest} tokenForCompanyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerificationApi
     */
    public getNewTokenForCompany(tokenForCompanyRequest: TokenForCompanyRequest, options?: AxiosRequestConfig) {
        return VerificationApiFp(this.configuration).getNewTokenForCompany(tokenForCompanyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TokenForCompanyRequest} tokenForCompanyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerificationApi
     */
    public getNewTokenForCompany1(tokenForCompanyRequest: TokenForCompanyRequest, options?: AxiosRequestConfig) {
        return VerificationApiFp(this.configuration).getNewTokenForCompany1(tokenForCompanyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TokenForUserRequest} tokenForUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerificationApi
     */
    public getNewTokenForUser(tokenForUserRequest: TokenForUserRequest, options?: AxiosRequestConfig) {
        return VerificationApiFp(this.configuration).getNewTokenForUser(tokenForUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TokenForUserRequest} tokenForUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerificationApi
     */
    public getNewTokenForUser1(tokenForUserRequest: TokenForUserRequest, options?: AxiosRequestConfig) {
        return VerificationApiFp(this.configuration).getNewTokenForUser1(tokenForUserRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


