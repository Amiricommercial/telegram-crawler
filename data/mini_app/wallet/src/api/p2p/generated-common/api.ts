/* tslint:disable */
/* eslint-disable */
/**
 * P2P Market
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: DEVELOPMENT
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface ABTestsDict
 */
export interface ABTestsDict {
    /**
     * 
     * @type {boolean}
     * @memberof ABTestsDict
     */
    'verifiedMerchantBadge': boolean;
}
/**
 * Errors details, present if status is not SUCCESS
 * @export
 * @interface AcceptOrderErrorDetails
 */
export interface AcceptOrderErrorDetails {
    /**
     * 
     * @type {number}
     * @memberof AcceptOrderErrorDetails
     */
    'maxOpenOrdersNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof AcceptOrderErrorDetails
     */
    'promotionKYCLevel'?: AcceptOrderErrorDetailsPromotionKYCLevelEnum;
}

export const AcceptOrderErrorDetailsPromotionKYCLevelEnum = {
    _0: 'LEVEL_0',
    _1: 'LEVEL_1',
    _2: 'LEVEL_2',
    _3: 'LEVEL_3',
    _4: 'LEVEL_4'
} as const;

export type AcceptOrderErrorDetailsPromotionKYCLevelEnum = typeof AcceptOrderErrorDetailsPromotionKYCLevelEnum[keyof typeof AcceptOrderErrorDetailsPromotionKYCLevelEnum];

/**
 * 
 * @export
 * @interface AcceptOrderRestRequest
 */
export interface AcceptOrderRestRequest {
    /**
     * 
     * @type {number}
     * @memberof AcceptOrderRestRequest
     */
    'orderId': number;
    /**
     * 
     * @type {string}
     * @memberof AcceptOrderRestRequest
     */
    'type': AcceptOrderRestRequestTypeEnum;
}

export const AcceptOrderRestRequestTypeEnum = {
    Sale: 'SALE',
    Purchase: 'PURCHASE'
} as const;

export type AcceptOrderRestRequestTypeEnum = typeof AcceptOrderRestRequestTypeEnum[keyof typeof AcceptOrderRestRequestTypeEnum];

/**
 * 
 * @export
 * @interface ActivateOfferRestRequest
 */
export interface ActivateOfferRestRequest {
    /**
     * 
     * @type {number}
     * @memberof ActivateOfferRestRequest
     */
    'offerId': number;
    /**
     * 
     * @type {string}
     * @memberof ActivateOfferRestRequest
     */
    'type': ActivateOfferRestRequestTypeEnum;
}

export const ActivateOfferRestRequestTypeEnum = {
    Sale: 'SALE',
    Purchase: 'PURCHASE'
} as const;

export type ActivateOfferRestRequestTypeEnum = typeof ActivateOfferRestRequestTypeEnum[keyof typeof ActivateOfferRestRequestTypeEnum];

/**
 * 
 * @export
 * @interface Alpha2CodeRequest
 */
export interface Alpha2CodeRequest {
    /**
     * 
     * @type {string}
     * @memberof Alpha2CodeRequest
     */
    'alpha2Code': string;
}
/**
 * 
 * @export
 * @interface AppealRestDto
 */
export interface AppealRestDto {
    /**
     * 
     * @type {number}
     * @memberof AppealRestDto
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof AppealRestDto
     */
    'petitionerUserId': number;
    /**
     * 
     * @type {string}
     * @memberof AppealRestDto
     */
    'orderStatusAtAppeal': AppealRestDtoOrderStatusAtAppealEnum;
    /**
     * 
     * @type {string}
     * @memberof AppealRestDto
     */
    'createDateTime': string;
    /**
     * 
     * @type {string}
     * @memberof AppealRestDto
     */
    'resolutionType'?: AppealRestDtoResolutionTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AppealRestDto
     */
    'resolveDateTime'?: string;
    /**
     * 
     * @type {number}
     * @memberof AppealRestDto
     */
    'resolvedByUserId'?: number;
    /**
     * 
     * @type {string}
     * @memberof AppealRestDto
     */
    'comment'?: string;
}

export const AppealRestDtoOrderStatusAtAppealEnum = {
    Draft: 'DRAFT',
    ConfirmingOrder: 'CONFIRMING_ORDER',
    New: 'NEW',
    Rejected: 'REJECTED',
    AcceptingOrder: 'ACCEPTING_ORDER',
    AcceptedOrder: 'ACCEPTED_ORDER',
    ConfirmedSendingPaymentByBuyer: 'CONFIRMED_SENDING_PAYMENT_BY_BUYER',
    TimeoutExpiredSendingPaymentByBuyer: 'TIMEOUT_EXPIRED_SENDING_PAYMENT_BY_BUYER',
    ConfirmedReceiptPaymentBySeller: 'CONFIRMED_RECEIPT_PAYMENT_BY_SELLER',
    OnAppeal: 'ON_APPEAL',
    AppealResolved: 'APPEAL_RESOLVED',
    Completed: 'COMPLETED',
    Cancelling: 'CANCELLING',
    Cancelled: 'CANCELLED'
} as const;

export type AppealRestDtoOrderStatusAtAppealEnum = typeof AppealRestDtoOrderStatusAtAppealEnum[keyof typeof AppealRestDtoOrderStatusAtAppealEnum];
export const AppealRestDtoResolutionTypeEnum = {
    NoChanges: 'NO_CHANGES',
    GoToNextStatus: 'GO_TO_NEXT_STATUS',
    CancelOrder: 'CANCEL_ORDER',
    RefundClosedOrder: 'REFUND_CLOSED_ORDER'
} as const;

export type AppealRestDtoResolutionTypeEnum = typeof AppealRestDtoResolutionTypeEnum[keyof typeof AppealRestDtoResolutionTypeEnum];

/**
 * 
 * @export
 * @interface ApplicationInfo
 */
export interface ApplicationInfo {
    /**
     * 
     * @type {string}
     * @memberof ApplicationInfo
     */
    'app_name': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationInfo
     */
    'app_version': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationInfo
     */
    'host_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationInfo
     */
    'app_time': string;
}
/**
 * 
 * @export
 * @interface ArraySbpBank
 */
export interface ArraySbpBank extends AttributeValueRestDto {
    /**
     * 
     * @type {Array<SbpBankRestDto>}
     * @memberof ArraySbpBank
     */
    'value': Array<SbpBankRestDto>;
}


/**
 * 
 * @export
 * @interface ArraySbpBankAllOf
 */
export interface ArraySbpBankAllOf {
    /**
     * 
     * @type {Array<SbpBankRestDto>}
     * @memberof ArraySbpBankAllOf
     */
    'value'?: Array<SbpBankRestDto>;
}
/**
 * 
 * @export
 * @interface ArraySbpBankCode
 */
export interface ArraySbpBankCode extends AttributeValueRestRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof ArraySbpBankCode
     */
    'value': Array<string>;
}


/**
 * 
 * @export
 * @interface ArraySbpBankCodeAllOf
 */
export interface ArraySbpBankCodeAllOf {
    /**
     * 
     * @type {Array<string>}
     * @memberof ArraySbpBankCodeAllOf
     */
    'value'?: Array<string>;
}
/**
 * 
 * @export
 * @interface AttributeTypeOptionRestDto
 */
export interface AttributeTypeOptionRestDto {
    /**
     * 
     * @type {string}
     * @memberof AttributeTypeOptionRestDto
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof AttributeTypeOptionRestDto
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof AttributeTypeOptionRestDto
     */
    'labelLocale': string;
    /**
     * 
     * @type {string}
     * @memberof AttributeTypeOptionRestDto
     */
    'labelEng': string;
}
/**
 * 
 * @export
 * @interface AttributeTypePartRestDto
 */
export interface AttributeTypePartRestDto {
    /**
     * 
     * @type {string}
     * @memberof AttributeTypePartRestDto
     */
    'name': AttributeTypePartRestDtoNameEnum;
    /**
     * 
     * @type {string}
     * @memberof AttributeTypePartRestDto
     */
    'type': AttributeTypePartRestDtoTypeEnum;
    /**
     * 
     * @type {Array<AttributeTypeOptionRestDto>}
     * @memberof AttributeTypePartRestDto
     */
    'options': Array<AttributeTypeOptionRestDto>;
    /**
     * 
     * @type {Array<MaxArraySizeRuleRestDto | MaxLengthRuleRestDto | MinLengthRuleRestDto | RegexPatternRestDto | RequiredRuleRestDto>}
     * @memberof AttributeTypePartRestDto
     */
    'validations': Array<MaxArraySizeRuleRestDto | MaxLengthRuleRestDto | MinLengthRuleRestDto | RegexPatternRestDto | RequiredRuleRestDto>;
}

export const AttributeTypePartRestDtoNameEnum = {
    Banks: 'BANKS',
    Phone: 'PHONE',
    PaymentDetailsNumber: 'PAYMENT_DETAILS_NUMBER'
} as const;

export type AttributeTypePartRestDtoNameEnum = typeof AttributeTypePartRestDtoNameEnum[keyof typeof AttributeTypePartRestDtoNameEnum];
export const AttributeTypePartRestDtoTypeEnum = {
    Input: 'INPUT',
    Select: 'SELECT'
} as const;

export type AttributeTypePartRestDtoTypeEnum = typeof AttributeTypePartRestDtoTypeEnum[keyof typeof AttributeTypePartRestDtoTypeEnum];

/**
 * 
 * @export
 * @interface AttributeTypeRestDto
 */
export interface AttributeTypeRestDto {
    /**
     * 
     * @type {string}
     * @memberof AttributeTypeRestDto
     */
    'version': string;
    /**
     * 
     * @type {Array<AttributeTypePartRestDto>}
     * @memberof AttributeTypeRestDto
     */
    'parts': Array<AttributeTypePartRestDto>;
}
/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface AttributeTypesRestDto
 */
export interface AttributeTypesRestDto {
    /**
     * 
     * @type {Array<AttributeTypeRestDto>}
     * @memberof AttributeTypesRestDto
     */
    'versions': Array<AttributeTypeRestDto>;
}
/**
 * 
 * @export
 * @interface AttributeValueRestDto
 */
export interface AttributeValueRestDto {
    /**
     * 
     * @type {string}
     * @memberof AttributeValueRestDto
     */
    'name': AttributeValueRestDtoNameEnum;
}

export const AttributeValueRestDtoNameEnum = {
    Banks: 'BANKS',
    Phone: 'PHONE',
    PaymentDetailsNumber: 'PAYMENT_DETAILS_NUMBER'
} as const;

export type AttributeValueRestDtoNameEnum = typeof AttributeValueRestDtoNameEnum[keyof typeof AttributeValueRestDtoNameEnum];

/**
 * 
 * @export
 * @interface AttributeValueRestRequest
 */
export interface AttributeValueRestRequest {
    /**
     * 
     * @type {string}
     * @memberof AttributeValueRestRequest
     */
    'name': AttributeValueRestRequestNameEnum;
}

export const AttributeValueRestRequestNameEnum = {
    Banks: 'BANKS',
    Phone: 'PHONE',
    PaymentDetailsNumber: 'PAYMENT_DETAILS_NUMBER'
} as const;

export type AttributeValueRestRequestNameEnum = typeof AttributeValueRestRequestNameEnum[keyof typeof AttributeValueRestRequestNameEnum];

/**
 * 
 * @export
 * @interface AttributesRestDto
 */
export interface AttributesRestDto {
    /**
     * 
     * @type {string}
     * @memberof AttributesRestDto
     */
    'version': string;
    /**
     * 
     * @type {Array<ArraySbpBank | Str>}
     * @memberof AttributesRestDto
     */
    'values': Array<ArraySbpBank | Str>;
}
/**
 * 
 * @export
 * @interface AttributesRestRequest
 */
export interface AttributesRestRequest {
    /**
     * 
     * @type {string}
     * @memberof AttributesRestRequest
     */
    'version': string;
    /**
     * 
     * @type {Array<ArraySbpBankCode | Str>}
     * @memberof AttributesRestRequest
     */
    'values': Array<ArraySbpBankCode | Str>;
}
/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface BaseOfferRestDto
 */
export interface BaseOfferRestDto {
    /**
     * 
     * @type {number}
     * @memberof BaseOfferRestDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof BaseOfferRestDto
     */
    'number': string;
    /**
     * 
     * @type {UserRestDto}
     * @memberof BaseOfferRestDto
     */
    'user': UserRestDto;
    /**
     * 
     * @type {string}
     * @memberof BaseOfferRestDto
     */
    'type': BaseOfferRestDtoTypeEnum;
    /**
     * 
     * @type {MoneyAmountRestDto}
     * @memberof BaseOfferRestDto
     */
    'initVolume': MoneyAmountRestDto;
    /**
     * 
     * @type {MoneyAmountRestDto}
     * @memberof BaseOfferRestDto
     */
    'availableVolume': MoneyAmountRestDto;
    /**
     * 
     * @type {string}
     * @memberof BaseOfferRestDto
     */
    'paymentConfirmTimeout': string;
    /**
     * 
     * @type {PriceWithEstimationRestDto}
     * @memberof BaseOfferRestDto
     */
    'price': PriceWithEstimationRestDto;
    /**
     * 
     * @type {MoneyAmountLimitsRestDto}
     * @memberof BaseOfferRestDto
     */
    'orderAmountLimits': MoneyAmountLimitsRestDto;
    /**
     * 
     * @type {MoneyAmountLimitsRestDto}
     * @memberof BaseOfferRestDto
     */
    'orderVolumeLimits'?: MoneyAmountLimitsRestDto;
    /**
     * 
     * @type {string}
     * @memberof BaseOfferRestDto
     */
    'status': BaseOfferRestDtoStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof BaseOfferRestDto
     */
    'createDateTime': string;
    /**
     * 
     * @type {string}
     * @memberof BaseOfferRestDto
     */
    'comment'?: string;
    /**
     * 
     * @type {ChangeLogRestDtoOfferStatus}
     * @memberof BaseOfferRestDto
     */
    'changeLog': ChangeLogRestDtoOfferStatus;
    /**
     * 
     * @type {string}
     * @memberof BaseOfferRestDto
     */
    'orderConfirmationTimeout': string;
    /**
     * 
     * @type {string}
     * @memberof BaseOfferRestDto
     */
    'orderAcceptTimeout': string;
}

export const BaseOfferRestDtoTypeEnum = {
    Sale: 'SALE',
    Purchase: 'PURCHASE'
} as const;

export type BaseOfferRestDtoTypeEnum = typeof BaseOfferRestDtoTypeEnum[keyof typeof BaseOfferRestDtoTypeEnum];
export const BaseOfferRestDtoStatusEnum = {
    Inactive: 'INACTIVE',
    Activating: 'ACTIVATING',
    Active: 'ACTIVE',
    Deactivating: 'DEACTIVATING',
    Killed: 'KILLED',
    Deleted: 'DELETED',
    Updating: 'UPDATING'
} as const;

export type BaseOfferRestDtoStatusEnum = typeof BaseOfferRestDtoStatusEnum[keyof typeof BaseOfferRestDtoStatusEnum];

/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface BiddingSettingsDto
 */
export interface BiddingSettingsDto {
    /**
     * 
     * @type {number}
     * @memberof BiddingSettingsDto
     */
    'userId': number;
    /**
     * 
     * @type {boolean}
     * @memberof BiddingSettingsDto
     */
    'isBiddingEnabled': boolean;
}
/**
 * 
 * @export
 * @interface Button
 */
export interface Button {
    /**
     * 
     * @type {string}
     * @memberof Button
     */
    'type': ButtonTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Button
     */
    'caption': string;
    /**
     * 
     * @type {string}
     * @memberof Button
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Button
     */
    'callbackData'?: string;
}

export const ButtonTypeEnum = {
    UrlButton: 'URL_BUTTON',
    ActionButton: 'ACTION_BUTTON'
} as const;

export type ButtonTypeEnum = typeof ButtonTypeEnum[keyof typeof ButtonTypeEnum];

/**
 * 
 * @export
 * @interface ButtonRow
 */
export interface ButtonRow {
    /**
     * 
     * @type {Array<Button>}
     * @memberof ButtonRow
     */
    'buttons': Array<Button>;
}
/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface BuyOfferInfoRestDto
 */
export interface BuyOfferInfoRestDto {
    /**
     * 
     * @type {number}
     * @memberof BuyOfferInfoRestDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof BuyOfferInfoRestDto
     */
    'number': string;
    /**
     * 
     * @type {number}
     * @memberof BuyOfferInfoRestDto
     */
    'userId': number;
    /**
     * 
     * @type {UserStatisticsBackOfficeRestDto}
     * @memberof BuyOfferInfoRestDto
     */
    'userStatistics': UserStatisticsBackOfficeRestDto;
    /**
     * 
     * @type {string}
     * @memberof BuyOfferInfoRestDto
     */
    'type': BuyOfferInfoRestDtoTypeEnum;
    /**
     * 
     * @type {MoneyAmountRestDto}
     * @memberof BuyOfferInfoRestDto
     */
    'initVolume': MoneyAmountRestDto;
    /**
     * 
     * @type {MoneyAmountRestDto}
     * @memberof BuyOfferInfoRestDto
     */
    'availableVolume': MoneyAmountRestDto;
    /**
     * 
     * @type {string}
     * @memberof BuyOfferInfoRestDto
     */
    'orderAcceptTimeout': string;
    /**
     * 
     * @type {string}
     * @memberof BuyOfferInfoRestDto
     */
    'paymentConfirmTimeout': string;
    /**
     * 
     * @type {UserPrivatePriceRestDto}
     * @memberof BuyOfferInfoRestDto
     */
    'price': UserPrivatePriceRestDto;
    /**
     * 
     * @type {MoneyAmountLimitsInfoRestDto}
     * @memberof BuyOfferInfoRestDto
     */
    'orderAmountLimits': MoneyAmountLimitsInfoRestDto;
    /**
     * 
     * @type {MoneyAmountLimitsInfoRestDto}
     * @memberof BuyOfferInfoRestDto
     */
    'orderVolumeLimits'?: MoneyAmountLimitsInfoRestDto;
    /**
     * 
     * @type {string}
     * @memberof BuyOfferInfoRestDto
     */
    'status': BuyOfferInfoRestDtoStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof BuyOfferInfoRestDto
     */
    'createDateTime': string;
    /**
     * 
     * @type {string}
     * @memberof BuyOfferInfoRestDto
     */
    'comment'?: string;
    /**
     * 
     * @type {ChangeLogInfoRestDtoOfferStatus}
     * @memberof BuyOfferInfoRestDto
     */
    'changeLog': ChangeLogInfoRestDtoOfferStatus;
    /**
     * 
     * @type {Array<PaymentMethodInfoRestDto>}
     * @memberof BuyOfferInfoRestDto
     */
    'paymentMethods': Array<PaymentMethodInfoRestDto>;
}

export const BuyOfferInfoRestDtoTypeEnum = {
    Sale: 'SALE',
    Purchase: 'PURCHASE'
} as const;

export type BuyOfferInfoRestDtoTypeEnum = typeof BuyOfferInfoRestDtoTypeEnum[keyof typeof BuyOfferInfoRestDtoTypeEnum];
export const BuyOfferInfoRestDtoStatusEnum = {
    Inactive: 'INACTIVE',
    Activating: 'ACTIVATING',
    Active: 'ACTIVE',
    Deactivating: 'DEACTIVATING',
    Killed: 'KILLED',
    Deleted: 'DELETED',
    Updating: 'UPDATING'
} as const;

export type BuyOfferInfoRestDtoStatusEnum = typeof BuyOfferInfoRestDtoStatusEnum[keyof typeof BuyOfferInfoRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface BuyOfferRestDto
 */
export interface BuyOfferRestDto extends BaseOfferRestDto {
    /**
     * 
     * @type {Array<PaymentMethodRestDto>}
     * @memberof BuyOfferRestDto
     */
    'paymentMethods': Array<PaymentMethodRestDto>;
}


/**
 * 
 * @export
 * @interface ByAmount
 */
export interface ByAmount {
    /**
     * 
     * @type {number}
     * @memberof ByAmount
     */
    'offerId': number;
    /**
     * 
     * @type {number}
     * @memberof ByAmount
     */
    'paymentDetailsId': number;
    /**
     * 
     * @type {string}
     * @memberof ByAmount
     */
    'type': ByAmountTypeEnum;
    /**
     * 
     * @type {MoneyAmountRestDto}
     * @memberof ByAmount
     */
    'amount': MoneyAmountRestDto;
}

export const ByAmountTypeEnum = {
    Sale: 'SALE',
    Purchase: 'PURCHASE'
} as const;

export type ByAmountTypeEnum = typeof ByAmountTypeEnum[keyof typeof ByAmountTypeEnum];

/**
 * 
 * @export
 * @interface ByVolume
 */
export interface ByVolume {
    /**
     * 
     * @type {number}
     * @memberof ByVolume
     */
    'offerId': number;
    /**
     * 
     * @type {number}
     * @memberof ByVolume
     */
    'paymentDetailsId': number;
    /**
     * 
     * @type {string}
     * @memberof ByVolume
     */
    'type': ByVolumeTypeEnum;
    /**
     * 
     * @type {MoneyAmountRestDto}
     * @memberof ByVolume
     */
    'volume': MoneyAmountRestDto;
}

export const ByVolumeTypeEnum = {
    Sale: 'SALE',
    Purchase: 'PURCHASE'
} as const;

export type ByVolumeTypeEnum = typeof ByVolumeTypeEnum[keyof typeof ByVolumeTypeEnum];

/**
 * 
 * @export
 * @interface CanCreateOrdersOnOfferRestRequest
 */
export interface CanCreateOrdersOnOfferRestRequest {
    /**
     * 
     * @type {number}
     * @memberof CanCreateOrdersOnOfferRestRequest
     */
    'offerId': number;
}
/**
 * 
 * @export
 * @interface CancellationDetails
 */
export interface CancellationDetails {
    /**
     * 
     * @type {string}
     * @memberof CancellationDetails
     */
    'side': CancellationDetailsSideEnum;
    /**
     * 
     * @type {string}
     * @memberof CancellationDetails
     */
    'message'?: string;
}

export const CancellationDetailsSideEnum = {
    Buyer: 'BUYER',
    Seller: 'SELLER',
    System: 'SYSTEM'
} as const;

export type CancellationDetailsSideEnum = typeof CancellationDetailsSideEnum[keyof typeof CancellationDetailsSideEnum];

/**
 * 
 * @export
 * @interface ChangeLogInfoRestDtoOfferStatus
 */
export interface ChangeLogInfoRestDtoOfferStatus {
    /**
     * 
     * @type {Array<ItemOfferStatus>}
     * @memberof ChangeLogInfoRestDtoOfferStatus
     */
    'items': Array<ItemOfferStatus>;
}
/**
 * 
 * @export
 * @interface ChangeLogInfoRestDtoOrderStatus
 */
export interface ChangeLogInfoRestDtoOrderStatus {
    /**
     * 
     * @type {Array<ItemOrderStatus>}
     * @memberof ChangeLogInfoRestDtoOrderStatus
     */
    'items': Array<ItemOrderStatus>;
}
/**
 * 
 * @export
 * @interface ChangeLogRestDtoOfferStatus
 */
export interface ChangeLogRestDtoOfferStatus {
    /**
     * 
     * @type {Array<ItemOfferStatus>}
     * @memberof ChangeLogRestDtoOfferStatus
     */
    'items': Array<ItemOfferStatus>;
}
/**
 * 
 * @export
 * @interface ChangeLogRestDtoOrderStatus
 */
export interface ChangeLogRestDtoOrderStatus {
    /**
     * 
     * @type {Array<ItemOrderStatus>}
     * @memberof ChangeLogRestDtoOrderStatus
     */
    'items': Array<ItemOrderStatus>;
}
/**
 * 
 * @export
 * @interface ChatMessageRestDto
 */
export interface ChatMessageRestDto {
    /**
     * 
     * @type {number}
     * @memberof ChatMessageRestDto
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof ChatMessageRestDto
     */
    'senderUserId': number;
    /**
     * 
     * @type {number}
     * @memberof ChatMessageRestDto
     */
    'recipientUserId': number;
    /**
     * 
     * @type {string}
     * @memberof ChatMessageRestDto
     */
    'sentBySenderUserDateTime': string;
    /**
     * 
     * @type {string}
     * @memberof ChatMessageRestDto
     */
    'sentBySenderSystemDateTime': string;
    /**
     * 
     * @type {string}
     * @memberof ChatMessageRestDto
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface CheckMakerLimitsToBuyOfferRestRequest
 */
export interface CheckMakerLimitsToBuyOfferRestRequest {
    /**
     * 
     * @type {MoneyAmountRestDto}
     * @memberof CheckMakerLimitsToBuyOfferRestRequest
     */
    'volume': MoneyAmountRestDto;
    /**
     * 
     * @type {number}
     * @memberof CheckMakerLimitsToBuyOfferRestRequest
     */
    'excludeOfferId'?: number;
}
/**
 * Errors details, present if status is not SUCCESS
 * @export
 * @interface ConfirmOrderErrorDetails
 */
export interface ConfirmOrderErrorDetails {
    /**
     * 
     * @type {number}
     * @memberof ConfirmOrderErrorDetails
     */
    'maxOpenOrdersNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof ConfirmOrderErrorDetails
     */
    'promotionKYCLevel'?: ConfirmOrderErrorDetailsPromotionKYCLevelEnum;
}

export const ConfirmOrderErrorDetailsPromotionKYCLevelEnum = {
    _0: 'LEVEL_0',
    _1: 'LEVEL_1',
    _2: 'LEVEL_2',
    _3: 'LEVEL_3',
    _4: 'LEVEL_4'
} as const;

export type ConfirmOrderErrorDetailsPromotionKYCLevelEnum = typeof ConfirmOrderErrorDetailsPromotionKYCLevelEnum[keyof typeof ConfirmOrderErrorDetailsPromotionKYCLevelEnum];

/**
 * 
 * @export
 * @interface ConfirmReceiptPaymentRestRequest
 */
export interface ConfirmReceiptPaymentRestRequest {
    /**
     * 
     * @type {number}
     * @memberof ConfirmReceiptPaymentRestRequest
     */
    'orderId': number;
}
/**
 * 
 * @export
 * @interface ConfirmSendingPaymentRestRequest
 */
export interface ConfirmSendingPaymentRestRequest {
    /**
     * 
     * @type {number}
     * @memberof ConfirmSendingPaymentRestRequest
     */
    'orderId': number;
}
/**
 * 
 * @export
 * @interface CreateBuyOfferRestRequest
 */
export interface CreateBuyOfferRestRequest extends CreateOfferRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateBuyOfferRestRequest
     */
    'paymentMethodCodes': Array<string>;
}


/**
 * 
 * @export
 * @interface CreateExpressRequest
 */
export interface CreateExpressRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateExpressRequest
     */
    'offerType': CreateExpressRequestOfferTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateExpressRequest
     */
    'baseCurrencyCode': string;
    /**
     * 
     * @type {string}
     * @memberof CreateExpressRequest
     */
    'quoteCurrencyCode': string;
    /**
     * 
     * @type {string}
     * @memberof CreateExpressRequest
     */
    'paymentMethodCode': string;
    /**
     * 
     * @type {string}
     * @memberof CreateExpressRequest
     */
    'calculationType': CreateExpressRequestCalculationTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateExpressRequest
     */
    'amount'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateExpressRequest
     */
    'volume'?: string;
}

export const CreateExpressRequestOfferTypeEnum = {
    Sale: 'SALE',
    Purchase: 'PURCHASE'
} as const;

export type CreateExpressRequestOfferTypeEnum = typeof CreateExpressRequestOfferTypeEnum[keyof typeof CreateExpressRequestOfferTypeEnum];
export const CreateExpressRequestCalculationTypeEnum = {
    Amount: 'BY_AMOUNT',
    Volume: 'BY_VOLUME'
} as const;

export type CreateExpressRequestCalculationTypeEnum = typeof CreateExpressRequestCalculationTypeEnum[keyof typeof CreateExpressRequestCalculationTypeEnum];

/**
 * 
 * @export
 * @interface CreateOfferRequest
 */
export interface CreateOfferRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateOfferRequest
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOfferRequest
     */
    'type': CreateOfferRequestTypeEnum;
    /**
     * 
     * @type {PriceRestDto}
     * @memberof CreateOfferRequest
     */
    'price': PriceRestDto;
    /**
     * 
     * @type {MoneyAmountRestDto}
     * @memberof CreateOfferRequest
     */
    'initVolume': MoneyAmountRestDto;
    /**
     * 
     * @type {string}
     * @memberof CreateOfferRequest
     */
    'paymentConfirmTimeout': string;
    /**
     * 
     * @type {OrderAmountLimitsRestRequest}
     * @memberof CreateOfferRequest
     */
    'orderAmountLimits': OrderAmountLimitsRestRequest;
}

export const CreateOfferRequestTypeEnum = {
    Sale: 'SALE',
    Purchase: 'PURCHASE'
} as const;

export type CreateOfferRequestTypeEnum = typeof CreateOfferRequestTypeEnum[keyof typeof CreateOfferRequestTypeEnum];

/**
 * 
 * @export
 * @interface CreateOrderAppealResolvedEventRestRequest
 */
export interface CreateOrderAppealResolvedEventRestRequest {
    /**
     * 
     * @type {number}
     * @memberof CreateOrderAppealResolvedEventRestRequest
     */
    'orderId': number;
}
/**
 * 
 * @export
 * @interface CreatePaymentDetailsBlacklistRestRequest
 */
export interface CreatePaymentDetailsBlacklistRestRequest {
    /**
     * 
     * @type {string}
     * @memberof CreatePaymentDetailsBlacklistRestRequest
     */
    'paymentDetailsNumber': string;
    /**
     * 
     * @type {number}
     * @memberof CreatePaymentDetailsBlacklistRestRequest
     */
    'staffId': number;
    /**
     * 
     * @type {string}
     * @memberof CreatePaymentDetailsBlacklistRestRequest
     */
    'comment': string | null;
}
/**
 * 
 * @export
 * @interface CreatePaymentDetailsRestRequest
 */
export interface CreatePaymentDetailsRestRequest {
    /**
     * 
     * @type {string}
     * @memberof CreatePaymentDetailsRestRequest
     */
    'paymentMethodCode': string;
    /**
     * 
     * @type {string}
     * @memberof CreatePaymentDetailsRestRequest
     */
    'currencyCode': string;
    /**
     * 
     * @type {AttributesRestRequest}
     * @memberof CreatePaymentDetailsRestRequest
     */
    'attributes': AttributesRestRequest;
    /**
     * 
     * @type {string}
     * @memberof CreatePaymentDetailsRestRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface CreateSellOfferRestRequest
 */
export interface CreateSellOfferRestRequest extends CreateOfferRequest {
    /**
     * 
     * @type {Array<number>}
     * @memberof CreateSellOfferRestRequest
     */
    'paymentDetailsIds': Array<number>;
}


/**
 * 
 * @export
 * @interface CurrencyCodeRestRequest
 */
export interface CurrencyCodeRestRequest {
    /**
     * 
     * @type {string}
     * @memberof CurrencyCodeRestRequest
     */
    'currencyCode': string;
}
/**
 * 
 * @export
 * @interface CurrencyPairsRestDto
 */
export interface CurrencyPairsRestDto {
    /**
     * 
     * @type {string}
     * @memberof CurrencyPairsRestDto
     */
    'baseCurrencyCode': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CurrencyPairsRestDto
     */
    'quoteCurrencyCodes': Array<string>;
}
/**
 * 
 * @export
 * @interface CurrencySettingsRestDto
 */
export interface CurrencySettingsRestDto {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CurrencySettingsRestDto
     */
    'localCountryAlpha2CodeToCurrencyMap': { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface DeactivateOfferRestRequest
 */
export interface DeactivateOfferRestRequest {
    /**
     * 
     * @type {number}
     * @memberof DeactivateOfferRestRequest
     */
    'offerId': number;
    /**
     * 
     * @type {string}
     * @memberof DeactivateOfferRestRequest
     */
    'type': DeactivateOfferRestRequestTypeEnum;
}

export const DeactivateOfferRestRequestTypeEnum = {
    Sale: 'SALE',
    Purchase: 'PURCHASE'
} as const;

export type DeactivateOfferRestRequestTypeEnum = typeof DeactivateOfferRestRequestTypeEnum[keyof typeof DeactivateOfferRestRequestTypeEnum];

/**
 * 
 * @export
 * @interface DeletePaymentDetailsBlacklistRestRequest
 */
export interface DeletePaymentDetailsBlacklistRestRequest {
    /**
     * 
     * @type {number}
     * @memberof DeletePaymentDetailsBlacklistRestRequest
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof DeletePaymentDetailsBlacklistRestRequest
     */
    'staffId': number;
}
/**
 * 
 * @export
 * @interface DeletePaymentDetailsRestRequest
 */
export interface DeletePaymentDetailsRestRequest {
    /**
     * 
     * @type {number}
     * @memberof DeletePaymentDetailsRestRequest
     */
    'id': number;
}
/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface DeletedPaymentDetailsRestDto
 */
export interface DeletedPaymentDetailsRestDto {
    /**
     * 
     * @type {number}
     * @memberof DeletedPaymentDetailsRestDto
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface DetailedRestDataResponseCreateOfferRestStatusUserPrivateBaseOfferRestDtoKycPromotionRequiredDetails
 */
export interface DetailedRestDataResponseCreateOfferRestStatusUserPrivateBaseOfferRestDtoKycPromotionRequiredDetails {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof DetailedRestDataResponseCreateOfferRestStatusUserPrivateBaseOfferRestDtoKycPromotionRequiredDetails
     */
    'status': DetailedRestDataResponseCreateOfferRestStatusUserPrivateBaseOfferRestDtoKycPromotionRequiredDetailsStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof DetailedRestDataResponseCreateOfferRestStatusUserPrivateBaseOfferRestDtoKycPromotionRequiredDetails
     */
    'message'?: string;
    /**
     * 
     * @type {UserPrivateBuyOfferRestDto | UserPrivateSellOfferRestDto}
     * @memberof DetailedRestDataResponseCreateOfferRestStatusUserPrivateBaseOfferRestDtoKycPromotionRequiredDetails
     */
    'data'?: UserPrivateBuyOfferRestDto | UserPrivateSellOfferRestDto;
    /**
     * 
     * @type {KycPromotionRequiredDetails}
     * @memberof DetailedRestDataResponseCreateOfferRestStatusUserPrivateBaseOfferRestDtoKycPromotionRequiredDetails
     */
    'errorDetails'?: KycPromotionRequiredDetails;
}

export const DetailedRestDataResponseCreateOfferRestStatusUserPrivateBaseOfferRestDtoKycPromotionRequiredDetailsStatusEnum = {
    Success: 'SUCCESS',
    KycPromotionRequired: 'KYC_PROMOTION_REQUIRED',
    Rejected: 'REJECTED',
    UnsupportedBaseCurrency: 'UNSUPPORTED_BASE_CURRENCY',
    UnsupportedQuoteCurrency: 'UNSUPPORTED_QUOTE_CURRENCY',
    WrongPaymentDetails: 'WRONG_PAYMENT_DETAILS',
    PaymentMethodsNotFound: 'PAYMENT_METHODS_NOT_FOUND',
    PaymentMethodsIsOutOfLimit: 'PAYMENT_METHODS_IS_OUT_OF_LIMIT',
    CurrencyIsNotSupportedByPaymentMethod: 'CURRENCY_IS_NOT_SUPPORTED_BY_PAYMENT_METHOD',
    TooManyPaymentsDetails: 'TOO_MANY_PAYMENTS_DETAILS',
    TooSmallMinOrderAmount: 'TOO_SMALL_MIN_ORDER_AMOUNT',
    OfferVolumeIsOutOfLimits: 'OFFER_VOLUME_IS_OUT_OF_LIMITS',
    PaymentConfirmTimeoutOutOfLimits: 'PAYMENT_CONFIRM_TIMEOUT_OUT_OF_LIMITS',
    FloatingPriceOutOfLimits: 'FLOATING_PRICE_OUT_OF_LIMITS',
    CommentTooLong: 'COMMENT_TOO_LONG',
    AccessDenied: 'ACCESS_DENIED',
    ActiveOfferCountLimitReached: 'ACTIVE_OFFER_COUNT_LIMIT_REACHED',
    FixedPriceOutOfLimits: 'FIXED_PRICE_OUT_OF_LIMITS',
    NextVolumeLowerThenCurrent: 'NEXT_VOLUME_LOWER_THEN_CURRENT'
} as const;

export type DetailedRestDataResponseCreateOfferRestStatusUserPrivateBaseOfferRestDtoKycPromotionRequiredDetailsStatusEnum = typeof DetailedRestDataResponseCreateOfferRestStatusUserPrivateBaseOfferRestDtoKycPromotionRequiredDetailsStatusEnum[keyof typeof DetailedRestDataResponseCreateOfferRestStatusUserPrivateBaseOfferRestDtoKycPromotionRequiredDetailsStatusEnum];

/**
 * 
 * @export
 * @interface DetailedRestDataResponseEditOfferRestStatusUserPrivateBaseOfferRestDtoKycPromotionRequiredDetails
 */
export interface DetailedRestDataResponseEditOfferRestStatusUserPrivateBaseOfferRestDtoKycPromotionRequiredDetails {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof DetailedRestDataResponseEditOfferRestStatusUserPrivateBaseOfferRestDtoKycPromotionRequiredDetails
     */
    'status': DetailedRestDataResponseEditOfferRestStatusUserPrivateBaseOfferRestDtoKycPromotionRequiredDetailsStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof DetailedRestDataResponseEditOfferRestStatusUserPrivateBaseOfferRestDtoKycPromotionRequiredDetails
     */
    'message'?: string;
    /**
     * 
     * @type {UserPrivateBuyOfferRestDto | UserPrivateSellOfferRestDto}
     * @memberof DetailedRestDataResponseEditOfferRestStatusUserPrivateBaseOfferRestDtoKycPromotionRequiredDetails
     */
    'data'?: UserPrivateBuyOfferRestDto | UserPrivateSellOfferRestDto;
    /**
     * 
     * @type {KycPromotionRequiredDetails}
     * @memberof DetailedRestDataResponseEditOfferRestStatusUserPrivateBaseOfferRestDtoKycPromotionRequiredDetails
     */
    'errorDetails'?: KycPromotionRequiredDetails;
}

export const DetailedRestDataResponseEditOfferRestStatusUserPrivateBaseOfferRestDtoKycPromotionRequiredDetailsStatusEnum = {
    Success: 'SUCCESS',
    KycPromotionRequired: 'KYC_PROMOTION_REQUIRED',
    Rejected: 'REJECTED',
    WrongPaymentDetails: 'WRONG_PAYMENT_DETAILS',
    TooManyPaymentsDetails: 'TOO_MANY_PAYMENTS_DETAILS',
    TooSmallMinOrderAmount: 'TOO_SMALL_MIN_ORDER_AMOUNT',
    OfferVolumeIsOutOfLimits: 'OFFER_VOLUME_IS_OUT_OF_LIMITS',
    PaymentConfirmTimeoutOutOfLimits: 'PAYMENT_CONFIRM_TIMEOUT_OUT_OF_LIMITS',
    FloatingPriceOutOfLimits: 'FLOATING_PRICE_OUT_OF_LIMITS',
    CommentTooLong: 'COMMENT_TOO_LONG',
    PaymentMethodsNotFound: 'PAYMENT_METHODS_NOT_FOUND',
    PaymentMethodsIsOutOfLimit: 'PAYMENT_METHODS_IS_OUT_OF_LIMIT',
    CurrencyIsNotSupportedByPaymentMethod: 'CURRENCY_IS_NOT_SUPPORTED_BY_PAYMENT_METHOD',
    AccessDenied: 'ACCESS_DENIED',
    NotFound: 'NOT_FOUND',
    FixedPriceOutOfLimits: 'FIXED_PRICE_OUT_OF_LIMITS',
    PhoneNumberRequired: 'PHONE_NUMBER_REQUIRED',
    NextVolumeLowerThanCurrent: 'NEXT_VOLUME_LOWER_THAN_CURRENT',
    NotEnoughMoneyForVolumeUpdate: 'NOT_ENOUGH_MONEY_FOR_VOLUME_UPDATE'
} as const;

export type DetailedRestDataResponseEditOfferRestStatusUserPrivateBaseOfferRestDtoKycPromotionRequiredDetailsStatusEnum = typeof DetailedRestDataResponseEditOfferRestStatusUserPrivateBaseOfferRestDtoKycPromotionRequiredDetailsStatusEnum[keyof typeof DetailedRestDataResponseEditOfferRestStatusUserPrivateBaseOfferRestDtoKycPromotionRequiredDetailsStatusEnum];

/**
 * 
 * @export
 * @interface DetailedRestResponseAcceptOrderRestStatusAcceptOrderErrorDetails
 */
export interface DetailedRestResponseAcceptOrderRestStatusAcceptOrderErrorDetails {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof DetailedRestResponseAcceptOrderRestStatusAcceptOrderErrorDetails
     */
    'status': DetailedRestResponseAcceptOrderRestStatusAcceptOrderErrorDetailsStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof DetailedRestResponseAcceptOrderRestStatusAcceptOrderErrorDetails
     */
    'message'?: string;
    /**
     * 
     * @type {AcceptOrderErrorDetails}
     * @memberof DetailedRestResponseAcceptOrderRestStatusAcceptOrderErrorDetails
     */
    'errorDetails'?: AcceptOrderErrorDetails;
}

export const DetailedRestResponseAcceptOrderRestStatusAcceptOrderErrorDetailsStatusEnum = {
    Success: 'SUCCESS',
    KycPromotionRequired: 'KYC_PROMOTION_REQUIRED',
    Rejected: 'REJECTED',
    OfferIllegalState: 'OFFER_ILLEGAL_STATE',
    TimeoutExpired: 'TIMEOUT_EXPIRED',
    NoVolumeEnough: 'NO_VOLUME_ENOUGH',
    AccessDeniedForBuyer: 'ACCESS_DENIED_FOR_BUYER',
    AccessDeniedForSeller: 'ACCESS_DENIED_FOR_SELLER',
    NotFound: 'NOT_FOUND'
} as const;

export type DetailedRestResponseAcceptOrderRestStatusAcceptOrderErrorDetailsStatusEnum = typeof DetailedRestResponseAcceptOrderRestStatusAcceptOrderErrorDetailsStatusEnum[keyof typeof DetailedRestResponseAcceptOrderRestStatusAcceptOrderErrorDetailsStatusEnum];

/**
 * 
 * @export
 * @interface DetailedRestResponseActivateOfferRestStatusKycPromotionRequiredDetails
 */
export interface DetailedRestResponseActivateOfferRestStatusKycPromotionRequiredDetails {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof DetailedRestResponseActivateOfferRestStatusKycPromotionRequiredDetails
     */
    'status': DetailedRestResponseActivateOfferRestStatusKycPromotionRequiredDetailsStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof DetailedRestResponseActivateOfferRestStatusKycPromotionRequiredDetails
     */
    'message'?: string;
    /**
     * 
     * @type {KycPromotionRequiredDetails}
     * @memberof DetailedRestResponseActivateOfferRestStatusKycPromotionRequiredDetails
     */
    'errorDetails'?: KycPromotionRequiredDetails;
}

export const DetailedRestResponseActivateOfferRestStatusKycPromotionRequiredDetailsStatusEnum = {
    Success: 'SUCCESS',
    KycPromotionRequired: 'KYC_PROMOTION_REQUIRED',
    Rejected: 'REJECTED',
    ActiveOfferCountLimitReached: 'ACTIVE_OFFER_COUNT_LIMIT_REACHED',
    NoVolumeEnough: 'NO_VOLUME_ENOUGH',
    NoOfferRemainingVolumeEnough: 'NO_OFFER_REMAINING_VOLUME_ENOUGH',
    NotCompleted: 'NOT_COMPLETED',
    AccessDenied: 'ACCESS_DENIED',
    NotFound: 'NOT_FOUND',
    EmptyPaymentDetails: 'EMPTY_PAYMENT_DETAILS',
    PhoneNumberRequired: 'PHONE_NUMBER_REQUIRED'
} as const;

export type DetailedRestResponseActivateOfferRestStatusKycPromotionRequiredDetailsStatusEnum = typeof DetailedRestResponseActivateOfferRestStatusKycPromotionRequiredDetailsStatusEnum[keyof typeof DetailedRestResponseActivateOfferRestStatusKycPromotionRequiredDetailsStatusEnum];

/**
 * 
 * @export
 * @interface DetailedRestResponseCheckMakerLimitsToBuyOfferRestStatusKycPromotionRequiredDetails
 */
export interface DetailedRestResponseCheckMakerLimitsToBuyOfferRestStatusKycPromotionRequiredDetails {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof DetailedRestResponseCheckMakerLimitsToBuyOfferRestStatusKycPromotionRequiredDetails
     */
    'status': DetailedRestResponseCheckMakerLimitsToBuyOfferRestStatusKycPromotionRequiredDetailsStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof DetailedRestResponseCheckMakerLimitsToBuyOfferRestStatusKycPromotionRequiredDetails
     */
    'message'?: string;
    /**
     * 
     * @type {KycPromotionRequiredDetails}
     * @memberof DetailedRestResponseCheckMakerLimitsToBuyOfferRestStatusKycPromotionRequiredDetails
     */
    'errorDetails'?: KycPromotionRequiredDetails;
}

export const DetailedRestResponseCheckMakerLimitsToBuyOfferRestStatusKycPromotionRequiredDetailsStatusEnum = {
    Success: 'SUCCESS',
    UnsupportedBaseCurrency: 'UNSUPPORTED_BASE_CURRENCY',
    AccessDenied: 'ACCESS_DENIED',
    KycPromotionRequired: 'KYC_PROMOTION_REQUIRED',
    Rejected: 'REJECTED'
} as const;

export type DetailedRestResponseCheckMakerLimitsToBuyOfferRestStatusKycPromotionRequiredDetailsStatusEnum = typeof DetailedRestResponseCheckMakerLimitsToBuyOfferRestStatusKycPromotionRequiredDetailsStatusEnum[keyof typeof DetailedRestResponseCheckMakerLimitsToBuyOfferRestStatusKycPromotionRequiredDetailsStatusEnum];

/**
 * 
 * @export
 * @interface DetailedRestResponseConfirmOrderRestStatusConfirmOrderErrorDetails
 */
export interface DetailedRestResponseConfirmOrderRestStatusConfirmOrderErrorDetails {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof DetailedRestResponseConfirmOrderRestStatusConfirmOrderErrorDetails
     */
    'status': DetailedRestResponseConfirmOrderRestStatusConfirmOrderErrorDetailsStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof DetailedRestResponseConfirmOrderRestStatusConfirmOrderErrorDetails
     */
    'message'?: string;
    /**
     * 
     * @type {ConfirmOrderErrorDetails}
     * @memberof DetailedRestResponseConfirmOrderRestStatusConfirmOrderErrorDetails
     */
    'errorDetails'?: ConfirmOrderErrorDetails;
}

export const DetailedRestResponseConfirmOrderRestStatusConfirmOrderErrorDetailsStatusEnum = {
    Success: 'SUCCESS',
    KycPromotionRequired: 'KYC_PROMOTION_REQUIRED',
    Rejected: 'REJECTED',
    OfferIllegalState: 'OFFER_ILLEGAL_STATE',
    TimeoutExpired: 'TIMEOUT_EXPIRED',
    TooManyOpenOrders: 'TOO_MANY_OPEN_ORDERS',
    AccessDeniedForBuyer: 'ACCESS_DENIED_FOR_BUYER',
    AccessDeniedForSeller: 'ACCESS_DENIED_FOR_SELLER',
    BiddingIsDisabled: 'BIDDING_IS_DISABLED',
    PhoneNumberRequired: 'PHONE_NUMBER_REQUIRED',
    NoVolumeEnough: 'NO_VOLUME_ENOUGH',
    NotFound: 'NOT_FOUND'
} as const;

export type DetailedRestResponseConfirmOrderRestStatusConfirmOrderErrorDetailsStatusEnum = typeof DetailedRestResponseConfirmOrderRestStatusConfirmOrderErrorDetailsStatusEnum[keyof typeof DetailedRestResponseConfirmOrderRestStatusConfirmOrderErrorDetailsStatusEnum];

/**
 * 
 * @export
 * @interface DisableAntifraudRestRequest
 */
export interface DisableAntifraudRestRequest {
    /**
     * 
     * @type {number}
     * @memberof DisableAntifraudRestRequest
     */
    'userId': number;
    /**
     * 
     * @type {string}
     * @memberof DisableAntifraudRestRequest
     */
    'rule': string;
    /**
     * 
     * @type {string}
     * @memberof DisableAntifraudRestRequest
     */
    'staffEmail': string;
    /**
     * 
     * @type {string}
     * @memberof DisableAntifraudRestRequest
     */
    'comment': string;
}
/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface DisableAntifraudRestResponse
 */
export interface DisableAntifraudRestResponse {
    /**
     * 
     * @type {number}
     * @memberof DisableAntifraudRestResponse
     */
    'ruleId': number;
}
/**
 * 
 * @export
 * @interface Document
 */
export interface Document {
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'fileId': string;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'fileName': string;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'mimeType': string;
    /**
     * 
     * @type {number}
     * @memberof Document
     */
    'fileSize': number;
}
/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface DomOfferRestDto
 */
export interface DomOfferRestDto {
    /**
     * 
     * @type {number}
     * @memberof DomOfferRestDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof DomOfferRestDto
     */
    'number': string;
    /**
     * 
     * @type {UserRestDto}
     * @memberof DomOfferRestDto
     */
    'user': UserRestDto;
    /**
     * 
     * @type {string}
     * @memberof DomOfferRestDto
     */
    'type': DomOfferRestDtoTypeEnum;
    /**
     * 
     * @type {PriceRestDto}
     * @memberof DomOfferRestDto
     */
    'price': PriceRestDto;
    /**
     * 
     * @type {string}
     * @memberof DomOfferRestDto
     */
    'availableVolume': string;
    /**
     * 
     * @type {MoneyAmountLimitsRestDto}
     * @memberof DomOfferRestDto
     */
    'orderAmountLimits': MoneyAmountLimitsRestDto;
    /**
     * 
     * @type {MoneyAmountLimitsRestDto}
     * @memberof DomOfferRestDto
     */
    'orderVolumeLimits': MoneyAmountLimitsRestDto;
    /**
     * 
     * @type {Array<PaymentMethodRestDto>}
     * @memberof DomOfferRestDto
     */
    'paymentMethods': Array<PaymentMethodRestDto>;
}

export const DomOfferRestDtoTypeEnum = {
    Sale: 'SALE',
    Purchase: 'PURCHASE'
} as const;

export type DomOfferRestDtoTypeEnum = typeof DomOfferRestDtoTypeEnum[keyof typeof DomOfferRestDtoTypeEnum];

/**
 * 
 * @export
 * @interface DomOffersRestRequest
 */
export interface DomOffersRestRequest {
    /**
     * 
     * @type {string}
     * @memberof DomOffersRestRequest
     */
    'baseCurrencyCode': string;
    /**
     * 
     * @type {string}
     * @memberof DomOffersRestRequest
     */
    'quoteCurrencyCode': string;
    /**
     * 
     * @type {string}
     * @memberof DomOffersRestRequest
     */
    'offerType': DomOffersRestRequestOfferTypeEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof DomOffersRestRequest
     */
    'paymentMethodCodes'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DomOffersRestRequest
     */
    'desiredAmount'?: string;
    /**
     * 
     * @type {number}
     * @memberof DomOffersRestRequest
     */
    'offset': number;
    /**
     * 
     * @type {number}
     * @memberof DomOffersRestRequest
     */
    'limit': number;
}

export const DomOffersRestRequestOfferTypeEnum = {
    Sale: 'SALE',
    Purchase: 'PURCHASE'
} as const;

export type DomOffersRestRequestOfferTypeEnum = typeof DomOffersRestRequestOfferTypeEnum[keyof typeof DomOffersRestRequestOfferTypeEnum];

/**
 * 
 * @export
 * @interface EditBuyOfferRestRequest
 */
export interface EditBuyOfferRestRequest extends EditOfferRestRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof EditBuyOfferRestRequest
     */
    'paymentMethodCodes'?: Array<string>;
}


/**
 * 
 * @export
 * @interface EditBuyOfferRestRequestAllOf
 */
export interface EditBuyOfferRestRequestAllOf {
    /**
     * 
     * @type {Array<string>}
     * @memberof EditBuyOfferRestRequestAllOf
     */
    'paymentMethodCodes'?: Array<string>;
}
/**
 * 
 * @export
 * @interface EditOfferRestRequest
 */
export interface EditOfferRestRequest {
    /**
     * 
     * @type {string}
     * @memberof EditOfferRestRequest
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditOfferRestRequest
     */
    'type': EditOfferRestRequestTypeEnum;
    /**
     * 
     * @type {EditPriceRequest}
     * @memberof EditOfferRestRequest
     */
    'price'?: EditPriceRequest;
    /**
     * 
     * @type {string}
     * @memberof EditOfferRestRequest
     */
    'paymentConfirmTimeout'?: string;
    /**
     * 
     * @type {OrderAmountLimitsRestRequest}
     * @memberof EditOfferRestRequest
     */
    'orderAmountLimits'?: OrderAmountLimitsRestRequest;
    /**
     * 
     * @type {string}
     * @memberof EditOfferRestRequest
     */
    'volume'?: string;
    /**
     * 
     * @type {number}
     * @memberof EditOfferRestRequest
     */
    'offerId': number;
}

export const EditOfferRestRequestTypeEnum = {
    Sale: 'SALE',
    Purchase: 'PURCHASE'
} as const;

export type EditOfferRestRequestTypeEnum = typeof EditOfferRestRequestTypeEnum[keyof typeof EditOfferRestRequestTypeEnum];

/**
 * 
 * @export
 * @interface EditPaymentDetailsBlacklistRestRequest
 */
export interface EditPaymentDetailsBlacklistRestRequest {
    /**
     * 
     * @type {number}
     * @memberof EditPaymentDetailsBlacklistRestRequest
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof EditPaymentDetailsBlacklistRestRequest
     */
    'staffId': number;
    /**
     * 
     * @type {string}
     * @memberof EditPaymentDetailsBlacklistRestRequest
     */
    'comment': string | null;
}
/**
 * 
 * @export
 * @interface EditPaymentDetailsRestRequest
 */
export interface EditPaymentDetailsRestRequest {
    /**
     * 
     * @type {number}
     * @memberof EditPaymentDetailsRestRequest
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof EditPaymentDetailsRestRequest
     */
    'paymentMethodCode': string;
    /**
     * 
     * @type {string}
     * @memberof EditPaymentDetailsRestRequest
     */
    'currencyCode': string;
    /**
     * 
     * @type {AttributesRestRequest}
     * @memberof EditPaymentDetailsRestRequest
     */
    'attributes': AttributesRestRequest;
    /**
     * 
     * @type {string}
     * @memberof EditPaymentDetailsRestRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface EditPriceRequest
 */
export interface EditPriceRequest {
    /**
     * 
     * @type {string}
     * @memberof EditPriceRequest
     */
    'type': EditPriceRequestTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof EditPriceRequest
     */
    'value': string;
}

export const EditPriceRequestTypeEnum = {
    Fixed: 'FIXED',
    Floating: 'FLOATING'
} as const;

export type EditPriceRequestTypeEnum = typeof EditPriceRequestTypeEnum[keyof typeof EditPriceRequestTypeEnum];

/**
 * 
 * @export
 * @interface EditSellOfferRestRequest
 */
export interface EditSellOfferRestRequest extends EditOfferRestRequest {
    /**
     * 
     * @type {Array<number>}
     * @memberof EditSellOfferRestRequest
     */
    'paymentDetailsIds'?: Array<number>;
}


/**
 * 
 * @export
 * @interface EditSellOfferRestRequestAllOf
 */
export interface EditSellOfferRestRequestAllOf {
    /**
     * 
     * @type {Array<number>}
     * @memberof EditSellOfferRestRequestAllOf
     */
    'paymentDetailsIds'?: Array<number>;
}
/**
 * 
 * @export
 * @interface ErrorResponseErrorRestDto
 */
export interface ErrorResponseErrorRestDto {
    /**
     * 
     * @type {boolean}
     * @memberof ErrorResponseErrorRestDto
     */
    'ok': boolean;
    /**
     * 
     * @type {number}
     * @memberof ErrorResponseErrorRestDto
     */
    'errorCode': number;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponseErrorRestDto
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface ExpressIdRequest
 */
export interface ExpressIdRequest {
    /**
     * 
     * @type {string}
     * @memberof ExpressIdRequest
     */
    'expressRequestId': string;
}
/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface ExpressRequestRestDto
 */
export interface ExpressRequestRestDto {
    /**
     * 
     * @type {string}
     * @memberof ExpressRequestRestDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ExpressRequestRestDto
     */
    'status': ExpressRequestRestDtoStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ExpressRequestRestDto
     */
    'offerType': ExpressRequestRestDtoOfferTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof ExpressRequestRestDto
     */
    'matchedOrderId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExpressRequestRestDto
     */
    'baseCurrencyCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExpressRequestRestDto
     */
    'quoteCurrencyCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExpressRequestRestDto
     */
    'calculationType'?: ExpressRequestRestDtoCalculationTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ExpressRequestRestDto
     */
    'amount'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExpressRequestRestDto
     */
    'volume'?: string;
    /**
     * 
     * @type {PaymentMethodRestDto}
     * @memberof ExpressRequestRestDto
     */
    'paymentMethod'?: PaymentMethodRestDto;
    /**
     * 
     * @type {string}
     * @memberof ExpressRequestRestDto
     */
    'matchFoundDateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExpressRequestRestDto
     */
    'cancelledDateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExpressRequestRestDto
     */
    'createdDateTime': string;
}

export const ExpressRequestRestDtoStatusEnum = {
    New: 'NEW',
    MatchFound: 'MATCH_FOUND',
    Completed: 'COMPLETED',
    Cancelled: 'CANCELLED'
} as const;

export type ExpressRequestRestDtoStatusEnum = typeof ExpressRequestRestDtoStatusEnum[keyof typeof ExpressRequestRestDtoStatusEnum];
export const ExpressRequestRestDtoOfferTypeEnum = {
    Sale: 'SALE',
    Purchase: 'PURCHASE'
} as const;

export type ExpressRequestRestDtoOfferTypeEnum = typeof ExpressRequestRestDtoOfferTypeEnum[keyof typeof ExpressRequestRestDtoOfferTypeEnum];
export const ExpressRequestRestDtoCalculationTypeEnum = {
    Amount: 'BY_AMOUNT',
    Volume: 'BY_VOLUME'
} as const;

export type ExpressRequestRestDtoCalculationTypeEnum = typeof ExpressRequestRestDtoCalculationTypeEnum[keyof typeof ExpressRequestRestDtoCalculationTypeEnum];

/**
 * 
 * @export
 * @interface FeeRestDto
 */
export interface FeeRestDto {
    /**
     * 
     * @type {string}
     * @memberof FeeRestDto
     */
    'rate': string;
    /**
     * 
     * @type {MoneyAmountRestDto}
     * @memberof FeeRestDto
     */
    'initVolume': MoneyAmountRestDto;
    /**
     * 
     * @type {MoneyAmountRestDto}
     * @memberof FeeRestDto
     */
    'availableVolume': MoneyAmountRestDto;
}
/**
 * 
 * @export
 * @interface FeeSettings
 */
export interface FeeSettings {
    /**
     * 
     * @type {string}
     * @memberof FeeSettings
     */
    'sellOfferForMakerPercent': string;
    /**
     * 
     * @type {string}
     * @memberof FeeSettings
     */
    'buyOfferForTakerPercent': string;
}
/**
 * 
 * @export
 * @interface Filter
 */
export interface Filter {
    /**
     * 
     * @type {string}
     * @memberof Filter
     */
    'status'?: FilterStatusEnum;
}

export const FilterStatusEnum = {
    Active: 'ALL_ACTIVE',
    Completed: 'ALL_COMPLETED'
} as const;

export type FilterStatusEnum = typeof FilterStatusEnum[keyof typeof FilterStatusEnum];

/**
 * 
 * @export
 * @interface FindCurrencyPairsRequest
 */
export interface FindCurrencyPairsRequest {
    /**
     * 
     * @type {string}
     * @memberof FindCurrencyPairsRequest
     */
    'offerType': FindCurrencyPairsRequestOfferTypeEnum;
}

export const FindCurrencyPairsRequestOfferTypeEnum = {
    Sale: 'SALE',
    Purchase: 'PURCHASE'
} as const;

export type FindCurrencyPairsRequestOfferTypeEnum = typeof FindCurrencyPairsRequestOfferTypeEnum[keyof typeof FindCurrencyPairsRequestOfferTypeEnum];

/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface FindCurrencyPairsResponse
 */
export interface FindCurrencyPairsResponse {
    /**
     * 
     * @type {Array<CurrencyPairsRestDto>}
     * @memberof FindCurrencyPairsResponse
     */
    'pairs': Array<CurrencyPairsRestDto>;
}
/**
 * 
 * @export
 * @interface FindPaymentMethodSchemaRestRequest
 */
export interface FindPaymentMethodSchemaRestRequest {
    /**
     * 
     * @type {string}
     * @memberof FindPaymentMethodSchemaRestRequest
     */
    'paymentMethodCode': string;
    /**
     * 
     * @type {string}
     * @memberof FindPaymentMethodSchemaRestRequest
     */
    'currencyCode': string;
}
/**
 * 
 * @export
 * @interface FindPaymentMethodsRequest
 */
export interface FindPaymentMethodsRequest {
    /**
     * 
     * @type {string}
     * @memberof FindPaymentMethodsRequest
     */
    'offerType': FindPaymentMethodsRequestOfferTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof FindPaymentMethodsRequest
     */
    'baseCurrencyCode': string;
    /**
     * 
     * @type {string}
     * @memberof FindPaymentMethodsRequest
     */
    'quoteCurrencyCode': string;
    /**
     * 
     * @type {string}
     * @memberof FindPaymentMethodsRequest
     */
    'amount'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindPaymentMethodsRequest
     */
    'volume'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindPaymentMethodsRequest
     */
    'calculationType': FindPaymentMethodsRequestCalculationTypeEnum;
}

export const FindPaymentMethodsRequestOfferTypeEnum = {
    Sale: 'SALE',
    Purchase: 'PURCHASE'
} as const;

export type FindPaymentMethodsRequestOfferTypeEnum = typeof FindPaymentMethodsRequestOfferTypeEnum[keyof typeof FindPaymentMethodsRequestOfferTypeEnum];
export const FindPaymentMethodsRequestCalculationTypeEnum = {
    Amount: 'BY_AMOUNT',
    Volume: 'BY_VOLUME'
} as const;

export type FindPaymentMethodsRequestCalculationTypeEnum = typeof FindPaymentMethodsRequestCalculationTypeEnum[keyof typeof FindPaymentMethodsRequestCalculationTypeEnum];

/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface FindPaymentMethodsResponse
 */
export interface FindPaymentMethodsResponse {
    /**
     * 
     * @type {Array<PaymentMethodInActiveOffersRestDto>}
     * @memberof FindPaymentMethodsResponse
     */
    'paymentMethods': Array<PaymentMethodInActiveOffersRestDto>;
}
/**
 * 
 * @export
 * @interface FixedPrice
 */
export interface FixedPrice extends Price {
}
/**
 * 
 * @export
 * @interface FloatingPrice
 */
export interface FloatingPrice extends Price {
}
/**
 * 
 * @export
 * @interface GenerateApiKeyRequest
 */
export interface GenerateApiKeyRequest {
    /**
     * 
     * @type {number}
     * @memberof GenerateApiKeyRequest
     */
    'userId': number;
}
/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface GenerateApiKeyResponse
 */
export interface GenerateApiKeyResponse {
    /**
     * 
     * @type {string}
     * @memberof GenerateApiKeyResponse
     */
    'apiKey': string;
}
/**
 * 
 * @export
 * @interface GetLimitsRequest
 */
export interface GetLimitsRequest {
    /**
     * 
     * @type {string}
     * @memberof GetLimitsRequest
     */
    'offerType': GetLimitsRequestOfferTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof GetLimitsRequest
     */
    'baseCurrencyCode': string;
    /**
     * 
     * @type {string}
     * @memberof GetLimitsRequest
     */
    'quoteCurrencyCode': string;
}

export const GetLimitsRequestOfferTypeEnum = {
    Sale: 'SALE',
    Purchase: 'PURCHASE'
} as const;

export type GetLimitsRequestOfferTypeEnum = typeof GetLimitsRequestOfferTypeEnum[keyof typeof GetLimitsRequestOfferTypeEnum];

/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface GetLimitsResponse
 */
export interface GetLimitsResponse {
    /**
     * 
     * @type {string}
     * @memberof GetLimitsResponse
     */
    'price': string;
    /**
     * 
     * @type {MoneyAmountLimitsRestDto}
     * @memberof GetLimitsResponse
     */
    'overallAmountLimits': MoneyAmountLimitsRestDto;
    /**
     * 
     * @type {MoneyAmountLimitsRestDto}
     * @memberof GetLimitsResponse
     */
    'overallVolumeLimits': MoneyAmountLimitsRestDto;
}
/**
 * 
 * @export
 * @interface GetOfferFixedPriceLimitsRestRequest
 */
export interface GetOfferFixedPriceLimitsRestRequest {
    /**
     * 
     * @type {string}
     * @memberof GetOfferFixedPriceLimitsRestRequest
     */
    'baseCurrencyCode': string;
    /**
     * 
     * @type {string}
     * @memberof GetOfferFixedPriceLimitsRestRequest
     */
    'quoteCurrencyCode': string;
}
/**
 * 
 * @export
 * @interface GetOfferRestRequest
 */
export interface GetOfferRestRequest {
    /**
     * 
     * @type {number}
     * @memberof GetOfferRestRequest
     */
    'offerId': number;
}
/**
 * 
 * @export
 * @interface GetOffersByUserIdV2Request
 */
export interface GetOffersByUserIdV2Request {
    /**
     * 
     * @type {string}
     * @memberof GetOffersByUserIdV2Request
     */
    'offerType'?: GetOffersByUserIdV2RequestOfferTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof GetOffersByUserIdV2Request
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetOffersByUserIdV2Request
     */
    'limit'?: number;
}

export const GetOffersByUserIdV2RequestOfferTypeEnum = {
    Sale: 'SALE',
    Purchase: 'PURCHASE'
} as const;

export type GetOffersByUserIdV2RequestOfferTypeEnum = typeof GetOffersByUserIdV2RequestOfferTypeEnum[keyof typeof GetOffersByUserIdV2RequestOfferTypeEnum];

/**
 * 
 * @export
 * @interface GetUserAvailableBalanceWithoutBuyOrderFeeRestRequest
 */
export interface GetUserAvailableBalanceWithoutBuyOrderFeeRestRequest {
    /**
     * 
     * @type {string}
     * @memberof GetUserAvailableBalanceWithoutBuyOrderFeeRestRequest
     */
    'currencyCode': string;
}
/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface GetUserAvailableBalanceWithoutBuyOrderFeeRestResponse
 */
export interface GetUserAvailableBalanceWithoutBuyOrderFeeRestResponse {
    /**
     * 
     * @type {MoneyAmountRestDto}
     * @memberof GetUserAvailableBalanceWithoutBuyOrderFeeRestResponse
     */
    'balance': MoneyAmountRestDto;
}
/**
 * 
 * @export
 * @interface GetUserPrivateOfferRestRequest
 */
export interface GetUserPrivateOfferRestRequest {
    /**
     * 
     * @type {number}
     * @memberof GetUserPrivateOfferRestRequest
     */
    'offerId': number;
}
/**
 * 
 * @export
 * @interface HealthStatus
 */
export interface HealthStatus {
    /**
     * 
     * @type {string}
     * @memberof HealthStatus
     */
    'state': HealthStatusStateEnum;
    /**
     * 
     * @type {boolean}
     * @memberof HealthStatus
     */
    'serviceAvailable': boolean;
}

export const HealthStatusStateEnum = {
    Ok: 'OK',
    ConnectionFailed: 'CONNECTION_FAILED',
    NotReady: 'NOT_READY'
} as const;

export type HealthStatusStateEnum = typeof HealthStatusStateEnum[keyof typeof HealthStatusStateEnum];

/**
 * 
 * @export
 * @interface HealthStatusResponse
 */
export interface HealthStatusResponse {
    /**
     * 
     * @type {string}
     * @memberof HealthStatusResponse
     */
    'instance_id': string;
    /**
     * 
     * @type {{ [key: string]: HealthStatus; }}
     * @memberof HealthStatusResponse
     */
    'resources_status': { [key: string]: HealthStatus; };
}
/**
 * 
 * @export
 * @interface InternalDomOffersRestRequest
 */
export interface InternalDomOffersRestRequest {
    /**
     * 
     * @type {number}
     * @memberof InternalDomOffersRestRequest
     */
    'userId': number;
    /**
     * 
     * @type {string}
     * @memberof InternalDomOffersRestRequest
     */
    'baseCurrencyCode': string;
    /**
     * 
     * @type {string}
     * @memberof InternalDomOffersRestRequest
     */
    'quoteCurrencyCode': string;
    /**
     * 
     * @type {string}
     * @memberof InternalDomOffersRestRequest
     */
    'offerType': InternalDomOffersRestRequestOfferTypeEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof InternalDomOffersRestRequest
     */
    'paymentMethodCodes'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof InternalDomOffersRestRequest
     */
    'desiredAmount'?: string;
    /**
     * 
     * @type {number}
     * @memberof InternalDomOffersRestRequest
     */
    'offset': number;
    /**
     * 
     * @type {number}
     * @memberof InternalDomOffersRestRequest
     */
    'limit': number;
}

export const InternalDomOffersRestRequestOfferTypeEnum = {
    Sale: 'SALE',
    Purchase: 'PURCHASE'
} as const;

export type InternalDomOffersRestRequestOfferTypeEnum = typeof InternalDomOffersRestRequestOfferTypeEnum[keyof typeof InternalDomOffersRestRequestOfferTypeEnum];

/**
 * 
 * @export
 * @interface ItemOfferStatus
 */
export interface ItemOfferStatus {
    /**
     * 
     * @type {string}
     * @memberof ItemOfferStatus
     */
    'status': ItemOfferStatusStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ItemOfferStatus
     */
    'createDateTime': string;
    /**
     * 
     * @type {number}
     * @memberof ItemOfferStatus
     */
    'initiatorUserId'?: number;
}

export const ItemOfferStatusStatusEnum = {
    Inactive: 'INACTIVE',
    Activating: 'ACTIVATING',
    Active: 'ACTIVE',
    Deactivating: 'DEACTIVATING',
    Killed: 'KILLED',
    Deleted: 'DELETED',
    Updating: 'UPDATING'
} as const;

export type ItemOfferStatusStatusEnum = typeof ItemOfferStatusStatusEnum[keyof typeof ItemOfferStatusStatusEnum];

/**
 * 
 * @export
 * @interface ItemOrderStatus
 */
export interface ItemOrderStatus {
    /**
     * 
     * @type {string}
     * @memberof ItemOrderStatus
     */
    'status': ItemOrderStatusStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ItemOrderStatus
     */
    'createDateTime': string;
    /**
     * 
     * @type {number}
     * @memberof ItemOrderStatus
     */
    'initiatorUserId'?: number;
}

export const ItemOrderStatusStatusEnum = {
    Draft: 'DRAFT',
    ConfirmingOrder: 'CONFIRMING_ORDER',
    New: 'NEW',
    Rejected: 'REJECTED',
    AcceptingOrder: 'ACCEPTING_ORDER',
    AcceptedOrder: 'ACCEPTED_ORDER',
    ConfirmedSendingPaymentByBuyer: 'CONFIRMED_SENDING_PAYMENT_BY_BUYER',
    TimeoutExpiredSendingPaymentByBuyer: 'TIMEOUT_EXPIRED_SENDING_PAYMENT_BY_BUYER',
    ConfirmedReceiptPaymentBySeller: 'CONFIRMED_RECEIPT_PAYMENT_BY_SELLER',
    OnAppeal: 'ON_APPEAL',
    AppealResolved: 'APPEAL_RESOLVED',
    Completed: 'COMPLETED',
    Cancelling: 'CANCELLING',
    Cancelled: 'CANCELLED'
} as const;

export type ItemOrderStatusStatusEnum = typeof ItemOrderStatusStatusEnum[keyof typeof ItemOrderStatusStatusEnum];

/**
 * Errors details, present if status is not SUCCESS
 * @export
 * @interface KycPromotionRequiredDetails
 */
export interface KycPromotionRequiredDetails {
    /**
     * 
     * @type {string}
     * @memberof KycPromotionRequiredDetails
     */
    'promotionKYCLevel': KycPromotionRequiredDetailsPromotionKYCLevelEnum;
}

export const KycPromotionRequiredDetailsPromotionKYCLevelEnum = {
    _0: 'LEVEL_0',
    _1: 'LEVEL_1',
    _2: 'LEVEL_2',
    _3: 'LEVEL_3',
    _4: 'LEVEL_4'
} as const;

export type KycPromotionRequiredDetailsPromotionKYCLevelEnum = typeof KycPromotionRequiredDetailsPromotionKYCLevelEnum[keyof typeof KycPromotionRequiredDetailsPromotionKYCLevelEnum];

/**
 * 
 * @export
 * @interface LimitsBigDecimal
 */
export interface LimitsBigDecimal {
    /**
     * 
     * @type {string}
     * @memberof LimitsBigDecimal
     */
    'minInclusive': string;
    /**
     * 
     * @type {string}
     * @memberof LimitsBigDecimal
     */
    'maxInclusive': string;
}
/**
 * 
 * @export
 * @interface LimitsDuration
 */
export interface LimitsDuration {
    /**
     * 
     * @type {string}
     * @memberof LimitsDuration
     */
    'minInclusive': string;
    /**
     * 
     * @type {string}
     * @memberof LimitsDuration
     */
    'maxInclusive': string;
}
/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface ListOrderViewRestDto
 */
export interface ListOrderViewRestDto {
    /**
     * 
     * @type {number}
     * @memberof ListOrderViewRestDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ListOrderViewRestDto
     */
    'number': string;
    /**
     * 
     * @type {number}
     * @memberof ListOrderViewRestDto
     */
    'sellerUserId': number;
    /**
     * 
     * @type {number}
     * @memberof ListOrderViewRestDto
     */
    'buyerUserId': number;
    /**
     * 
     * @type {number}
     * @memberof ListOrderViewRestDto
     */
    'offerId': number;
    /**
     * 
     * @type {string}
     * @memberof ListOrderViewRestDto
     */
    'offerType': ListOrderViewRestDtoOfferTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ListOrderViewRestDto
     */
    'offerComment'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListOrderViewRestDto
     */
    'offerNumber': string;
    /**
     * 
     * @type {number}
     * @memberof ListOrderViewRestDto
     */
    'offerUserId': number;
    /**
     * 
     * @type {string}
     * @memberof ListOrderViewRestDto
     */
    'baseCurrencyCode': string;
    /**
     * 
     * @type {string}
     * @memberof ListOrderViewRestDto
     */
    'quotedCurrencyCode': string;
    /**
     * 
     * @type {string}
     * @memberof ListOrderViewRestDto
     */
    'paymentConfirmTimeout': string;
    /**
     * 
     * @type {string}
     * @memberof ListOrderViewRestDto
     */
    'createDateTime': string;
    /**
     * 
     * @type {string}
     * @memberof ListOrderViewRestDto
     */
    'confirmationDateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListOrderViewRestDto
     */
    'acceptDateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListOrderViewRestDto
     */
    'statusUpdateDateTime': string;
    /**
     * 
     * @type {string}
     * @memberof ListOrderViewRestDto
     */
    'status': ListOrderViewRestDtoStatusEnum;
}

export const ListOrderViewRestDtoOfferTypeEnum = {
    Sale: 'SALE',
    Purchase: 'PURCHASE'
} as const;

export type ListOrderViewRestDtoOfferTypeEnum = typeof ListOrderViewRestDtoOfferTypeEnum[keyof typeof ListOrderViewRestDtoOfferTypeEnum];
export const ListOrderViewRestDtoStatusEnum = {
    Draft: 'DRAFT',
    ConfirmingOrder: 'CONFIRMING_ORDER',
    New: 'NEW',
    Rejected: 'REJECTED',
    AcceptingOrder: 'ACCEPTING_ORDER',
    AcceptedOrder: 'ACCEPTED_ORDER',
    ConfirmedSendingPaymentByBuyer: 'CONFIRMED_SENDING_PAYMENT_BY_BUYER',
    TimeoutExpiredSendingPaymentByBuyer: 'TIMEOUT_EXPIRED_SENDING_PAYMENT_BY_BUYER',
    ConfirmedReceiptPaymentBySeller: 'CONFIRMED_RECEIPT_PAYMENT_BY_SELLER',
    OnAppeal: 'ON_APPEAL',
    AppealResolved: 'APPEAL_RESOLVED',
    Completed: 'COMPLETED',
    Cancelling: 'CANCELLING',
    Cancelled: 'CANCELLED'
} as const;

export type ListOrderViewRestDtoStatusEnum = typeof ListOrderViewRestDtoStatusEnum[keyof typeof ListOrderViewRestDtoStatusEnum];

/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface ListOrderViewWithActiveAppealRestDto
 */
export interface ListOrderViewWithActiveAppealRestDto {
    /**
     * 
     * @type {number}
     * @memberof ListOrderViewWithActiveAppealRestDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ListOrderViewWithActiveAppealRestDto
     */
    'number': string;
    /**
     * 
     * @type {number}
     * @memberof ListOrderViewWithActiveAppealRestDto
     */
    'sellerUserId': number;
    /**
     * 
     * @type {number}
     * @memberof ListOrderViewWithActiveAppealRestDto
     */
    'buyerUserId': number;
    /**
     * 
     * @type {number}
     * @memberof ListOrderViewWithActiveAppealRestDto
     */
    'offerId': number;
    /**
     * 
     * @type {string}
     * @memberof ListOrderViewWithActiveAppealRestDto
     */
    'offerType': ListOrderViewWithActiveAppealRestDtoOfferTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ListOrderViewWithActiveAppealRestDto
     */
    'offerComment'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListOrderViewWithActiveAppealRestDto
     */
    'offerNumber': string;
    /**
     * 
     * @type {number}
     * @memberof ListOrderViewWithActiveAppealRestDto
     */
    'offerUserId': number;
    /**
     * 
     * @type {string}
     * @memberof ListOrderViewWithActiveAppealRestDto
     */
    'baseCurrencyCode': string;
    /**
     * 
     * @type {string}
     * @memberof ListOrderViewWithActiveAppealRestDto
     */
    'quotedCurrencyCode': string;
    /**
     * 
     * @type {string}
     * @memberof ListOrderViewWithActiveAppealRestDto
     */
    'paymentConfirmTimeout': string;
    /**
     * 
     * @type {string}
     * @memberof ListOrderViewWithActiveAppealRestDto
     */
    'createDateTime': string;
    /**
     * 
     * @type {string}
     * @memberof ListOrderViewWithActiveAppealRestDto
     */
    'confirmationDateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListOrderViewWithActiveAppealRestDto
     */
    'acceptDateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListOrderViewWithActiveAppealRestDto
     */
    'statusUpdateDateTime': string;
    /**
     * 
     * @type {string}
     * @memberof ListOrderViewWithActiveAppealRestDto
     */
    'status': ListOrderViewWithActiveAppealRestDtoStatusEnum;
    /**
     * 
     * @type {AppealRestDto}
     * @memberof ListOrderViewWithActiveAppealRestDto
     */
    'appeal': AppealRestDto;
}

export const ListOrderViewWithActiveAppealRestDtoOfferTypeEnum = {
    Sale: 'SALE',
    Purchase: 'PURCHASE'
} as const;

export type ListOrderViewWithActiveAppealRestDtoOfferTypeEnum = typeof ListOrderViewWithActiveAppealRestDtoOfferTypeEnum[keyof typeof ListOrderViewWithActiveAppealRestDtoOfferTypeEnum];
export const ListOrderViewWithActiveAppealRestDtoStatusEnum = {
    Draft: 'DRAFT',
    ConfirmingOrder: 'CONFIRMING_ORDER',
    New: 'NEW',
    Rejected: 'REJECTED',
    AcceptingOrder: 'ACCEPTING_ORDER',
    AcceptedOrder: 'ACCEPTED_ORDER',
    ConfirmedSendingPaymentByBuyer: 'CONFIRMED_SENDING_PAYMENT_BY_BUYER',
    TimeoutExpiredSendingPaymentByBuyer: 'TIMEOUT_EXPIRED_SENDING_PAYMENT_BY_BUYER',
    ConfirmedReceiptPaymentBySeller: 'CONFIRMED_RECEIPT_PAYMENT_BY_SELLER',
    OnAppeal: 'ON_APPEAL',
    AppealResolved: 'APPEAL_RESOLVED',
    Completed: 'COMPLETED',
    Cancelling: 'CANCELLING',
    Cancelled: 'CANCELLED'
} as const;

export type ListOrderViewWithActiveAppealRestDtoStatusEnum = typeof ListOrderViewWithActiveAppealRestDtoStatusEnum[keyof typeof ListOrderViewWithActiveAppealRestDtoStatusEnum];

/**
 * All filters and sorts orders are optional, all non-null filters will be applied with AND
 * @export
 * @interface ListOrdersRestRequest
 */
export interface ListOrdersRestRequest {
    /**
     * 
     * @type {number}
     * @memberof ListOrdersRestRequest
     */
    'orderIdFilter'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ListOrdersRestRequest
     */
    'orderNumberFilter'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ListOrdersRestRequest
     */
    'orderSellerUserIdFilter'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ListOrdersRestRequest
     */
    'orderBuyerUserIdFilter'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ListOrdersRestRequest
     */
    'offerIdFilter'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ListOrdersRestRequest
     */
    'offerNumberFilter'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ListOrdersRestRequest
     */
    'offerUserIdFilter'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ListOrdersRestRequest
     */
    'orderAcceptDateTimeSort'?: ListOrdersRestRequestOrderAcceptDateTimeSortEnum;
    /**
     * 
     * @type {number}
     * @memberof ListOrdersRestRequest
     */
    'offset'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ListOrdersRestRequest
     */
    'limit': number;
}

export const ListOrdersRestRequestOrderAcceptDateTimeSortEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;

export type ListOrdersRestRequestOrderAcceptDateTimeSortEnum = typeof ListOrdersRestRequestOrderAcceptDateTimeSortEnum[keyof typeof ListOrdersRestRequestOrderAcceptDateTimeSortEnum];

/**
 * All filters and sorts orders are optional, all non-null filters will be applied with AND
 * @export
 * @interface ListOrdersWithActiveAppealRestRequest
 */
export interface ListOrdersWithActiveAppealRestRequest {
    /**
     * 
     * @type {number}
     * @memberof ListOrdersWithActiveAppealRestRequest
     */
    'orderIdFilter'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ListOrdersWithActiveAppealRestRequest
     */
    'orderNumberFilter'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ListOrdersWithActiveAppealRestRequest
     */
    'orderSellerUserIdFilter'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ListOrdersWithActiveAppealRestRequest
     */
    'orderBuyerUserIdFilter'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ListOrdersWithActiveAppealRestRequest
     */
    'offerIdFilter'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ListOrdersWithActiveAppealRestRequest
     */
    'offerNumberFilter'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ListOrdersWithActiveAppealRestRequest
     */
    'offerUserIdFilter'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ListOrdersWithActiveAppealRestRequest
     */
    'baseCurrencyCodeFilter'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListOrdersWithActiveAppealRestRequest
     */
    'quotedCurrencyCodeFilter'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListOrdersWithActiveAppealRestRequest
     */
    'orderCreateDateTimeMinInclusive'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListOrdersWithActiveAppealRestRequest
     */
    'orderCreateDateTimeMaxInclusive'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListOrdersWithActiveAppealRestRequest
     */
    'appealCreateDateTimeMinInclusive'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListOrdersWithActiveAppealRestRequest
     */
    'appealCreateDateTimeMaxInclusive'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListOrdersWithActiveAppealRestRequest
     */
    'appealOrderStatusAtAppealFilter'?: ListOrdersWithActiveAppealRestRequestAppealOrderStatusAtAppealFilterEnum;
    /**
     * 
     * @type {string}
     * @memberof ListOrdersWithActiveAppealRestRequest
     */
    'orderAcceptDateTimeSort'?: ListOrdersWithActiveAppealRestRequestOrderAcceptDateTimeSortEnum;
    /**
     * 
     * @type {string}
     * @memberof ListOrdersWithActiveAppealRestRequest
     */
    'appealCreateDateTimeSort'?: ListOrdersWithActiveAppealRestRequestAppealCreateDateTimeSortEnum;
    /**
     * 
     * @type {number}
     * @memberof ListOrdersWithActiveAppealRestRequest
     */
    'offset'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ListOrdersWithActiveAppealRestRequest
     */
    'limit': number;
}

export const ListOrdersWithActiveAppealRestRequestAppealOrderStatusAtAppealFilterEnum = {
    Draft: 'DRAFT',
    ConfirmingOrder: 'CONFIRMING_ORDER',
    New: 'NEW',
    Rejected: 'REJECTED',
    AcceptingOrder: 'ACCEPTING_ORDER',
    AcceptedOrder: 'ACCEPTED_ORDER',
    ConfirmedSendingPaymentByBuyer: 'CONFIRMED_SENDING_PAYMENT_BY_BUYER',
    TimeoutExpiredSendingPaymentByBuyer: 'TIMEOUT_EXPIRED_SENDING_PAYMENT_BY_BUYER',
    ConfirmedReceiptPaymentBySeller: 'CONFIRMED_RECEIPT_PAYMENT_BY_SELLER',
    OnAppeal: 'ON_APPEAL',
    AppealResolved: 'APPEAL_RESOLVED',
    Completed: 'COMPLETED',
    Cancelling: 'CANCELLING',
    Cancelled: 'CANCELLED'
} as const;

export type ListOrdersWithActiveAppealRestRequestAppealOrderStatusAtAppealFilterEnum = typeof ListOrdersWithActiveAppealRestRequestAppealOrderStatusAtAppealFilterEnum[keyof typeof ListOrdersWithActiveAppealRestRequestAppealOrderStatusAtAppealFilterEnum];
export const ListOrdersWithActiveAppealRestRequestOrderAcceptDateTimeSortEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;

export type ListOrdersWithActiveAppealRestRequestOrderAcceptDateTimeSortEnum = typeof ListOrdersWithActiveAppealRestRequestOrderAcceptDateTimeSortEnum[keyof typeof ListOrdersWithActiveAppealRestRequestOrderAcceptDateTimeSortEnum];
export const ListOrdersWithActiveAppealRestRequestAppealCreateDateTimeSortEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;

export type ListOrdersWithActiveAppealRestRequestAppealCreateDateTimeSortEnum = typeof ListOrdersWithActiveAppealRestRequestAppealCreateDateTimeSortEnum[keyof typeof ListOrdersWithActiveAppealRestRequestAppealCreateDateTimeSortEnum];

/**
 * 
 * @export
 * @interface ListPaymentDetailsBlacklistRestRequest
 */
export interface ListPaymentDetailsBlacklistRestRequest {
    /**
     * 
     * @type {number}
     * @memberof ListPaymentDetailsBlacklistRestRequest
     */
    'userIdFilter'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ListPaymentDetailsBlacklistRestRequest
     */
    'paymentDetailsNumberFilter'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListPaymentDetailsBlacklistRestRequest
     */
    'createdDateTimeSort'?: ListPaymentDetailsBlacklistRestRequestCreatedDateTimeSortEnum;
    /**
     * 
     * @type {number}
     * @memberof ListPaymentDetailsBlacklistRestRequest
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof ListPaymentDetailsBlacklistRestRequest
     */
    'offset': number;
}

export const ListPaymentDetailsBlacklistRestRequestCreatedDateTimeSortEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;

export type ListPaymentDetailsBlacklistRestRequestCreatedDateTimeSortEnum = typeof ListPaymentDetailsBlacklistRestRequestCreatedDateTimeSortEnum[keyof typeof ListPaymentDetailsBlacklistRestRequestCreatedDateTimeSortEnum];

/**
 * 
 * @export
 * @interface MaxArraySizeRuleRestDto
 */
export interface MaxArraySizeRuleRestDto extends ValidationRuleRestDto {
    /**
     * 
     * @type {string}
     * @memberof MaxArraySizeRuleRestDto
     */
    'type': MaxArraySizeRuleRestDtoTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof MaxArraySizeRuleRestDto
     */
    'value': number;
}

export const MaxArraySizeRuleRestDtoTypeEnum = {
    Required: 'REQUIRED',
    MaxLength: 'MAX_LENGTH',
    MaxArraySize: 'MAX_ARRAY_SIZE',
    MinLength: 'MIN_LENGTH',
    RegexPattern: 'REGEX_PATTERN'
} as const;

export type MaxArraySizeRuleRestDtoTypeEnum = typeof MaxArraySizeRuleRestDtoTypeEnum[keyof typeof MaxArraySizeRuleRestDtoTypeEnum];

/**
 * 
 * @export
 * @interface MaxArraySizeRuleRestDtoAllOf
 */
export interface MaxArraySizeRuleRestDtoAllOf {
    /**
     * 
     * @type {string}
     * @memberof MaxArraySizeRuleRestDtoAllOf
     */
    'type'?: MaxArraySizeRuleRestDtoAllOfTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof MaxArraySizeRuleRestDtoAllOf
     */
    'value'?: number;
}

export const MaxArraySizeRuleRestDtoAllOfTypeEnum = {
    Required: 'REQUIRED',
    MaxLength: 'MAX_LENGTH',
    MaxArraySize: 'MAX_ARRAY_SIZE',
    MinLength: 'MIN_LENGTH',
    RegexPattern: 'REGEX_PATTERN'
} as const;

export type MaxArraySizeRuleRestDtoAllOfTypeEnum = typeof MaxArraySizeRuleRestDtoAllOfTypeEnum[keyof typeof MaxArraySizeRuleRestDtoAllOfTypeEnum];

/**
 * 
 * @export
 * @interface MaxLengthRuleRestDto
 */
export interface MaxLengthRuleRestDto extends ValidationRuleRestDto {
    /**
     * 
     * @type {string}
     * @memberof MaxLengthRuleRestDto
     */
    'type': MaxLengthRuleRestDtoTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof MaxLengthRuleRestDto
     */
    'value': number;
}

export const MaxLengthRuleRestDtoTypeEnum = {
    Required: 'REQUIRED',
    MaxLength: 'MAX_LENGTH',
    MaxArraySize: 'MAX_ARRAY_SIZE',
    MinLength: 'MIN_LENGTH',
    RegexPattern: 'REGEX_PATTERN'
} as const;

export type MaxLengthRuleRestDtoTypeEnum = typeof MaxLengthRuleRestDtoTypeEnum[keyof typeof MaxLengthRuleRestDtoTypeEnum];

/**
 * 
 * @export
 * @interface MerchantApiResponseAllOffersStatusPageOfferLong
 */
export interface MerchantApiResponseAllOffersStatusPageOfferLong {
    /**
     * Status of request execution
     * @type {string}
     * @memberof MerchantApiResponseAllOffersStatusPageOfferLong
     */
    'status': MerchantApiResponseAllOffersStatusPageOfferLongStatusEnum;
    /**
     * 
     * @type {PageOfferLong}
     * @memberof MerchantApiResponseAllOffersStatusPageOfferLong
     */
    'data'?: PageOfferLong;
    /**
     * Error details if any
     * @type {string}
     * @memberof MerchantApiResponseAllOffersStatusPageOfferLong
     */
    'errorMessage'?: string;
}

export const MerchantApiResponseAllOffersStatusPageOfferLongStatusEnum = {
    Success: 'SUCCESS'
} as const;

export type MerchantApiResponseAllOffersStatusPageOfferLongStatusEnum = typeof MerchantApiResponseAllOffersStatusPageOfferLongStatusEnum[keyof typeof MerchantApiResponseAllOffersStatusPageOfferLongStatusEnum];

/**
 * 
 * @export
 * @interface MerchantApiResponseGetOfferByIdStatusOffer
 */
export interface MerchantApiResponseGetOfferByIdStatusOffer {
    /**
     * Status of request execution
     * @type {string}
     * @memberof MerchantApiResponseGetOfferByIdStatusOffer
     */
    'status': MerchantApiResponseGetOfferByIdStatusOfferStatusEnum;
    /**
     * 
     * @type {Offer}
     * @memberof MerchantApiResponseGetOfferByIdStatusOffer
     */
    'data'?: Offer;
    /**
     * Error details if any
     * @type {string}
     * @memberof MerchantApiResponseGetOfferByIdStatusOffer
     */
    'errorMessage'?: string;
}

export const MerchantApiResponseGetOfferByIdStatusOfferStatusEnum = {
    Success: 'SUCCESS',
    NotFound: 'NOT_FOUND'
} as const;

export type MerchantApiResponseGetOfferByIdStatusOfferStatusEnum = typeof MerchantApiResponseGetOfferByIdStatusOfferStatusEnum[keyof typeof MerchantApiResponseGetOfferByIdStatusOfferStatusEnum];

/**
 * 
 * @export
 * @interface MerchantApiResponseGetOpenOrdersStatusPageOrderLong
 */
export interface MerchantApiResponseGetOpenOrdersStatusPageOrderLong {
    /**
     * Status of request execution
     * @type {string}
     * @memberof MerchantApiResponseGetOpenOrdersStatusPageOrderLong
     */
    'status': MerchantApiResponseGetOpenOrdersStatusPageOrderLongStatusEnum;
    /**
     * 
     * @type {PageOrderLong}
     * @memberof MerchantApiResponseGetOpenOrdersStatusPageOrderLong
     */
    'data'?: PageOrderLong;
    /**
     * Error details if any
     * @type {string}
     * @memberof MerchantApiResponseGetOpenOrdersStatusPageOrderLong
     */
    'errorMessage'?: string;
}

export const MerchantApiResponseGetOpenOrdersStatusPageOrderLongStatusEnum = {
    Success: 'SUCCESS',
    BadRequest: 'BAD_REQUEST',
    Error: 'ERROR'
} as const;

export type MerchantApiResponseGetOpenOrdersStatusPageOrderLongStatusEnum = typeof MerchantApiResponseGetOpenOrdersStatusPageOrderLongStatusEnum[keyof typeof MerchantApiResponseGetOpenOrdersStatusPageOrderLongStatusEnum];

/**
 * 
 * @export
 * @interface MerchantApiResponseGetOrderStatusOrder
 */
export interface MerchantApiResponseGetOrderStatusOrder {
    /**
     * Status of request execution
     * @type {string}
     * @memberof MerchantApiResponseGetOrderStatusOrder
     */
    'status': MerchantApiResponseGetOrderStatusOrderStatusEnum;
    /**
     * 
     * @type {Order}
     * @memberof MerchantApiResponseGetOrderStatusOrder
     */
    'data'?: Order;
    /**
     * Error details if any
     * @type {string}
     * @memberof MerchantApiResponseGetOrderStatusOrder
     */
    'errorMessage'?: string;
}

export const MerchantApiResponseGetOrderStatusOrderStatusEnum = {
    Success: 'SUCCESS',
    Error: 'ERROR',
    NotFound: 'NOT_FOUND'
} as const;

export type MerchantApiResponseGetOrderStatusOrderStatusEnum = typeof MerchantApiResponseGetOrderStatusOrderStatusEnum[keyof typeof MerchantApiResponseGetOrderStatusOrderStatusEnum];

/**
 * 
 * @export
 * @interface MinLengthRuleRestDto
 */
export interface MinLengthRuleRestDto extends ValidationRuleRestDto {
    /**
     * 
     * @type {string}
     * @memberof MinLengthRuleRestDto
     */
    'type': MinLengthRuleRestDtoTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof MinLengthRuleRestDto
     */
    'value': number;
}

export const MinLengthRuleRestDtoTypeEnum = {
    Required: 'REQUIRED',
    MaxLength: 'MAX_LENGTH',
    MaxArraySize: 'MAX_ARRAY_SIZE',
    MinLength: 'MIN_LENGTH',
    RegexPattern: 'REGEX_PATTERN'
} as const;

export type MinLengthRuleRestDtoTypeEnum = typeof MinLengthRuleRestDtoTypeEnum[keyof typeof MinLengthRuleRestDtoTypeEnum];

/**
 * 
 * @export
 * @interface MoneyAmount
 */
export interface MoneyAmount {
    /**
     * 
     * @type {string}
     * @memberof MoneyAmount
     */
    'amount': string;
    /**
     * 
     * @type {string}
     * @memberof MoneyAmount
     */
    'currency': string;
}
/**
 * 
 * @export
 * @interface MoneyAmountLimitsInfoRestDto
 */
export interface MoneyAmountLimitsInfoRestDto {
    /**
     * 
     * @type {string}
     * @memberof MoneyAmountLimitsInfoRestDto
     */
    'currencyCode': string;
    /**
     * 
     * @type {string}
     * @memberof MoneyAmountLimitsInfoRestDto
     */
    'min': string;
    /**
     * 
     * @type {string}
     * @memberof MoneyAmountLimitsInfoRestDto
     */
    'max': string;
    /**
     * 
     * @type {boolean}
     * @memberof MoneyAmountLimitsInfoRestDto
     */
    'approximate': boolean;
}
/**
 * 
 * @export
 * @interface MoneyAmountLimitsRestDto
 */
export interface MoneyAmountLimitsRestDto {
    /**
     * 
     * @type {string}
     * @memberof MoneyAmountLimitsRestDto
     */
    'currencyCode': string;
    /**
     * 
     * @type {string}
     * @memberof MoneyAmountLimitsRestDto
     */
    'min': string;
    /**
     * 
     * @type {string}
     * @memberof MoneyAmountLimitsRestDto
     */
    'max'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MoneyAmountLimitsRestDto
     */
    'approximate': boolean;
}
/**
 * 
 * @export
 * @interface MoneyAmountRestDto
 */
export interface MoneyAmountRestDto {
    /**
     * 
     * @type {string}
     * @memberof MoneyAmountRestDto
     */
    'currencyCode': string;
    /**
     * 
     * @type {string}
     * @memberof MoneyAmountRestDto
     */
    'amount': string;
}
/**
 * 
 * @export
 * @interface NotificationMessageRestDto
 */
export interface NotificationMessageRestDto {
    /**
     * 
     * @type {string}
     * @memberof NotificationMessageRestDto
     */
    'localizedMessage': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationMessageRestDto
     */
    'locale': string;
}
/**
 * 
 * @export
 * @interface NotificationPageRestRequest
 */
export interface NotificationPageRestRequest {
    /**
     * 
     * @type {number}
     * @memberof NotificationPageRestRequest
     */
    'offset': number;
    /**
     * 
     * @type {number}
     * @memberof NotificationPageRestRequest
     */
    'limit': number;
}
/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface NotificationRestDto
 */
export interface NotificationRestDto {
    /**
     * 
     * @type {number}
     * @memberof NotificationRestDto
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof NotificationRestDto
     */
    'userId': number;
    /**
     * 
     * @type {number}
     * @memberof NotificationRestDto
     */
    'orderId'?: number;
    /**
     * 
     * @type {number}
     * @memberof NotificationRestDto
     */
    'offerId'?: number;
    /**
     * 
     * @type {string}
     * @memberof NotificationRestDto
     */
    'type': NotificationRestDtoTypeEnum;
    /**
     * 
     * @type {NotificationMessageRestDto}
     * @memberof NotificationRestDto
     */
    'message': NotificationMessageRestDto;
    /**
     * 
     * @type {string}
     * @memberof NotificationRestDto
     */
    'createdDateTime': string;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationRestDto
     */
    'sentToTelegram': boolean;
    /**
     * 
     * @type {ErrorResponseErrorRestDto}
     * @memberof NotificationRestDto
     */
    'sentToTelegramErrorResponse'?: ErrorResponseErrorRestDto;
}

export const NotificationRestDtoTypeEnum = {
    BuyerNewOrderRejected: 'BUYER_NEW_ORDER_REJECTED',
    SellerNewOrderCreated: 'SELLER_NEW_ORDER_CREATED',
    MakerNewOrderCreated: 'MAKER_NEW_ORDER_CREATED',
    TakerNewOrderCreated: 'TAKER_NEW_ORDER_CREATED',
    BuyerOrderAcceptedBySeller: 'BUYER_ORDER_ACCEPTED_BY_SELLER',
    TakerOrderAccepted: 'TAKER_ORDER_ACCEPTED',
    SellerOrderConfirmedSendingPayment: 'SELLER_ORDER_CONFIRMED_SENDING_PAYMENT',
    SellerOrderCancelledByAcceptanceTimeout: 'SELLER_ORDER_CANCELLED_BY_ACCEPTANCE_TIMEOUT',
    MakerOrderCancelledByAcceptanceTimeout: 'MAKER_ORDER_CANCELLED_BY_ACCEPTANCE_TIMEOUT',
    BuyerOrderCancellationReminderDueSendingPaymentByBuyer: 'BUYER_ORDER_CANCELLATION_REMINDER_DUE_SENDING_PAYMENT_BY_BUYER',
    SellerOrderCancellationReminderDueSendingPaymentByBuyer: 'SELLER_ORDER_CANCELLATION_REMINDER_DUE_SENDING_PAYMENT_BY_BUYER',
    SellerOrderCancelledBySendingPaymentTimeout: 'SELLER_ORDER_CANCELLED_BY_SENDING_PAYMENT_TIMEOUT',
    BuyerOrderCancelledBySendingPaymentTimeout: 'BUYER_ORDER_CANCELLED_BY_SENDING_PAYMENT_TIMEOUT',
    BuyerOrderConfirmedReceiptPayment: 'BUYER_ORDER_CONFIRMED_RECEIPT_PAYMENT',
    SellerOrderCancelled: 'SELLER_ORDER_CANCELLED',
    MakerOrderCancelledByTaker: 'MAKER_ORDER_CANCELLED_BY_TAKER',
    BuyerOrderCancelled: 'BUYER_ORDER_CANCELLED',
    TakerOrderCancelledByMaker: 'TAKER_ORDER_CANCELLED_BY_MAKER',
    ReceiverOrderChatMessageReceived: 'RECEIVER_ORDER_CHAT_MESSAGE_RECEIVED',
    ReceiverOrderChatAttachmentReceived: 'RECEIVER_ORDER_CHAT_ATTACHMENT_RECEIVED',
    ReceiverOrderAppealed: 'RECEIVER_ORDER_APPEALED',
    ReceiverOrderAppealResolved: 'RECEIVER_ORDER_APPEAL_RESOLVED',
    BuyerOrderCompleted: 'BUYER_ORDER_COMPLETED',
    SellerBiddingDisabled: 'SELLER_BIDDING_DISABLED',
    MakerBiddingDisabled: 'MAKER_BIDDING_DISABLED',
    MakerOfferDeactivated: 'MAKER_OFFER_DEACTIVATED'
} as const;

export type NotificationRestDtoTypeEnum = typeof NotificationRestDtoTypeEnum[keyof typeof NotificationRestDtoTypeEnum];

/**
 * Data corresponding to request
 * @export
 * @interface Offer
 */
export interface Offer {
    /**
     * Offer id
     * @type {number}
     * @memberof Offer
     */
    'id': number;
    /**
     * Offer display number
     * @type {string}
     * @memberof Offer
     */
    'number': string;
    /**
     * 
     * @type {MoneyAmount}
     * @memberof Offer
     */
    'initVolume': MoneyAmount;
    /**
     * 
     * @type {MoneyAmount}
     * @memberof Offer
     */
    'availableVolume': MoneyAmount;
    /**
     * 
     * @type {FixedPrice | FloatingPrice}
     * @memberof Offer
     */
    'price': FixedPrice | FloatingPrice;
    /**
     * Offer creation date and time
     * @type {string}
     * @memberof Offer
     */
    'createDateTime': string;
    /**
     * Optional commentary of the offer
     * @type {string}
     * @memberof Offer
     */
    'comment'?: string;
    /**
     * Type of the offer
     * @type {string}
     * @memberof Offer
     */
    'type': OfferTypeEnum;
    /**
     * 
     * @type {OrderAmountLimits}
     * @memberof Offer
     */
    'orderAmountLimits': OrderAmountLimits;
    /**
     * Actual status of the offer for the moment of the request
     * @type {string}
     * @memberof Offer
     */
    'status': OfferStatusEnum;
}

export const OfferTypeEnum = {
    Sale: 'SALE',
    Purchase: 'PURCHASE'
} as const;

export type OfferTypeEnum = typeof OfferTypeEnum[keyof typeof OfferTypeEnum];
export const OfferStatusEnum = {
    Inactive: 'INACTIVE',
    Active: 'ACTIVE',
    Killed: 'KILLED',
    Deleted: 'DELETED'
} as const;

export type OfferStatusEnum = typeof OfferStatusEnum[keyof typeof OfferStatusEnum];

/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface OfferFixedPriceLimitsRestDto
 */
export interface OfferFixedPriceLimitsRestDto {
    /**
     * 
     * @type {string}
     * @memberof OfferFixedPriceLimitsRestDto
     */
    'minPriceInclusive': string;
    /**
     * 
     * @type {string}
     * @memberof OfferFixedPriceLimitsRestDto
     */
    'maxPriceInclusive': string;
}
/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface OfferIdsExcludeFromDomListRestDto
 */
export interface OfferIdsExcludeFromDomListRestDto {
    /**
     * 
     * @type {Array<number>}
     * @memberof OfferIdsExcludeFromDomListRestDto
     */
    'items': Array<number>;
    /**
     * 
     * @type {string}
     * @memberof OfferIdsExcludeFromDomListRestDto
     */
    'createdDateTime': string;
}
/**
 * 
 * @export
 * @interface OfferSettingsRestDto
 */
export interface OfferSettingsRestDto {
    /**
     * 
     * @type {LimitsDuration}
     * @memberof OfferSettingsRestDto
     */
    'paymentConfirmTimeoutLimits': LimitsDuration;
    /**
     * 
     * @type {LimitsBigDecimal}
     * @memberof OfferSettingsRestDto
     */
    'floatingPriceLimits': LimitsBigDecimal;
    /**
     * 
     * @type {{ [key: string]: LimitsBigDecimal; }}
     * @memberof OfferSettingsRestDto
     */
    'offerVolumeLimitsByCurrencyCode': { [key: string]: LimitsBigDecimal; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof OfferSettingsRestDto
     */
    'minOrderAmountByCurrencyCode': { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof OfferSettingsRestDto
     */
    'maxPaymentDetailsQuantityInclusive': number;
    /**
     * 
     * @type {number}
     * @memberof OfferSettingsRestDto
     */
    'activeBuyOffersCountLimit': number;
    /**
     * 
     * @type {number}
     * @memberof OfferSettingsRestDto
     */
    'commentMaxLengthInclusive': number;
}
/**
 * 
 * @export
 * @interface OpenAppealRestRequest
 */
export interface OpenAppealRestRequest {
    /**
     * 
     * @type {number}
     * @memberof OpenAppealRestRequest
     */
    'orderId': number;
}
/**
 * 
 * @export
 * @interface OpenChatInternalRestRequest
 */
export interface OpenChatInternalRestRequest {
    /**
     * 
     * @type {number}
     * @memberof OpenChatInternalRestRequest
     */
    'orderId': number;
    /**
     * 
     * @type {number}
     * @memberof OpenChatInternalRestRequest
     */
    'userId': number;
}
/**
 * 
 * @export
 * @interface OpenChatPublicRestRequest
 */
export interface OpenChatPublicRestRequest {
    /**
     * 
     * @type {number}
     * @memberof OpenChatPublicRestRequest
     */
    'orderId': number;
}
/**
 * Data corresponding to request
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'number': string;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'offerId': number;
    /**
     * 
     * @type {User}
     * @memberof Order
     */
    'taker': User;
    /**
     * 
     * @type {FixedPrice}
     * @memberof Order
     */
    'price': FixedPrice;
    /**
     * 
     * @type {PaymentDetails}
     * @memberof Order
     */
    'paymentDetails': PaymentDetails;
    /**
     * 
     * @type {MoneyAmount}
     * @memberof Order
     */
    'volume': MoneyAmount;
    /**
     * 
     * @type {MoneyAmount}
     * @memberof Order
     */
    'amount': MoneyAmount;
    /**
     * 
     * @type {MoneyAmount}
     * @memberof Order
     */
    'fee': MoneyAmount;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'status': OrderStatusEnum;
    /**
     * 
     * @type {CancellationDetails}
     * @memberof Order
     */
    'cancellationDetails'?: CancellationDetails;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'startedDateTime': string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'completedDateTime'?: string;
}

export const OrderStatusEnum = {
    New: 'NEW',
    Accepted: 'ACCEPTED',
    ConfirmedSendingPaymentByBuyer: 'CONFIRMED_SENDING_PAYMENT_BY_BUYER',
    ConfirmedReceiptPaymentBySeller: 'CONFIRMED_RECEIPT_PAYMENT_BY_SELLER',
    OnAppeal: 'ON_APPEAL',
    Completed: 'COMPLETED',
    Cancelled: 'CANCELLED'
} as const;

export type OrderStatusEnum = typeof OrderStatusEnum[keyof typeof OrderStatusEnum];

/**
 * Limits for orders of the offer
 * @export
 * @interface OrderAmountLimits
 */
export interface OrderAmountLimits {
    /**
     * 
     * @type {string}
     * @memberof OrderAmountLimits
     */
    'min'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderAmountLimits
     */
    'max'?: string;
    /**
     * Order currency
     * @type {string}
     * @memberof OrderAmountLimits
     */
    'currency': string;
}
/**
 * 
 * @export
 * @interface OrderAmountLimitsRestRequest
 */
export interface OrderAmountLimitsRestRequest {
    /**
     * 
     * @type {string}
     * @memberof OrderAmountLimitsRestRequest
     */
    'min': string;
    /**
     * 
     * @type {string}
     * @memberof OrderAmountLimitsRestRequest
     */
    'max'?: string;
}
/**
 * 
 * @export
 * @interface OrderConfirmRestRequest
 */
export interface OrderConfirmRestRequest {
    /**
     * 
     * @type {number}
     * @memberof OrderConfirmRestRequest
     */
    'orderId': number;
    /**
     * 
     * @type {string}
     * @memberof OrderConfirmRestRequest
     */
    'type': OrderConfirmRestRequestTypeEnum;
}

export const OrderConfirmRestRequestTypeEnum = {
    Sale: 'SALE',
    Purchase: 'PURCHASE'
} as const;

export type OrderConfirmRestRequestTypeEnum = typeof OrderConfirmRestRequestTypeEnum[keyof typeof OrderConfirmRestRequestTypeEnum];

/**
 * 
 * @export
 * @interface OrderIdRestRequest
 */
export interface OrderIdRestRequest {
    /**
     * 
     * @type {number}
     * @memberof OrderIdRestRequest
     */
    'orderId': number;
}
/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface OrderInfoRestDto
 */
export interface OrderInfoRestDto {
    /**
     * 
     * @type {number}
     * @memberof OrderInfoRestDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof OrderInfoRestDto
     */
    'number': string;
    /**
     * 
     * @type {number}
     * @memberof OrderInfoRestDto
     */
    'sellerUserId': number;
    /**
     * 
     * @type {number}
     * @memberof OrderInfoRestDto
     */
    'buyerUserId': number;
    /**
     * 
     * @type {number}
     * @memberof OrderInfoRestDto
     */
    'offerId': number;
    /**
     * 
     * @type {string}
     * @memberof OrderInfoRestDto
     */
    'offerType': OrderInfoRestDtoOfferTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OrderInfoRestDto
     */
    'offerComment'?: string;
    /**
     * 
     * @type {PriceRestDto}
     * @memberof OrderInfoRestDto
     */
    'price': PriceRestDto;
    /**
     * 
     * @type {number}
     * @memberof OrderInfoRestDto
     */
    'paymentDetailsId': number;
    /**
     * 
     * @type {MoneyAmountRestDto}
     * @memberof OrderInfoRestDto
     */
    'volume': MoneyAmountRestDto;
    /**
     * 
     * @type {MoneyAmountRestDto}
     * @memberof OrderInfoRestDto
     */
    'amount': MoneyAmountRestDto;
    /**
     * 
     * @type {MoneyAmountRestDto}
     * @memberof OrderInfoRestDto
     */
    'feeVolume': MoneyAmountRestDto;
    /**
     * 
     * @type {string}
     * @memberof OrderInfoRestDto
     */
    'paymentConfirmTimeout': string;
    /**
     * 
     * @type {string}
     * @memberof OrderInfoRestDto
     */
    'createDateTime': string;
    /**
     * 
     * @type {string}
     * @memberof OrderInfoRestDto
     */
    'confirmationDateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderInfoRestDto
     */
    'acceptDateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderInfoRestDto
     */
    'status': OrderInfoRestDtoStatusEnum;
    /**
     * 
     * @type {ChangeLogInfoRestDtoOrderStatus}
     * @memberof OrderInfoRestDto
     */
    'changeLog': ChangeLogInfoRestDtoOrderStatus;
    /**
     * 
     * @type {OrderPaymentDetailsInfoRestDto}
     * @memberof OrderInfoRestDto
     */
    'paymentDetails': OrderPaymentDetailsInfoRestDto;
    /**
     * 
     * @type {Array<AppealRestDto>}
     * @memberof OrderInfoRestDto
     */
    'appeals': Array<AppealRestDto>;
    /**
     * 
     * @type {Array<ChatMessageRestDto>}
     * @memberof OrderInfoRestDto
     */
    'chatHistory': Array<ChatMessageRestDto>;
}

export const OrderInfoRestDtoOfferTypeEnum = {
    Sale: 'SALE',
    Purchase: 'PURCHASE'
} as const;

export type OrderInfoRestDtoOfferTypeEnum = typeof OrderInfoRestDtoOfferTypeEnum[keyof typeof OrderInfoRestDtoOfferTypeEnum];
export const OrderInfoRestDtoStatusEnum = {
    Draft: 'DRAFT',
    ConfirmingOrder: 'CONFIRMING_ORDER',
    New: 'NEW',
    Rejected: 'REJECTED',
    AcceptingOrder: 'ACCEPTING_ORDER',
    AcceptedOrder: 'ACCEPTED_ORDER',
    ConfirmedSendingPaymentByBuyer: 'CONFIRMED_SENDING_PAYMENT_BY_BUYER',
    TimeoutExpiredSendingPaymentByBuyer: 'TIMEOUT_EXPIRED_SENDING_PAYMENT_BY_BUYER',
    ConfirmedReceiptPaymentBySeller: 'CONFIRMED_RECEIPT_PAYMENT_BY_SELLER',
    OnAppeal: 'ON_APPEAL',
    AppealResolved: 'APPEAL_RESOLVED',
    Completed: 'COMPLETED',
    Cancelling: 'CANCELLING',
    Cancelled: 'CANCELLED'
} as const;

export type OrderInfoRestDtoStatusEnum = typeof OrderInfoRestDtoStatusEnum[keyof typeof OrderInfoRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface OrderPaymentDetailsInfoRestDto
 */
export interface OrderPaymentDetailsInfoRestDto {
    /**
     * 
     * @type {number}
     * @memberof OrderPaymentDetailsInfoRestDto
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof OrderPaymentDetailsInfoRestDto
     */
    'userId': number;
    /**
     * 
     * @type {OrderPaymentMethodInfoRestDto}
     * @memberof OrderPaymentDetailsInfoRestDto
     */
    'paymentMethod': OrderPaymentMethodInfoRestDto;
    /**
     * 
     * @type {string}
     * @memberof OrderPaymentDetailsInfoRestDto
     */
    'currency': string;
    /**
     * 
     * @type {string}
     * @memberof OrderPaymentDetailsInfoRestDto
     */
    'recipientNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderPaymentDetailsInfoRestDto
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface OrderPaymentMethodInfoRestDto
 */
export interface OrderPaymentMethodInfoRestDto {
    /**
     * 
     * @type {string}
     * @memberof OrderPaymentMethodInfoRestDto
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof OrderPaymentMethodInfoRestDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OrderPaymentMethodInfoRestDto
     */
    'originNameLocale': string;
    /**
     * 
     * @type {string}
     * @memberof OrderPaymentMethodInfoRestDto
     */
    'nameEng': string;
}
/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface OrderRestDto
 */
export interface OrderRestDto {
    /**
     * 
     * @type {number}
     * @memberof OrderRestDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof OrderRestDto
     */
    'number': string;
    /**
     * 
     * @type {UserRestDto}
     * @memberof OrderRestDto
     */
    'seller'?: UserRestDto;
    /**
     * 
     * @type {UserRestDto}
     * @memberof OrderRestDto
     */
    'buyer'?: UserRestDto;
    /**
     * 
     * @type {number}
     * @memberof OrderRestDto
     */
    'offerId': number;
    /**
     * 
     * @type {string}
     * @memberof OrderRestDto
     */
    'offerType': OrderRestDtoOfferTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OrderRestDto
     */
    'offerComment'?: string;
    /**
     * 
     * @type {PriceRestDto}
     * @memberof OrderRestDto
     */
    'price': PriceRestDto;
    /**
     * 
     * @type {PaymentDetailsRestDto}
     * @memberof OrderRestDto
     */
    'paymentDetails': PaymentDetailsRestDto;
    /**
     * 
     * @type {MoneyAmountRestDto}
     * @memberof OrderRestDto
     */
    'volume': MoneyAmountRestDto;
    /**
     * 
     * @type {MoneyAmountRestDto}
     * @memberof OrderRestDto
     */
    'amount': MoneyAmountRestDto;
    /**
     * 
     * @type {MoneyAmountRestDto}
     * @memberof OrderRestDto
     */
    'feeVolume': MoneyAmountRestDto;
    /**
     * 
     * @type {string}
     * @memberof OrderRestDto
     */
    'paymentConfirmTimeout': string;
    /**
     * 
     * @type {string}
     * @memberof OrderRestDto
     */
    'createDateTime': string;
    /**
     * 
     * @type {string}
     * @memberof OrderRestDto
     */
    'confirmationDateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderRestDto
     */
    'acceptDateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderRestDto
     */
    'statusUpdateDateTime': string;
    /**
     * 
     * @type {string}
     * @memberof OrderRestDto
     */
    'rejectReason'?: OrderRestDtoRejectReasonEnum;
    /**
     * 
     * @type {string}
     * @memberof OrderRestDto
     */
    'cancelReason'?: OrderRestDtoCancelReasonEnum;
    /**
     * 
     * @type {string}
     * @memberof OrderRestDto
     */
    'status': OrderRestDtoStatusEnum;
    /**
     * 
     * @type {ChangeLogRestDtoOrderStatus}
     * @memberof OrderRestDto
     */
    'changeLog': ChangeLogRestDtoOrderStatus;
}

export const OrderRestDtoOfferTypeEnum = {
    Sale: 'SALE',
    Purchase: 'PURCHASE'
} as const;

export type OrderRestDtoOfferTypeEnum = typeof OrderRestDtoOfferTypeEnum[keyof typeof OrderRestDtoOfferTypeEnum];
export const OrderRestDtoRejectReasonEnum = {
    ConfirmingOrderTimeoutExceeded: 'CONFIRMING_ORDER_TIMEOUT_EXCEEDED',
    UserHasNoMoney: 'USER_HAS_NO_MONEY',
    OfferDeactivated: 'OFFER_DEACTIVATED'
} as const;

export type OrderRestDtoRejectReasonEnum = typeof OrderRestDtoRejectReasonEnum[keyof typeof OrderRestDtoRejectReasonEnum];
export const OrderRestDtoCancelReasonEnum = {
    CancelledOnAcceptingStageBySeller: 'CANCELLED_ON_ACCEPTING_STAGE_BY_SELLER',
    CancelledOnAcceptingStageByBuyer: 'CANCELLED_ON_ACCEPTING_STAGE_BY_BUYER',
    CancelledOnSendingPaymentStageByBuyer: 'CANCELLED_ON_SENDING_PAYMENT_STAGE_BY_BUYER',
    CancelledOnConfirmingReceiptPaymentStageByBuyer: 'CANCELLED_ON_CONFIRMING_RECEIPT_PAYMENT_STAGE_BY_BUYER',
    AcceptingTimeoutExceeded: 'ACCEPTING_TIMEOUT_EXCEEDED',
    SendingPaymentByBuyerTimeoutExceeded: 'SENDING_PAYMENT_BY_BUYER_TIMEOUT_EXCEEDED',
    OfferDeactivated: 'OFFER_DEACTIVATED',
    CancelledOnCancellingExpressRequestStage: 'CANCELLED_ON_CANCELLING_EXPRESS_REQUEST_STAGE',
    NotEnoughVolume: 'NOT_ENOUGH_VOLUME'
} as const;

export type OrderRestDtoCancelReasonEnum = typeof OrderRestDtoCancelReasonEnum[keyof typeof OrderRestDtoCancelReasonEnum];
export const OrderRestDtoStatusEnum = {
    Draft: 'DRAFT',
    ConfirmingOrder: 'CONFIRMING_ORDER',
    New: 'NEW',
    Rejected: 'REJECTED',
    AcceptingOrder: 'ACCEPTING_ORDER',
    AcceptedOrder: 'ACCEPTED_ORDER',
    ConfirmedSendingPaymentByBuyer: 'CONFIRMED_SENDING_PAYMENT_BY_BUYER',
    TimeoutExpiredSendingPaymentByBuyer: 'TIMEOUT_EXPIRED_SENDING_PAYMENT_BY_BUYER',
    ConfirmedReceiptPaymentBySeller: 'CONFIRMED_RECEIPT_PAYMENT_BY_SELLER',
    OnAppeal: 'ON_APPEAL',
    AppealResolved: 'APPEAL_RESOLVED',
    Completed: 'COMPLETED',
    Cancelling: 'CANCELLING',
    Cancelled: 'CANCELLED'
} as const;

export type OrderRestDtoStatusEnum = typeof OrderRestDtoStatusEnum[keyof typeof OrderRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface OrderSettingsRestDto
 */
export interface OrderSettingsRestDto {
    /**
     * 
     * @type {string}
     * @memberof OrderSettingsRestDto
     */
    'orderAcceptanceTimeout': string;
    /**
     * 
     * @type {string}
     * @memberof OrderSettingsRestDto
     */
    'orderConfirmationTimeout': string;
    /**
     * 
     * @type {string}
     * @memberof OrderSettingsRestDto
     */
    'buyerSendingPaymentConfirmationTimeout': string;
}
/**
 * Data corresponding to request
 * @export
 * @interface PageOfferLong
 */
export interface PageOfferLong {
    /**
     * 
     * @type {Array<Offer>}
     * @memberof PageOfferLong
     */
    'items': Array<Offer>;
    /**
     * 
     * @type {number}
     * @memberof PageOfferLong
     */
    'offset': number;
    /**
     * 
     * @type {number}
     * @memberof PageOfferLong
     */
    'pageLimit': number;
}
/**
 * Data corresponding to request
 * @export
 * @interface PageOrderLong
 */
export interface PageOrderLong {
    /**
     * 
     * @type {Array<Order>}
     * @memberof PageOrderLong
     */
    'items': Array<Order>;
    /**
     * 
     * @type {number}
     * @memberof PageOrderLong
     */
    'offset': number;
    /**
     * 
     * @type {number}
     * @memberof PageOrderLong
     */
    'pageLimit': number;
}
/**
 * 
 * @export
 * @interface PaymentDetails
 */
export interface PaymentDetails {
    /**
     * 
     * @type {PaymentMethod}
     * @memberof PaymentDetails
     */
    'paymentMethod': PaymentMethod;
    /**
     * 
     * @type {string}
     * @memberof PaymentDetails
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentDetails
     */
    'currency': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentDetails
     */
    'recipientNumber': string;
}
/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface PaymentDetailsBlacklistInfoRestDto
 */
export interface PaymentDetailsBlacklistInfoRestDto {
    /**
     * 
     * @type {number}
     * @memberof PaymentDetailsBlacklistInfoRestDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof PaymentDetailsBlacklistInfoRestDto
     */
    'paymentDetailsNumber': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentDetailsBlacklistInfoRestDto
     */
    'comment'?: string;
    /**
     * 
     * @type {number}
     * @memberof PaymentDetailsBlacklistInfoRestDto
     */
    'staffId'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaymentDetailsBlacklistInfoRestDto
     */
    'creationType': PaymentDetailsBlacklistInfoRestDtoCreationTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PaymentDetailsBlacklistInfoRestDto
     */
    'createdDateTime': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof PaymentDetailsBlacklistInfoRestDto
     */
    'userIds': Array<number>;
}

export const PaymentDetailsBlacklistInfoRestDtoCreationTypeEnum = {
    Manual: 'MANUAL',
    Auto: 'AUTO'
} as const;

export type PaymentDetailsBlacklistInfoRestDtoCreationTypeEnum = typeof PaymentDetailsBlacklistInfoRestDtoCreationTypeEnum[keyof typeof PaymentDetailsBlacklistInfoRestDtoCreationTypeEnum];

/**
 * 
 * @export
 * @interface PaymentDetailsInfoRestDto
 */
export interface PaymentDetailsInfoRestDto {
    /**
     * 
     * @type {number}
     * @memberof PaymentDetailsInfoRestDto
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof PaymentDetailsInfoRestDto
     */
    'userId': number;
    /**
     * 
     * @type {PaymentMethodInfoRestDto}
     * @memberof PaymentDetailsInfoRestDto
     */
    'paymentMethod': PaymentMethodInfoRestDto;
    /**
     * 
     * @type {string}
     * @memberof PaymentDetailsInfoRestDto
     */
    'currency': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentDetailsInfoRestDto
     */
    'recipientNumber': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentDetailsInfoRestDto
     */
    'name'?: string;
}
/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface PaymentDetailsRestDto
 */
export interface PaymentDetailsRestDto {
    /**
     * 
     * @type {number}
     * @memberof PaymentDetailsRestDto
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof PaymentDetailsRestDto
     */
    'userId': number;
    /**
     * 
     * @type {PaymentMethodRestDto}
     * @memberof PaymentDetailsRestDto
     */
    'paymentMethod': PaymentMethodRestDto;
    /**
     * 
     * @type {string}
     * @memberof PaymentDetailsRestDto
     */
    'currency': string;
    /**
     * 
     * @type {AttributesRestDto}
     * @memberof PaymentDetailsRestDto
     */
    'attributes': AttributesRestDto;
    /**
     * 
     * @type {string}
     * @memberof PaymentDetailsRestDto
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface PaymentMethod
 */
export interface PaymentMethod {
    /**
     * 
     * @type {string}
     * @memberof PaymentMethod
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethod
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface PaymentMethodInActiveOffersRestDto
 */
export interface PaymentMethodInActiveOffersRestDto {
    /**
     * 
     * @type {PaymentMethodRestDto}
     * @memberof PaymentMethodInActiveOffersRestDto
     */
    'paymentMethod': PaymentMethodRestDto;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInActiveOffersRestDto
     */
    'amount': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInActiveOffersRestDto
     */
    'volume': string;
}
/**
 * 
 * @export
 * @interface PaymentMethodInfoRestDto
 */
export interface PaymentMethodInfoRestDto {
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInfoRestDto
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInfoRestDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInfoRestDto
     */
    'originNameLocale': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInfoRestDto
     */
    'nameEng': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PaymentMethodInfoRestDto
     */
    'supportedCurrencies': Array<string>;
}
/**
 * 
 * @export
 * @interface PaymentMethodRestDto
 */
export interface PaymentMethodRestDto {
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodRestDto
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodRestDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodRestDto
     */
    'originNameLocale': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodRestDto
     */
    'nameEng': string;
    /**
     * 
     * @type {Array<PaymentMethodRestDto>}
     * @memberof PaymentMethodRestDto
     */
    'banks'?: Array<PaymentMethodRestDto>;
}
/**
 * 
 * @export
 * @interface Photo
 */
export interface Photo {
    /**
     * 
     * @type {string}
     * @memberof Photo
     */
    'fileId': string;
    /**
     * 
     * @type {number}
     * @memberof Photo
     */
    'fileSize': number;
}
/**
 * Price of the offer
 * @export
 * @interface Price
 */
export interface Price {
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    'baseCurrency': string;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    'quoteCurrency': string;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface PriceRestDto
 */
export interface PriceRestDto {
    /**
     * 
     * @type {string}
     * @memberof PriceRestDto
     */
    'type': PriceRestDtoTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PriceRestDto
     */
    'baseCurrencyCode': string;
    /**
     * 
     * @type {string}
     * @memberof PriceRestDto
     */
    'quoteCurrencyCode': string;
    /**
     * 
     * @type {string}
     * @memberof PriceRestDto
     */
    'value': string;
}

export const PriceRestDtoTypeEnum = {
    Fixed: 'FIXED',
    Floating: 'FLOATING'
} as const;

export type PriceRestDtoTypeEnum = typeof PriceRestDtoTypeEnum[keyof typeof PriceRestDtoTypeEnum];

/**
 * 
 * @export
 * @interface PriceWithEstimationRestDto
 */
export interface PriceWithEstimationRestDto {
    /**
     * 
     * @type {string}
     * @memberof PriceWithEstimationRestDto
     */
    'type': PriceWithEstimationRestDtoTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PriceWithEstimationRestDto
     */
    'baseCurrencyCode': string;
    /**
     * 
     * @type {string}
     * @memberof PriceWithEstimationRestDto
     */
    'quoteCurrencyCode': string;
    /**
     * 
     * @type {string}
     * @memberof PriceWithEstimationRestDto
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof PriceWithEstimationRestDto
     */
    'estimated'?: string;
}

export const PriceWithEstimationRestDtoTypeEnum = {
    Fixed: 'FIXED',
    Floating: 'FLOATING'
} as const;

export type PriceWithEstimationRestDtoTypeEnum = typeof PriceWithEstimationRestDtoTypeEnum[keyof typeof PriceWithEstimationRestDtoTypeEnum];

/**
 * 
 * @export
 * @interface RegexPatternRestDto
 */
export interface RegexPatternRestDto extends ValidationRuleRestDto {
    /**
     * 
     * @type {string}
     * @memberof RegexPatternRestDto
     */
    'type': RegexPatternRestDtoTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof RegexPatternRestDto
     */
    'value': string;
}

export const RegexPatternRestDtoTypeEnum = {
    Required: 'REQUIRED',
    MaxLength: 'MAX_LENGTH',
    MaxArraySize: 'MAX_ARRAY_SIZE',
    MinLength: 'MIN_LENGTH',
    RegexPattern: 'REGEX_PATTERN'
} as const;

export type RegexPatternRestDtoTypeEnum = typeof RegexPatternRestDtoTypeEnum[keyof typeof RegexPatternRestDtoTypeEnum];

/**
 * 
 * @export
 * @interface RegexPatternRestDtoAllOf
 */
export interface RegexPatternRestDtoAllOf {
    /**
     * 
     * @type {string}
     * @memberof RegexPatternRestDtoAllOf
     */
    'type'?: RegexPatternRestDtoAllOfTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof RegexPatternRestDtoAllOf
     */
    'value'?: string;
}

export const RegexPatternRestDtoAllOfTypeEnum = {
    Required: 'REQUIRED',
    MaxLength: 'MAX_LENGTH',
    MaxArraySize: 'MAX_ARRAY_SIZE',
    MinLength: 'MIN_LENGTH',
    RegexPattern: 'REGEX_PATTERN'
} as const;

export type RegexPatternRestDtoAllOfTypeEnum = typeof RegexPatternRestDtoAllOfTypeEnum[keyof typeof RegexPatternRestDtoAllOfTypeEnum];

/**
 * 
 * @export
 * @interface RequiredRuleRestDto
 */
export interface RequiredRuleRestDto extends ValidationRuleRestDto {
    /**
     * 
     * @type {string}
     * @memberof RequiredRuleRestDto
     */
    'type': RequiredRuleRestDtoTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof RequiredRuleRestDto
     */
    'value': boolean;
}

export const RequiredRuleRestDtoTypeEnum = {
    Required: 'REQUIRED',
    MaxLength: 'MAX_LENGTH',
    MaxArraySize: 'MAX_ARRAY_SIZE',
    MinLength: 'MIN_LENGTH',
    RegexPattern: 'REGEX_PATTERN'
} as const;

export type RequiredRuleRestDtoTypeEnum = typeof RequiredRuleRestDtoTypeEnum[keyof typeof RequiredRuleRestDtoTypeEnum];

/**
 * 
 * @export
 * @interface RequiredRuleRestDtoAllOf
 */
export interface RequiredRuleRestDtoAllOf {
    /**
     * 
     * @type {string}
     * @memberof RequiredRuleRestDtoAllOf
     */
    'type'?: RequiredRuleRestDtoAllOfTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof RequiredRuleRestDtoAllOf
     */
    'value'?: boolean;
}

export const RequiredRuleRestDtoAllOfTypeEnum = {
    Required: 'REQUIRED',
    MaxLength: 'MAX_LENGTH',
    MaxArraySize: 'MAX_ARRAY_SIZE',
    MinLength: 'MIN_LENGTH',
    RegexPattern: 'REGEX_PATTERN'
} as const;

export type RequiredRuleRestDtoAllOfTypeEnum = typeof RequiredRuleRestDtoAllOfTypeEnum[keyof typeof RequiredRuleRestDtoAllOfTypeEnum];

/**
 * 
 * @export
 * @interface ResolveAppealRestRequest
 */
export interface ResolveAppealRestRequest {
    /**
     * 
     * @type {number}
     * @memberof ResolveAppealRestRequest
     */
    'orderId': number;
    /**
     * 
     * @type {string}
     * @memberof ResolveAppealRestRequest
     */
    'resolutionType': ResolveAppealRestRequestResolutionTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof ResolveAppealRestRequest
     */
    'resolvedByStaffId': number;
    /**
     * 
     * @type {string}
     * @memberof ResolveAppealRestRequest
     */
    'comment'?: string;
}

export const ResolveAppealRestRequestResolutionTypeEnum = {
    NoChanges: 'NO_CHANGES',
    GoToNextStatus: 'GO_TO_NEXT_STATUS',
    CancelOrder: 'CANCEL_ORDER',
    RefundClosedOrder: 'REFUND_CLOSED_ORDER'
} as const;

export type ResolveAppealRestRequestResolutionTypeEnum = typeof ResolveAppealRestRequestResolutionTypeEnum[keyof typeof ResolveAppealRestRequestResolutionTypeEnum];

/**
 * 
 * @export
 * @interface ResolveAppealViaScriptRestRequest
 */
export interface ResolveAppealViaScriptRestRequest {
    /**
     * 
     * @type {number}
     * @memberof ResolveAppealViaScriptRestRequest
     */
    'orderId': number;
    /**
     * 
     * @type {number}
     * @memberof ResolveAppealViaScriptRestRequest
     */
    'staffId': number;
    /**
     * 
     * @type {string}
     * @memberof ResolveAppealViaScriptRestRequest
     */
    'resolutionType': ResolveAppealViaScriptRestRequestResolutionTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ResolveAppealViaScriptRestRequest
     */
    'comment'?: string;
}

export const ResolveAppealViaScriptRestRequestResolutionTypeEnum = {
    NoChanges: 'NO_CHANGES',
    GoToNextStatus: 'GO_TO_NEXT_STATUS',
    CancelOrder: 'CANCEL_ORDER',
    RefundClosedOrder: 'REFUND_CLOSED_ORDER'
} as const;

export type ResolveAppealViaScriptRestRequestResolutionTypeEnum = typeof ResolveAppealViaScriptRestRequestResolutionTypeEnum[keyof typeof ResolveAppealViaScriptRestRequestResolutionTypeEnum];

/**
 * 
 * @export
 * @interface RestDataResponseBiddingSettingsResponseStatusBiddingSettingsDto
 */
export interface RestDataResponseBiddingSettingsResponseStatusBiddingSettingsDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseBiddingSettingsResponseStatusBiddingSettingsDto
     */
    'status': RestDataResponseBiddingSettingsResponseStatusBiddingSettingsDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseBiddingSettingsResponseStatusBiddingSettingsDto
     */
    'message'?: string;
    /**
     * 
     * @type {BiddingSettingsDto}
     * @memberof RestDataResponseBiddingSettingsResponseStatusBiddingSettingsDto
     */
    'data'?: BiddingSettingsDto;
}

export const RestDataResponseBiddingSettingsResponseStatusBiddingSettingsDtoStatusEnum = {
    Success: 'SUCCESS',
    AccessDenied: 'ACCESS_DENIED'
} as const;

export type RestDataResponseBiddingSettingsResponseStatusBiddingSettingsDtoStatusEnum = typeof RestDataResponseBiddingSettingsResponseStatusBiddingSettingsDtoStatusEnum[keyof typeof RestDataResponseBiddingSettingsResponseStatusBiddingSettingsDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseCreateExpressRequestStatusExpressRequestRestDto
 */
export interface RestDataResponseCreateExpressRequestStatusExpressRequestRestDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseCreateExpressRequestStatusExpressRequestRestDto
     */
    'status': RestDataResponseCreateExpressRequestStatusExpressRequestRestDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseCreateExpressRequestStatusExpressRequestRestDto
     */
    'message'?: string;
    /**
     * 
     * @type {ExpressRequestRestDto}
     * @memberof RestDataResponseCreateExpressRequestStatusExpressRequestRestDto
     */
    'data'?: ExpressRequestRestDto;
}

export const RestDataResponseCreateExpressRequestStatusExpressRequestRestDtoStatusEnum = {
    Success: 'SUCCESS',
    AccessDenied: 'ACCESS_DENIED',
    UserAlreadyHasActiveRequest: 'USER_ALREADY_HAS_ACTIVE_REQUEST',
    UnsupportedBaseCurrency: 'UNSUPPORTED_BASE_CURRENCY',
    UnsupportedQuoteCurrency: 'UNSUPPORTED_QUOTE_CURRENCY'
} as const;

export type RestDataResponseCreateExpressRequestStatusExpressRequestRestDtoStatusEnum = typeof RestDataResponseCreateExpressRequestStatusExpressRequestRestDtoStatusEnum[keyof typeof RestDataResponseCreateExpressRequestStatusExpressRequestRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseCreateOrderRestStatusOrderRestDto
 */
export interface RestDataResponseCreateOrderRestStatusOrderRestDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseCreateOrderRestStatusOrderRestDto
     */
    'status': RestDataResponseCreateOrderRestStatusOrderRestDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseCreateOrderRestStatusOrderRestDto
     */
    'message'?: string;
    /**
     * 
     * @type {OrderRestDto}
     * @memberof RestDataResponseCreateOrderRestStatusOrderRestDto
     */
    'data'?: OrderRestDto;
}

export const RestDataResponseCreateOrderRestStatusOrderRestDtoStatusEnum = {
    Success: 'SUCCESS',
    WrongPaymentDetails: 'WRONG_PAYMENT_DETAILS',
    AmountIsOutOfLimits: 'AMOUNT_IS_OUT_OF_LIMITS',
    OfferIllegalState: 'OFFER_ILLEGAL_STATE',
    VolumeIsNotAvailable: 'VOLUME_IS_NOT_AVAILABLE',
    UnsupportedCurrency: 'UNSUPPORTED_CURRENCY',
    AccessDeniedForBuyer: 'ACCESS_DENIED_FOR_BUYER',
    AccessDeniedForSeller: 'ACCESS_DENIED_FOR_SELLER',
    ExchangeRateIsNotAvailable: 'EXCHANGE_RATE_IS_NOT_AVAILABLE',
    BiddingIsDisabled: 'BIDDING_IS_DISABLED',
    UserIsOfferOwner: 'USER_IS_OFFER_OWNER'
} as const;

export type RestDataResponseCreateOrderRestStatusOrderRestDtoStatusEnum = typeof RestDataResponseCreateOrderRestStatusOrderRestDtoStatusEnum[keyof typeof RestDataResponseCreateOrderRestStatusOrderRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseCreatePaymentDetailsBlacklistRestStatusPaymentDetailsBlacklistInfoRestDto
 */
export interface RestDataResponseCreatePaymentDetailsBlacklistRestStatusPaymentDetailsBlacklistInfoRestDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseCreatePaymentDetailsBlacklistRestStatusPaymentDetailsBlacklistInfoRestDto
     */
    'status': RestDataResponseCreatePaymentDetailsBlacklistRestStatusPaymentDetailsBlacklistInfoRestDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseCreatePaymentDetailsBlacklistRestStatusPaymentDetailsBlacklistInfoRestDto
     */
    'message'?: string;
    /**
     * 
     * @type {PaymentDetailsBlacklistInfoRestDto}
     * @memberof RestDataResponseCreatePaymentDetailsBlacklistRestStatusPaymentDetailsBlacklistInfoRestDto
     */
    'data'?: PaymentDetailsBlacklistInfoRestDto;
}

export const RestDataResponseCreatePaymentDetailsBlacklistRestStatusPaymentDetailsBlacklistInfoRestDtoStatusEnum = {
    Success: 'SUCCESS'
} as const;

export type RestDataResponseCreatePaymentDetailsBlacklistRestStatusPaymentDetailsBlacklistInfoRestDtoStatusEnum = typeof RestDataResponseCreatePaymentDetailsBlacklistRestStatusPaymentDetailsBlacklistInfoRestDtoStatusEnum[keyof typeof RestDataResponseCreatePaymentDetailsBlacklistRestStatusPaymentDetailsBlacklistInfoRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseCreatePaymentDetailsStatusPaymentDetailsRestDto
 */
export interface RestDataResponseCreatePaymentDetailsStatusPaymentDetailsRestDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseCreatePaymentDetailsStatusPaymentDetailsRestDto
     */
    'status': RestDataResponseCreatePaymentDetailsStatusPaymentDetailsRestDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseCreatePaymentDetailsStatusPaymentDetailsRestDto
     */
    'message'?: string;
    /**
     * 
     * @type {PaymentDetailsRestDto}
     * @memberof RestDataResponseCreatePaymentDetailsStatusPaymentDetailsRestDto
     */
    'data'?: PaymentDetailsRestDto;
}

export const RestDataResponseCreatePaymentDetailsStatusPaymentDetailsRestDtoStatusEnum = {
    Success: 'SUCCESS',
    AccessDenied: 'ACCESS_DENIED',
    CurrencyNotFound: 'CURRENCY_NOT_FOUND',
    CurrencyIsNotSupportedByPaymentMethod: 'CURRENCY_IS_NOT_SUPPORTED_BY_PAYMENT_METHOD',
    PaymentDetailsNameIsTooLong: 'PAYMENT_DETAILS_NAME_IS_TOO_LONG',
    PaymentMethodNotFound: 'PAYMENT_METHOD_NOT_FOUND',
    SelectedCurrencyIsNotFiat: 'SELECTED_CURRENCY_IS_NOT_FIAT',
    InvalidPaymentDetailsAttributes: 'INVALID_PAYMENT_DETAILS_ATTRIBUTES'
} as const;

export type RestDataResponseCreatePaymentDetailsStatusPaymentDetailsRestDtoStatusEnum = typeof RestDataResponseCreatePaymentDetailsStatusPaymentDetailsRestDtoStatusEnum[keyof typeof RestDataResponseCreatePaymentDetailsStatusPaymentDetailsRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseDeletePaymentDetailsStatusDeletedPaymentDetailsRestDto
 */
export interface RestDataResponseDeletePaymentDetailsStatusDeletedPaymentDetailsRestDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseDeletePaymentDetailsStatusDeletedPaymentDetailsRestDto
     */
    'status': RestDataResponseDeletePaymentDetailsStatusDeletedPaymentDetailsRestDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseDeletePaymentDetailsStatusDeletedPaymentDetailsRestDto
     */
    'message'?: string;
    /**
     * 
     * @type {DeletedPaymentDetailsRestDto}
     * @memberof RestDataResponseDeletePaymentDetailsStatusDeletedPaymentDetailsRestDto
     */
    'data'?: DeletedPaymentDetailsRestDto;
}

export const RestDataResponseDeletePaymentDetailsStatusDeletedPaymentDetailsRestDtoStatusEnum = {
    Success: 'SUCCESS',
    CannotDeleteWhenUsedInOffer: 'CANNOT_DELETE_WHEN_USED_IN_OFFER',
    AccessDenied: 'ACCESS_DENIED',
    NotFound: 'NOT_FOUND'
} as const;

export type RestDataResponseDeletePaymentDetailsStatusDeletedPaymentDetailsRestDtoStatusEnum = typeof RestDataResponseDeletePaymentDetailsStatusDeletedPaymentDetailsRestDtoStatusEnum[keyof typeof RestDataResponseDeletePaymentDetailsStatusDeletedPaymentDetailsRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseDisableAntifraudRestStatusDisableAntifraudRestResponse
 */
export interface RestDataResponseDisableAntifraudRestStatusDisableAntifraudRestResponse {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseDisableAntifraudRestStatusDisableAntifraudRestResponse
     */
    'status': RestDataResponseDisableAntifraudRestStatusDisableAntifraudRestResponseStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseDisableAntifraudRestStatusDisableAntifraudRestResponse
     */
    'message'?: string;
    /**
     * 
     * @type {DisableAntifraudRestResponse}
     * @memberof RestDataResponseDisableAntifraudRestStatusDisableAntifraudRestResponse
     */
    'data'?: DisableAntifraudRestResponse;
}

export const RestDataResponseDisableAntifraudRestStatusDisableAntifraudRestResponseStatusEnum = {
    Success: 'SUCCESS',
    Failure: 'FAILURE'
} as const;

export type RestDataResponseDisableAntifraudRestStatusDisableAntifraudRestResponseStatusEnum = typeof RestDataResponseDisableAntifraudRestStatusDisableAntifraudRestResponseStatusEnum[keyof typeof RestDataResponseDisableAntifraudRestStatusDisableAntifraudRestResponseStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseDomOffersStatusListDomOfferRestDto
 */
export interface RestDataResponseDomOffersStatusListDomOfferRestDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseDomOffersStatusListDomOfferRestDto
     */
    'status': RestDataResponseDomOffersStatusListDomOfferRestDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseDomOffersStatusListDomOfferRestDto
     */
    'message'?: string;
    /**
     * Response payload, present if status is SUCCESS
     * @type {Array<DomOfferRestDto>}
     * @memberof RestDataResponseDomOffersStatusListDomOfferRestDto
     */
    'data'?: Array<DomOfferRestDto>;
}

export const RestDataResponseDomOffersStatusListDomOfferRestDtoStatusEnum = {
    Success: 'SUCCESS',
    UnsupportedBaseCurrency: 'UNSUPPORTED_BASE_CURRENCY',
    UnsupportedQuoteCurrency: 'UNSUPPORTED_QUOTE_CURRENCY',
    UnsupportedPaymentMethod: 'UNSUPPORTED_PAYMENT_METHOD',
    AccessDenied: 'ACCESS_DENIED'
} as const;

export type RestDataResponseDomOffersStatusListDomOfferRestDtoStatusEnum = typeof RestDataResponseDomOffersStatusListDomOfferRestDtoStatusEnum[keyof typeof RestDataResponseDomOffersStatusListDomOfferRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseEditPaymentDetailsBlacklistRestStatusPaymentDetailsBlacklistInfoRestDto
 */
export interface RestDataResponseEditPaymentDetailsBlacklistRestStatusPaymentDetailsBlacklistInfoRestDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseEditPaymentDetailsBlacklistRestStatusPaymentDetailsBlacklistInfoRestDto
     */
    'status': RestDataResponseEditPaymentDetailsBlacklistRestStatusPaymentDetailsBlacklistInfoRestDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseEditPaymentDetailsBlacklistRestStatusPaymentDetailsBlacklistInfoRestDto
     */
    'message'?: string;
    /**
     * 
     * @type {PaymentDetailsBlacklistInfoRestDto}
     * @memberof RestDataResponseEditPaymentDetailsBlacklistRestStatusPaymentDetailsBlacklistInfoRestDto
     */
    'data'?: PaymentDetailsBlacklistInfoRestDto;
}

export const RestDataResponseEditPaymentDetailsBlacklistRestStatusPaymentDetailsBlacklistInfoRestDtoStatusEnum = {
    Success: 'SUCCESS',
    NotFound: 'NOT_FOUND'
} as const;

export type RestDataResponseEditPaymentDetailsBlacklistRestStatusPaymentDetailsBlacklistInfoRestDtoStatusEnum = typeof RestDataResponseEditPaymentDetailsBlacklistRestStatusPaymentDetailsBlacklistInfoRestDtoStatusEnum[keyof typeof RestDataResponseEditPaymentDetailsBlacklistRestStatusPaymentDetailsBlacklistInfoRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseEditPaymentDetailsStatusPaymentDetailsRestDto
 */
export interface RestDataResponseEditPaymentDetailsStatusPaymentDetailsRestDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseEditPaymentDetailsStatusPaymentDetailsRestDto
     */
    'status': RestDataResponseEditPaymentDetailsStatusPaymentDetailsRestDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseEditPaymentDetailsStatusPaymentDetailsRestDto
     */
    'message'?: string;
    /**
     * 
     * @type {PaymentDetailsRestDto}
     * @memberof RestDataResponseEditPaymentDetailsStatusPaymentDetailsRestDto
     */
    'data'?: PaymentDetailsRestDto;
}

export const RestDataResponseEditPaymentDetailsStatusPaymentDetailsRestDtoStatusEnum = {
    Success: 'SUCCESS',
    AccessDenied: 'ACCESS_DENIED',
    CurrencyNotFound: 'CURRENCY_NOT_FOUND',
    CurrencyIsNotSupportedByPaymentMethod: 'CURRENCY_IS_NOT_SUPPORTED_BY_PAYMENT_METHOD',
    PaymentDetailsNameIsTooLong: 'PAYMENT_DETAILS_NAME_IS_TOO_LONG',
    PaymentMethodNotFound: 'PAYMENT_METHOD_NOT_FOUND',
    SelectedCurrencyIsNotFiat: 'SELECTED_CURRENCY_IS_NOT_FIAT',
    PaymentDetailsNotFound: 'PAYMENT_DETAILS_NOT_FOUND',
    InvalidPaymentDetailsAttributes: 'INVALID_PAYMENT_DETAILS_ATTRIBUTES'
} as const;

export type RestDataResponseEditPaymentDetailsStatusPaymentDetailsRestDtoStatusEnum = typeof RestDataResponseEditPaymentDetailsStatusPaymentDetailsRestDtoStatusEnum[keyof typeof RestDataResponseEditPaymentDetailsStatusPaymentDetailsRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseFindAllSupportedFiatStatusListString
 */
export interface RestDataResponseFindAllSupportedFiatStatusListString {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseFindAllSupportedFiatStatusListString
     */
    'status': RestDataResponseFindAllSupportedFiatStatusListStringStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseFindAllSupportedFiatStatusListString
     */
    'message'?: string;
    /**
     * Response payload, present if status is SUCCESS
     * @type {Array<string>}
     * @memberof RestDataResponseFindAllSupportedFiatStatusListString
     */
    'data'?: Array<string>;
}

export const RestDataResponseFindAllSupportedFiatStatusListStringStatusEnum = {
    Success: 'SUCCESS'
} as const;

export type RestDataResponseFindAllSupportedFiatStatusListStringStatusEnum = typeof RestDataResponseFindAllSupportedFiatStatusListStringStatusEnum[keyof typeof RestDataResponseFindAllSupportedFiatStatusListStringStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseFindCurrencyPairsStatusFindCurrencyPairsResponse
 */
export interface RestDataResponseFindCurrencyPairsStatusFindCurrencyPairsResponse {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseFindCurrencyPairsStatusFindCurrencyPairsResponse
     */
    'status': RestDataResponseFindCurrencyPairsStatusFindCurrencyPairsResponseStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseFindCurrencyPairsStatusFindCurrencyPairsResponse
     */
    'message'?: string;
    /**
     * 
     * @type {FindCurrencyPairsResponse}
     * @memberof RestDataResponseFindCurrencyPairsStatusFindCurrencyPairsResponse
     */
    'data'?: FindCurrencyPairsResponse;
}

export const RestDataResponseFindCurrencyPairsStatusFindCurrencyPairsResponseStatusEnum = {
    Success: 'SUCCESS'
} as const;

export type RestDataResponseFindCurrencyPairsStatusFindCurrencyPairsResponseStatusEnum = typeof RestDataResponseFindCurrencyPairsStatusFindCurrencyPairsResponseStatusEnum[keyof typeof RestDataResponseFindCurrencyPairsStatusFindCurrencyPairsResponseStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseFindPaymentDetailsStatusListPaymentDetailsRestDto
 */
export interface RestDataResponseFindPaymentDetailsStatusListPaymentDetailsRestDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseFindPaymentDetailsStatusListPaymentDetailsRestDto
     */
    'status': RestDataResponseFindPaymentDetailsStatusListPaymentDetailsRestDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseFindPaymentDetailsStatusListPaymentDetailsRestDto
     */
    'message'?: string;
    /**
     * Response payload, present if status is SUCCESS
     * @type {Array<PaymentDetailsRestDto>}
     * @memberof RestDataResponseFindPaymentDetailsStatusListPaymentDetailsRestDto
     */
    'data'?: Array<PaymentDetailsRestDto>;
}

export const RestDataResponseFindPaymentDetailsStatusListPaymentDetailsRestDtoStatusEnum = {
    Success: 'SUCCESS',
    NoPaymentDetailsFound: 'NO_PAYMENT_DETAILS_FOUND'
} as const;

export type RestDataResponseFindPaymentDetailsStatusListPaymentDetailsRestDtoStatusEnum = typeof RestDataResponseFindPaymentDetailsStatusListPaymentDetailsRestDtoStatusEnum[keyof typeof RestDataResponseFindPaymentDetailsStatusListPaymentDetailsRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseFindPaymentMethodSchemaStatusAttributeTypesRestDto
 */
export interface RestDataResponseFindPaymentMethodSchemaStatusAttributeTypesRestDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseFindPaymentMethodSchemaStatusAttributeTypesRestDto
     */
    'status': RestDataResponseFindPaymentMethodSchemaStatusAttributeTypesRestDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseFindPaymentMethodSchemaStatusAttributeTypesRestDto
     */
    'message'?: string;
    /**
     * 
     * @type {AttributeTypesRestDto}
     * @memberof RestDataResponseFindPaymentMethodSchemaStatusAttributeTypesRestDto
     */
    'data'?: AttributeTypesRestDto;
}

export const RestDataResponseFindPaymentMethodSchemaStatusAttributeTypesRestDtoStatusEnum = {
    Success: 'SUCCESS',
    NoPaymentMethodsAvailable: 'NO_PAYMENT_METHODS_AVAILABLE'
} as const;

export type RestDataResponseFindPaymentMethodSchemaStatusAttributeTypesRestDtoStatusEnum = typeof RestDataResponseFindPaymentMethodSchemaStatusAttributeTypesRestDtoStatusEnum[keyof typeof RestDataResponseFindPaymentMethodSchemaStatusAttributeTypesRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseFindPaymentMethodsStatusFindPaymentMethodsResponse
 */
export interface RestDataResponseFindPaymentMethodsStatusFindPaymentMethodsResponse {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseFindPaymentMethodsStatusFindPaymentMethodsResponse
     */
    'status': RestDataResponseFindPaymentMethodsStatusFindPaymentMethodsResponseStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseFindPaymentMethodsStatusFindPaymentMethodsResponse
     */
    'message'?: string;
    /**
     * 
     * @type {FindPaymentMethodsResponse}
     * @memberof RestDataResponseFindPaymentMethodsStatusFindPaymentMethodsResponse
     */
    'data'?: FindPaymentMethodsResponse;
}

export const RestDataResponseFindPaymentMethodsStatusFindPaymentMethodsResponseStatusEnum = {
    Success: 'SUCCESS',
    UnsupportedBaseCurrency: 'UNSUPPORTED_BASE_CURRENCY',
    UnsupportedQuoteCurrency: 'UNSUPPORTED_QUOTE_CURRENCY'
} as const;

export type RestDataResponseFindPaymentMethodsStatusFindPaymentMethodsResponseStatusEnum = typeof RestDataResponseFindPaymentMethodsStatusFindPaymentMethodsResponseStatusEnum[keyof typeof RestDataResponseFindPaymentMethodsStatusFindPaymentMethodsResponseStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseFindPaymentMethodsStatusListPaymentMethodRestDto
 */
export interface RestDataResponseFindPaymentMethodsStatusListPaymentMethodRestDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseFindPaymentMethodsStatusListPaymentMethodRestDto
     */
    'status': RestDataResponseFindPaymentMethodsStatusListPaymentMethodRestDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseFindPaymentMethodsStatusListPaymentMethodRestDto
     */
    'message'?: string;
    /**
     * Response payload, present if status is SUCCESS
     * @type {Array<PaymentMethodRestDto>}
     * @memberof RestDataResponseFindPaymentMethodsStatusListPaymentMethodRestDto
     */
    'data'?: Array<PaymentMethodRestDto>;
}

export const RestDataResponseFindPaymentMethodsStatusListPaymentMethodRestDtoStatusEnum = {
    Success: 'SUCCESS',
    NoPaymentMethodsAvailable: 'NO_PAYMENT_METHODS_AVAILABLE'
} as const;

export type RestDataResponseFindPaymentMethodsStatusListPaymentMethodRestDtoStatusEnum = typeof RestDataResponseFindPaymentMethodsStatusListPaymentMethodRestDtoStatusEnum[keyof typeof RestDataResponseFindPaymentMethodsStatusListPaymentMethodRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseFixedPriceLimitsStatusOfferFixedPriceLimitsRestDto
 */
export interface RestDataResponseFixedPriceLimitsStatusOfferFixedPriceLimitsRestDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseFixedPriceLimitsStatusOfferFixedPriceLimitsRestDto
     */
    'status': RestDataResponseFixedPriceLimitsStatusOfferFixedPriceLimitsRestDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseFixedPriceLimitsStatusOfferFixedPriceLimitsRestDto
     */
    'message'?: string;
    /**
     * 
     * @type {OfferFixedPriceLimitsRestDto}
     * @memberof RestDataResponseFixedPriceLimitsStatusOfferFixedPriceLimitsRestDto
     */
    'data'?: OfferFixedPriceLimitsRestDto;
}

export const RestDataResponseFixedPriceLimitsStatusOfferFixedPriceLimitsRestDtoStatusEnum = {
    Success: 'SUCCESS',
    UnsupportedBaseCurrency: 'UNSUPPORTED_BASE_CURRENCY',
    UnsupportedQuoteCurrency: 'UNSUPPORTED_QUOTE_CURRENCY'
} as const;

export type RestDataResponseFixedPriceLimitsStatusOfferFixedPriceLimitsRestDtoStatusEnum = typeof RestDataResponseFixedPriceLimitsStatusOfferFixedPriceLimitsRestDtoStatusEnum[keyof typeof RestDataResponseFixedPriceLimitsStatusOfferFixedPriceLimitsRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseGenerateApiKeyStatusGenerateApiKeyResponse
 */
export interface RestDataResponseGenerateApiKeyStatusGenerateApiKeyResponse {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseGenerateApiKeyStatusGenerateApiKeyResponse
     */
    'status': RestDataResponseGenerateApiKeyStatusGenerateApiKeyResponseStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseGenerateApiKeyStatusGenerateApiKeyResponse
     */
    'message'?: string;
    /**
     * 
     * @type {GenerateApiKeyResponse}
     * @memberof RestDataResponseGenerateApiKeyStatusGenerateApiKeyResponse
     */
    'data'?: GenerateApiKeyResponse;
}

export const RestDataResponseGenerateApiKeyStatusGenerateApiKeyResponseStatusEnum = {
    Success: 'SUCCESS',
    Error: 'ERROR'
} as const;

export type RestDataResponseGenerateApiKeyStatusGenerateApiKeyResponseStatusEnum = typeof RestDataResponseGenerateApiKeyStatusGenerateApiKeyResponseStatusEnum[keyof typeof RestDataResponseGenerateApiKeyStatusGenerateApiKeyResponseStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseGetAbTestsStatusABTestsDict
 */
export interface RestDataResponseGetAbTestsStatusABTestsDict {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseGetAbTestsStatusABTestsDict
     */
    'status': RestDataResponseGetAbTestsStatusABTestsDictStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseGetAbTestsStatusABTestsDict
     */
    'message'?: string;
    /**
     * 
     * @type {ABTestsDict}
     * @memberof RestDataResponseGetAbTestsStatusABTestsDict
     */
    'data'?: ABTestsDict;
}

export const RestDataResponseGetAbTestsStatusABTestsDictStatusEnum = {
    Success: 'SUCCESS'
} as const;

export type RestDataResponseGetAbTestsStatusABTestsDictStatusEnum = typeof RestDataResponseGetAbTestsStatusABTestsDictStatusEnum[keyof typeof RestDataResponseGetAbTestsStatusABTestsDictStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseGetCurrentRequestStatusExpressRequestRestDto
 */
export interface RestDataResponseGetCurrentRequestStatusExpressRequestRestDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseGetCurrentRequestStatusExpressRequestRestDto
     */
    'status': RestDataResponseGetCurrentRequestStatusExpressRequestRestDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseGetCurrentRequestStatusExpressRequestRestDto
     */
    'message'?: string;
    /**
     * 
     * @type {ExpressRequestRestDto}
     * @memberof RestDataResponseGetCurrentRequestStatusExpressRequestRestDto
     */
    'data'?: ExpressRequestRestDto;
}

export const RestDataResponseGetCurrentRequestStatusExpressRequestRestDtoStatusEnum = {
    Success: 'SUCCESS',
    NoCurrentRequest: 'NO_CURRENT_REQUEST',
    AccessDenied: 'ACCESS_DENIED'
} as const;

export type RestDataResponseGetCurrentRequestStatusExpressRequestRestDtoStatusEnum = typeof RestDataResponseGetCurrentRequestStatusExpressRequestRestDtoStatusEnum[keyof typeof RestDataResponseGetCurrentRequestStatusExpressRequestRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseGetInfoRestStatusBuyOfferInfoRestDto
 */
export interface RestDataResponseGetInfoRestStatusBuyOfferInfoRestDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseGetInfoRestStatusBuyOfferInfoRestDto
     */
    'status': RestDataResponseGetInfoRestStatusBuyOfferInfoRestDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseGetInfoRestStatusBuyOfferInfoRestDto
     */
    'message'?: string;
    /**
     * 
     * @type {BuyOfferInfoRestDto}
     * @memberof RestDataResponseGetInfoRestStatusBuyOfferInfoRestDto
     */
    'data'?: BuyOfferInfoRestDto;
}

export const RestDataResponseGetInfoRestStatusBuyOfferInfoRestDtoStatusEnum = {
    Success: 'SUCCESS',
    NotFound: 'NOT_FOUND'
} as const;

export type RestDataResponseGetInfoRestStatusBuyOfferInfoRestDtoStatusEnum = typeof RestDataResponseGetInfoRestStatusBuyOfferInfoRestDtoStatusEnum[keyof typeof RestDataResponseGetInfoRestStatusBuyOfferInfoRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseGetInfoRestStatusOrderInfoRestDto
 */
export interface RestDataResponseGetInfoRestStatusOrderInfoRestDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseGetInfoRestStatusOrderInfoRestDto
     */
    'status': RestDataResponseGetInfoRestStatusOrderInfoRestDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseGetInfoRestStatusOrderInfoRestDto
     */
    'message'?: string;
    /**
     * 
     * @type {OrderInfoRestDto}
     * @memberof RestDataResponseGetInfoRestStatusOrderInfoRestDto
     */
    'data'?: OrderInfoRestDto;
}

export const RestDataResponseGetInfoRestStatusOrderInfoRestDtoStatusEnum = {
    Success: 'SUCCESS',
    NotFound: 'NOT_FOUND'
} as const;

export type RestDataResponseGetInfoRestStatusOrderInfoRestDtoStatusEnum = typeof RestDataResponseGetInfoRestStatusOrderInfoRestDtoStatusEnum[keyof typeof RestDataResponseGetInfoRestStatusOrderInfoRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseGetInfoRestStatusSellOfferInfoRestDto
 */
export interface RestDataResponseGetInfoRestStatusSellOfferInfoRestDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseGetInfoRestStatusSellOfferInfoRestDto
     */
    'status': RestDataResponseGetInfoRestStatusSellOfferInfoRestDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseGetInfoRestStatusSellOfferInfoRestDto
     */
    'message'?: string;
    /**
     * 
     * @type {SellOfferInfoRestDto}
     * @memberof RestDataResponseGetInfoRestStatusSellOfferInfoRestDto
     */
    'data'?: SellOfferInfoRestDto;
}

export const RestDataResponseGetInfoRestStatusSellOfferInfoRestDtoStatusEnum = {
    Success: 'SUCCESS',
    NotFound: 'NOT_FOUND'
} as const;

export type RestDataResponseGetInfoRestStatusSellOfferInfoRestDtoStatusEnum = typeof RestDataResponseGetInfoRestStatusSellOfferInfoRestDtoStatusEnum[keyof typeof RestDataResponseGetInfoRestStatusSellOfferInfoRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseGetLimitsStatusGetLimitsResponse
 */
export interface RestDataResponseGetLimitsStatusGetLimitsResponse {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseGetLimitsStatusGetLimitsResponse
     */
    'status': RestDataResponseGetLimitsStatusGetLimitsResponseStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseGetLimitsStatusGetLimitsResponse
     */
    'message'?: string;
    /**
     * 
     * @type {GetLimitsResponse}
     * @memberof RestDataResponseGetLimitsStatusGetLimitsResponse
     */
    'data'?: GetLimitsResponse;
}

export const RestDataResponseGetLimitsStatusGetLimitsResponseStatusEnum = {
    Success: 'SUCCESS',
    UnsupportedBaseCurrency: 'UNSUPPORTED_BASE_CURRENCY',
    UnsupportedQuoteCurrency: 'UNSUPPORTED_QUOTE_CURRENCY'
} as const;

export type RestDataResponseGetLimitsStatusGetLimitsResponseStatusEnum = typeof RestDataResponseGetLimitsStatusGetLimitsResponseStatusEnum[keyof typeof RestDataResponseGetLimitsStatusGetLimitsResponseStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseGetNotificationsByUserIdListNotificationRestDto
 */
export interface RestDataResponseGetNotificationsByUserIdListNotificationRestDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseGetNotificationsByUserIdListNotificationRestDto
     */
    'status': RestDataResponseGetNotificationsByUserIdListNotificationRestDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseGetNotificationsByUserIdListNotificationRestDto
     */
    'message'?: string;
    /**
     * Response payload, present if status is SUCCESS
     * @type {Array<NotificationRestDto>}
     * @memberof RestDataResponseGetNotificationsByUserIdListNotificationRestDto
     */
    'data'?: Array<NotificationRestDto>;
}

export const RestDataResponseGetNotificationsByUserIdListNotificationRestDtoStatusEnum = {
    Success: 'SUCCESS'
} as const;

export type RestDataResponseGetNotificationsByUserIdListNotificationRestDtoStatusEnum = typeof RestDataResponseGetNotificationsByUserIdListNotificationRestDtoStatusEnum[keyof typeof RestDataResponseGetNotificationsByUserIdListNotificationRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseGetOfferByUserIdStatusListUserPrivateMyOffersListRestDto
 */
export interface RestDataResponseGetOfferByUserIdStatusListUserPrivateMyOffersListRestDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseGetOfferByUserIdStatusListUserPrivateMyOffersListRestDto
     */
    'status': RestDataResponseGetOfferByUserIdStatusListUserPrivateMyOffersListRestDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseGetOfferByUserIdStatusListUserPrivateMyOffersListRestDto
     */
    'message'?: string;
    /**
     * Response payload, present if status is SUCCESS
     * @type {Array<UserPrivateMyBuyOffersListRestDto | UserPrivateMySellOffersListRestDto>}
     * @memberof RestDataResponseGetOfferByUserIdStatusListUserPrivateMyOffersListRestDto
     */
    'data'?: Array<UserPrivateMyBuyOffersListRestDto | UserPrivateMySellOffersListRestDto>;
}

export const RestDataResponseGetOfferByUserIdStatusListUserPrivateMyOffersListRestDtoStatusEnum = {
    Success: 'SUCCESS'
} as const;

export type RestDataResponseGetOfferByUserIdStatusListUserPrivateMyOffersListRestDtoStatusEnum = typeof RestDataResponseGetOfferByUserIdStatusListUserPrivateMyOffersListRestDtoStatusEnum[keyof typeof RestDataResponseGetOfferByUserIdStatusListUserPrivateMyOffersListRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseGetOfferStatusBaseOfferRestDto
 */
export interface RestDataResponseGetOfferStatusBaseOfferRestDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseGetOfferStatusBaseOfferRestDto
     */
    'status': RestDataResponseGetOfferStatusBaseOfferRestDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseGetOfferStatusBaseOfferRestDto
     */
    'message'?: string;
    /**
     * 
     * @type {BuyOfferRestDto | SellOfferRestDto}
     * @memberof RestDataResponseGetOfferStatusBaseOfferRestDto
     */
    'data'?: BuyOfferRestDto | SellOfferRestDto;
}

export const RestDataResponseGetOfferStatusBaseOfferRestDtoStatusEnum = {
    Success: 'SUCCESS',
    OfferNotFound: 'OFFER_NOT_FOUND'
} as const;

export type RestDataResponseGetOfferStatusBaseOfferRestDtoStatusEnum = typeof RestDataResponseGetOfferStatusBaseOfferRestDtoStatusEnum[keyof typeof RestDataResponseGetOfferStatusBaseOfferRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseGetOrderRestStatusOrderRestDto
 */
export interface RestDataResponseGetOrderRestStatusOrderRestDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseGetOrderRestStatusOrderRestDto
     */
    'status': RestDataResponseGetOrderRestStatusOrderRestDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseGetOrderRestStatusOrderRestDto
     */
    'message'?: string;
    /**
     * 
     * @type {OrderRestDto}
     * @memberof RestDataResponseGetOrderRestStatusOrderRestDto
     */
    'data'?: OrderRestDto;
}

export const RestDataResponseGetOrderRestStatusOrderRestDtoStatusEnum = {
    Success: 'SUCCESS',
    NotFound: 'NOT_FOUND'
} as const;

export type RestDataResponseGetOrderRestStatusOrderRestDtoStatusEnum = typeof RestDataResponseGetOrderRestStatusOrderRestDtoStatusEnum[keyof typeof RestDataResponseGetOrderRestStatusOrderRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseGetOrdersByUserRestStatusListOrderRestDto
 */
export interface RestDataResponseGetOrdersByUserRestStatusListOrderRestDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseGetOrdersByUserRestStatusListOrderRestDto
     */
    'status': RestDataResponseGetOrdersByUserRestStatusListOrderRestDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseGetOrdersByUserRestStatusListOrderRestDto
     */
    'message'?: string;
    /**
     * Response payload, present if status is SUCCESS
     * @type {Array<OrderRestDto>}
     * @memberof RestDataResponseGetOrdersByUserRestStatusListOrderRestDto
     */
    'data'?: Array<OrderRestDto>;
}

export const RestDataResponseGetOrdersByUserRestStatusListOrderRestDtoStatusEnum = {
    Success: 'SUCCESS'
} as const;

export type RestDataResponseGetOrdersByUserRestStatusListOrderRestDtoStatusEnum = typeof RestDataResponseGetOrdersByUserRestStatusListOrderRestDtoStatusEnum[keyof typeof RestDataResponseGetOrdersByUserRestStatusListOrderRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseGetPaymentDetailsBlacklistRestStatusPaymentDetailsBlacklistInfoRestDto
 */
export interface RestDataResponseGetPaymentDetailsBlacklistRestStatusPaymentDetailsBlacklistInfoRestDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseGetPaymentDetailsBlacklistRestStatusPaymentDetailsBlacklistInfoRestDto
     */
    'status': RestDataResponseGetPaymentDetailsBlacklistRestStatusPaymentDetailsBlacklistInfoRestDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseGetPaymentDetailsBlacklistRestStatusPaymentDetailsBlacklistInfoRestDto
     */
    'message'?: string;
    /**
     * 
     * @type {PaymentDetailsBlacklistInfoRestDto}
     * @memberof RestDataResponseGetPaymentDetailsBlacklistRestStatusPaymentDetailsBlacklistInfoRestDto
     */
    'data'?: PaymentDetailsBlacklistInfoRestDto;
}

export const RestDataResponseGetPaymentDetailsBlacklistRestStatusPaymentDetailsBlacklistInfoRestDtoStatusEnum = {
    Success: 'SUCCESS',
    NotFound: 'NOT_FOUND'
} as const;

export type RestDataResponseGetPaymentDetailsBlacklistRestStatusPaymentDetailsBlacklistInfoRestDtoStatusEnum = typeof RestDataResponseGetPaymentDetailsBlacklistRestStatusPaymentDetailsBlacklistInfoRestDtoStatusEnum[keyof typeof RestDataResponseGetPaymentDetailsBlacklistRestStatusPaymentDetailsBlacklistInfoRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseGetSupportedCodesStatusListString
 */
export interface RestDataResponseGetSupportedCodesStatusListString {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseGetSupportedCodesStatusListString
     */
    'status': RestDataResponseGetSupportedCodesStatusListStringStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseGetSupportedCodesStatusListString
     */
    'message'?: string;
    /**
     * Response payload, present if status is SUCCESS
     * @type {Array<string>}
     * @memberof RestDataResponseGetSupportedCodesStatusListString
     */
    'data'?: Array<string>;
}

export const RestDataResponseGetSupportedCodesStatusListStringStatusEnum = {
    Success: 'SUCCESS'
} as const;

export type RestDataResponseGetSupportedCodesStatusListStringStatusEnum = typeof RestDataResponseGetSupportedCodesStatusListStringStatusEnum[keyof typeof RestDataResponseGetSupportedCodesStatusListStringStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseGetUserAvailableBalanceWithoutBuyOrderFeeStatusGetUserAvailableBalanceWithoutBuyOrderFeeRestResponse
 */
export interface RestDataResponseGetUserAvailableBalanceWithoutBuyOrderFeeStatusGetUserAvailableBalanceWithoutBuyOrderFeeRestResponse {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseGetUserAvailableBalanceWithoutBuyOrderFeeStatusGetUserAvailableBalanceWithoutBuyOrderFeeRestResponse
     */
    'status': RestDataResponseGetUserAvailableBalanceWithoutBuyOrderFeeStatusGetUserAvailableBalanceWithoutBuyOrderFeeRestResponseStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseGetUserAvailableBalanceWithoutBuyOrderFeeStatusGetUserAvailableBalanceWithoutBuyOrderFeeRestResponse
     */
    'message'?: string;
    /**
     * 
     * @type {GetUserAvailableBalanceWithoutBuyOrderFeeRestResponse}
     * @memberof RestDataResponseGetUserAvailableBalanceWithoutBuyOrderFeeStatusGetUserAvailableBalanceWithoutBuyOrderFeeRestResponse
     */
    'data'?: GetUserAvailableBalanceWithoutBuyOrderFeeRestResponse;
}

export const RestDataResponseGetUserAvailableBalanceWithoutBuyOrderFeeStatusGetUserAvailableBalanceWithoutBuyOrderFeeRestResponseStatusEnum = {
    Success: 'SUCCESS',
    BalanceIsUnavailable: 'BALANCE_IS_UNAVAILABLE',
    AccessDenied: 'ACCESS_DENIED',
    UnsupportedCurrency: 'UNSUPPORTED_CURRENCY'
} as const;

export type RestDataResponseGetUserAvailableBalanceWithoutBuyOrderFeeStatusGetUserAvailableBalanceWithoutBuyOrderFeeRestResponseStatusEnum = typeof RestDataResponseGetUserAvailableBalanceWithoutBuyOrderFeeStatusGetUserAvailableBalanceWithoutBuyOrderFeeRestResponseStatusEnum[keyof typeof RestDataResponseGetUserAvailableBalanceWithoutBuyOrderFeeStatusGetUserAvailableBalanceWithoutBuyOrderFeeRestResponseStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseGetUserPrivateOfferStatusUserPrivateBaseOfferRestDto
 */
export interface RestDataResponseGetUserPrivateOfferStatusUserPrivateBaseOfferRestDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseGetUserPrivateOfferStatusUserPrivateBaseOfferRestDto
     */
    'status': RestDataResponseGetUserPrivateOfferStatusUserPrivateBaseOfferRestDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseGetUserPrivateOfferStatusUserPrivateBaseOfferRestDto
     */
    'message'?: string;
    /**
     * 
     * @type {UserPrivateBuyOfferRestDto | UserPrivateSellOfferRestDto}
     * @memberof RestDataResponseGetUserPrivateOfferStatusUserPrivateBaseOfferRestDto
     */
    'data'?: UserPrivateBuyOfferRestDto | UserPrivateSellOfferRestDto;
}

export const RestDataResponseGetUserPrivateOfferStatusUserPrivateBaseOfferRestDtoStatusEnum = {
    Success: 'SUCCESS',
    OfferNotFound: 'OFFER_NOT_FOUND'
} as const;

export type RestDataResponseGetUserPrivateOfferStatusUserPrivateBaseOfferRestDtoStatusEnum = typeof RestDataResponseGetUserPrivateOfferStatusUserPrivateBaseOfferRestDtoStatusEnum[keyof typeof RestDataResponseGetUserPrivateOfferStatusUserPrivateBaseOfferRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseGetUserStatisticsResponseStatusUserStatisticsBackOfficeRestDto
 */
export interface RestDataResponseGetUserStatisticsResponseStatusUserStatisticsBackOfficeRestDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseGetUserStatisticsResponseStatusUserStatisticsBackOfficeRestDto
     */
    'status': RestDataResponseGetUserStatisticsResponseStatusUserStatisticsBackOfficeRestDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseGetUserStatisticsResponseStatusUserStatisticsBackOfficeRestDto
     */
    'message'?: string;
    /**
     * 
     * @type {UserStatisticsBackOfficeRestDto}
     * @memberof RestDataResponseGetUserStatisticsResponseStatusUserStatisticsBackOfficeRestDto
     */
    'data'?: UserStatisticsBackOfficeRestDto;
}

export const RestDataResponseGetUserStatisticsResponseStatusUserStatisticsBackOfficeRestDtoStatusEnum = {
    Success: 'SUCCESS'
} as const;

export type RestDataResponseGetUserStatisticsResponseStatusUserStatisticsBackOfficeRestDtoStatusEnum = typeof RestDataResponseGetUserStatisticsResponseStatusUserStatisticsBackOfficeRestDtoStatusEnum[keyof typeof RestDataResponseGetUserStatisticsResponseStatusUserStatisticsBackOfficeRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseGetUserStatisticsResponseStatusUserStatisticsRestDto
 */
export interface RestDataResponseGetUserStatisticsResponseStatusUserStatisticsRestDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseGetUserStatisticsResponseStatusUserStatisticsRestDto
     */
    'status': RestDataResponseGetUserStatisticsResponseStatusUserStatisticsRestDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseGetUserStatisticsResponseStatusUserStatisticsRestDto
     */
    'message'?: string;
    /**
     * 
     * @type {UserStatisticsRestDto}
     * @memberof RestDataResponseGetUserStatisticsResponseStatusUserStatisticsRestDto
     */
    'data'?: UserStatisticsRestDto;
}

export const RestDataResponseGetUserStatisticsResponseStatusUserStatisticsRestDtoStatusEnum = {
    Success: 'SUCCESS'
} as const;

export type RestDataResponseGetUserStatisticsResponseStatusUserStatisticsRestDtoStatusEnum = typeof RestDataResponseGetUserStatisticsResponseStatusUserStatisticsRestDtoStatusEnum[keyof typeof RestDataResponseGetUserStatisticsResponseStatusUserStatisticsRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseIsCodeSupportedStatusBoolean
 */
export interface RestDataResponseIsCodeSupportedStatusBoolean {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseIsCodeSupportedStatusBoolean
     */
    'status': RestDataResponseIsCodeSupportedStatusBooleanStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseIsCodeSupportedStatusBoolean
     */
    'message'?: string;
    /**
     * Response payload, present if status is SUCCESS
     * @type {boolean}
     * @memberof RestDataResponseIsCodeSupportedStatusBoolean
     */
    'data'?: boolean;
}

export const RestDataResponseIsCodeSupportedStatusBooleanStatusEnum = {
    Success: 'SUCCESS'
} as const;

export type RestDataResponseIsCodeSupportedStatusBooleanStatusEnum = typeof RestDataResponseIsCodeSupportedStatusBooleanStatusEnum[keyof typeof RestDataResponseIsCodeSupportedStatusBooleanStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseListOrderViewRestStatusListListOrderViewRestDto
 */
export interface RestDataResponseListOrderViewRestStatusListListOrderViewRestDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseListOrderViewRestStatusListListOrderViewRestDto
     */
    'status': RestDataResponseListOrderViewRestStatusListListOrderViewRestDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseListOrderViewRestStatusListListOrderViewRestDto
     */
    'message'?: string;
    /**
     * Response payload, present if status is SUCCESS
     * @type {Array<ListOrderViewRestDto>}
     * @memberof RestDataResponseListOrderViewRestStatusListListOrderViewRestDto
     */
    'data'?: Array<ListOrderViewRestDto>;
}

export const RestDataResponseListOrderViewRestStatusListListOrderViewRestDtoStatusEnum = {
    Success: 'SUCCESS'
} as const;

export type RestDataResponseListOrderViewRestStatusListListOrderViewRestDtoStatusEnum = typeof RestDataResponseListOrderViewRestStatusListListOrderViewRestDtoStatusEnum[keyof typeof RestDataResponseListOrderViewRestStatusListListOrderViewRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseListOrderViewRestStatusListListOrderViewWithActiveAppealRestDto
 */
export interface RestDataResponseListOrderViewRestStatusListListOrderViewWithActiveAppealRestDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseListOrderViewRestStatusListListOrderViewWithActiveAppealRestDto
     */
    'status': RestDataResponseListOrderViewRestStatusListListOrderViewWithActiveAppealRestDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseListOrderViewRestStatusListListOrderViewWithActiveAppealRestDto
     */
    'message'?: string;
    /**
     * Response payload, present if status is SUCCESS
     * @type {Array<ListOrderViewWithActiveAppealRestDto>}
     * @memberof RestDataResponseListOrderViewRestStatusListListOrderViewWithActiveAppealRestDto
     */
    'data'?: Array<ListOrderViewWithActiveAppealRestDto>;
}

export const RestDataResponseListOrderViewRestStatusListListOrderViewWithActiveAppealRestDtoStatusEnum = {
    Success: 'SUCCESS'
} as const;

export type RestDataResponseListOrderViewRestStatusListListOrderViewWithActiveAppealRestDtoStatusEnum = typeof RestDataResponseListOrderViewRestStatusListListOrderViewWithActiveAppealRestDtoStatusEnum[keyof typeof RestDataResponseListOrderViewRestStatusListListOrderViewWithActiveAppealRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseListPaymentDetailsBlacklistRestStatusListPaymentDetailsBlacklistInfoRestDto
 */
export interface RestDataResponseListPaymentDetailsBlacklistRestStatusListPaymentDetailsBlacklistInfoRestDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseListPaymentDetailsBlacklistRestStatusListPaymentDetailsBlacklistInfoRestDto
     */
    'status': RestDataResponseListPaymentDetailsBlacklistRestStatusListPaymentDetailsBlacklistInfoRestDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseListPaymentDetailsBlacklistRestStatusListPaymentDetailsBlacklistInfoRestDto
     */
    'message'?: string;
    /**
     * Response payload, present if status is SUCCESS
     * @type {Array<PaymentDetailsBlacklistInfoRestDto>}
     * @memberof RestDataResponseListPaymentDetailsBlacklistRestStatusListPaymentDetailsBlacklistInfoRestDto
     */
    'data'?: Array<PaymentDetailsBlacklistInfoRestDto>;
}

export const RestDataResponseListPaymentDetailsBlacklistRestStatusListPaymentDetailsBlacklistInfoRestDtoStatusEnum = {
    Success: 'SUCCESS'
} as const;

export type RestDataResponseListPaymentDetailsBlacklistRestStatusListPaymentDetailsBlacklistInfoRestDtoStatusEnum = typeof RestDataResponseListPaymentDetailsBlacklistRestStatusListPaymentDetailsBlacklistInfoRestDtoStatusEnum[keyof typeof RestDataResponseListPaymentDetailsBlacklistRestStatusListPaymentDetailsBlacklistInfoRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseOfferIdsToExcludeFromDomRestStatusOfferIdsExcludeFromDomListRestDto
 */
export interface RestDataResponseOfferIdsToExcludeFromDomRestStatusOfferIdsExcludeFromDomListRestDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseOfferIdsToExcludeFromDomRestStatusOfferIdsExcludeFromDomListRestDto
     */
    'status': RestDataResponseOfferIdsToExcludeFromDomRestStatusOfferIdsExcludeFromDomListRestDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseOfferIdsToExcludeFromDomRestStatusOfferIdsExcludeFromDomListRestDto
     */
    'message'?: string;
    /**
     * 
     * @type {OfferIdsExcludeFromDomListRestDto}
     * @memberof RestDataResponseOfferIdsToExcludeFromDomRestStatusOfferIdsExcludeFromDomListRestDto
     */
    'data'?: OfferIdsExcludeFromDomListRestDto;
}

export const RestDataResponseOfferIdsToExcludeFromDomRestStatusOfferIdsExcludeFromDomListRestDtoStatusEnum = {
    Success: 'SUCCESS',
    AccessDenied: 'ACCESS_DENIED'
} as const;

export type RestDataResponseOfferIdsToExcludeFromDomRestStatusOfferIdsExcludeFromDomListRestDtoStatusEnum = typeof RestDataResponseOfferIdsToExcludeFromDomRestStatusOfferIdsExcludeFromDomListRestDtoStatusEnum[keyof typeof RestDataResponseOfferIdsToExcludeFromDomRestStatusOfferIdsExcludeFromDomListRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseSendAttachmentRestStatusSendAttachmentRestResponse
 */
export interface RestDataResponseSendAttachmentRestStatusSendAttachmentRestResponse {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseSendAttachmentRestStatusSendAttachmentRestResponse
     */
    'status': RestDataResponseSendAttachmentRestStatusSendAttachmentRestResponseStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseSendAttachmentRestStatusSendAttachmentRestResponse
     */
    'message'?: string;
    /**
     * 
     * @type {SendAttachmentRestResponse}
     * @memberof RestDataResponseSendAttachmentRestStatusSendAttachmentRestResponse
     */
    'data'?: SendAttachmentRestResponse;
}

export const RestDataResponseSendAttachmentRestStatusSendAttachmentRestResponseStatusEnum = {
    Success: 'SUCCESS',
    OrderClosed: 'ORDER_CLOSED',
    IllegalMimeType: 'ILLEGAL_MIME_TYPE',
    TooManyAttachmentsForOneOrder: 'TOO_MANY_ATTACHMENTS_FOR_ONE_ORDER',
    FileSizeExceeded: 'FILE_SIZE_EXCEEDED',
    IllegalRequest: 'ILLEGAL_REQUEST',
    MessageTooLong: 'MESSAGE_TOO_LONG'
} as const;

export type RestDataResponseSendAttachmentRestStatusSendAttachmentRestResponseStatusEnum = typeof RestDataResponseSendAttachmentRestStatusSendAttachmentRestResponseStatusEnum[keyof typeof RestDataResponseSendAttachmentRestStatusSendAttachmentRestResponseStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseSendMessageRestStatusSendMessageRestResponse
 */
export interface RestDataResponseSendMessageRestStatusSendMessageRestResponse {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseSendMessageRestStatusSendMessageRestResponse
     */
    'status': RestDataResponseSendMessageRestStatusSendMessageRestResponseStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseSendMessageRestStatusSendMessageRestResponse
     */
    'message'?: string;
    /**
     * 
     * @type {SendMessageRestResponse}
     * @memberof RestDataResponseSendMessageRestStatusSendMessageRestResponse
     */
    'data'?: SendMessageRestResponse;
}

export const RestDataResponseSendMessageRestStatusSendMessageRestResponseStatusEnum = {
    Success: 'SUCCESS',
    OrderClosed: 'ORDER_CLOSED',
    MessageTooLong: 'MESSAGE_TOO_LONG',
    IllegalRequest: 'ILLEGAL_REQUEST'
} as const;

export type RestDataResponseSendMessageRestStatusSendMessageRestResponseStatusEnum = typeof RestDataResponseSendMessageRestStatusSendMessageRestResponseStatusEnum[keyof typeof RestDataResponseSendMessageRestStatusSendMessageRestResponseStatusEnum];

/**
 * 
 * @export
 * @interface RestDataResponseSettingsStatusSettingsRestDto
 */
export interface RestDataResponseSettingsStatusSettingsRestDto {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestDataResponseSettingsStatusSettingsRestDto
     */
    'status': RestDataResponseSettingsStatusSettingsRestDtoStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestDataResponseSettingsStatusSettingsRestDto
     */
    'message'?: string;
    /**
     * 
     * @type {SettingsRestDto}
     * @memberof RestDataResponseSettingsStatusSettingsRestDto
     */
    'data'?: SettingsRestDto;
}

export const RestDataResponseSettingsStatusSettingsRestDtoStatusEnum = {
    Success: 'SUCCESS'
} as const;

export type RestDataResponseSettingsStatusSettingsRestDtoStatusEnum = typeof RestDataResponseSettingsStatusSettingsRestDtoStatusEnum[keyof typeof RestDataResponseSettingsStatusSettingsRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface RestResponseAntifraudLastResultRestStatus
 */
export interface RestResponseAntifraudLastResultRestStatus {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestResponseAntifraudLastResultRestStatus
     */
    'status': RestResponseAntifraudLastResultRestStatusStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestResponseAntifraudLastResultRestStatus
     */
    'message'?: string;
}

export const RestResponseAntifraudLastResultRestStatusStatusEnum = {
    Success: 'SUCCESS'
} as const;

export type RestResponseAntifraudLastResultRestStatusStatusEnum = typeof RestResponseAntifraudLastResultRestStatusStatusEnum[keyof typeof RestResponseAntifraudLastResultRestStatusStatusEnum];

/**
 * 
 * @export
 * @interface RestResponseBiddingSettingsResponseStatus
 */
export interface RestResponseBiddingSettingsResponseStatus {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestResponseBiddingSettingsResponseStatus
     */
    'status': RestResponseBiddingSettingsResponseStatusStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestResponseBiddingSettingsResponseStatus
     */
    'message'?: string;
}

export const RestResponseBiddingSettingsResponseStatusStatusEnum = {
    Success: 'SUCCESS',
    AccessDenied: 'ACCESS_DENIED'
} as const;

export type RestResponseBiddingSettingsResponseStatusStatusEnum = typeof RestResponseBiddingSettingsResponseStatusStatusEnum[keyof typeof RestResponseBiddingSettingsResponseStatusStatusEnum];

/**
 * 
 * @export
 * @interface RestResponseCanCreateOrdersOnOfferRestStatus
 */
export interface RestResponseCanCreateOrdersOnOfferRestStatus {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestResponseCanCreateOrdersOnOfferRestStatus
     */
    'status': RestResponseCanCreateOrdersOnOfferRestStatusStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestResponseCanCreateOrdersOnOfferRestStatus
     */
    'message'?: string;
}

export const RestResponseCanCreateOrdersOnOfferRestStatusStatusEnum = {
    Success: 'SUCCESS',
    OpenOrdersPerOfferCapReached: 'OPEN_ORDERS_PER_OFFER_CAP_REACHED',
    NotFound: 'NOT_FOUND',
    AccessDeniedForUser: 'ACCESS_DENIED_FOR_USER',
    AccessDeniedForMaker: 'ACCESS_DENIED_FOR_MAKER'
} as const;

export type RestResponseCanCreateOrdersOnOfferRestStatusStatusEnum = typeof RestResponseCanCreateOrdersOnOfferRestStatusStatusEnum[keyof typeof RestResponseCanCreateOrdersOnOfferRestStatusStatusEnum];

/**
 * 
 * @export
 * @interface RestResponseCancelExpressRequestStatus
 */
export interface RestResponseCancelExpressRequestStatus {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestResponseCancelExpressRequestStatus
     */
    'status': RestResponseCancelExpressRequestStatusStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestResponseCancelExpressRequestStatus
     */
    'message'?: string;
}

export const RestResponseCancelExpressRequestStatusStatusEnum = {
    Success: 'SUCCESS',
    AccessDenied: 'ACCESS_DENIED',
    CancellingIsNotAvailable: 'CANCELLING_IS_NOT_AVAILABLE'
} as const;

export type RestResponseCancelExpressRequestStatusStatusEnum = typeof RestResponseCancelExpressRequestStatusStatusEnum[keyof typeof RestResponseCancelExpressRequestStatusStatusEnum];

/**
 * 
 * @export
 * @interface RestResponseCancelRestStatus
 */
export interface RestResponseCancelRestStatus {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestResponseCancelRestStatus
     */
    'status': RestResponseCancelRestStatusStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestResponseCancelRestStatus
     */
    'message'?: string;
}

export const RestResponseCancelRestStatusStatusEnum = {
    Success: 'SUCCESS',
    CancellationIsNotAvailable: 'CANCELLATION_IS_NOT_AVAILABLE',
    AccessDeniedForBuyer: 'ACCESS_DENIED_FOR_BUYER',
    AccessDeniedForSeller: 'ACCESS_DENIED_FOR_SELLER'
} as const;

export type RestResponseCancelRestStatusStatusEnum = typeof RestResponseCancelRestStatusStatusEnum[keyof typeof RestResponseCancelRestStatusStatusEnum];

/**
 * 
 * @export
 * @interface RestResponseCheckUserResponseStatus
 */
export interface RestResponseCheckUserResponseStatus {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestResponseCheckUserResponseStatus
     */
    'status': RestResponseCheckUserResponseStatusStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestResponseCheckUserResponseStatus
     */
    'message'?: string;
}

export const RestResponseCheckUserResponseStatusStatusEnum = {
    Success: 'SUCCESS',
    AccessDenied: 'ACCESS_DENIED',
    PhoneNumberRequired: 'PHONE_NUMBER_REQUIRED'
} as const;

export type RestResponseCheckUserResponseStatusStatusEnum = typeof RestResponseCheckUserResponseStatusStatusEnum[keyof typeof RestResponseCheckUserResponseStatusStatusEnum];

/**
 * 
 * @export
 * @interface RestResponseConfirmReceiptPaymentRestStatus
 */
export interface RestResponseConfirmReceiptPaymentRestStatus {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestResponseConfirmReceiptPaymentRestStatus
     */
    'status': RestResponseConfirmReceiptPaymentRestStatusStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestResponseConfirmReceiptPaymentRestStatus
     */
    'message'?: string;
}

export const RestResponseConfirmReceiptPaymentRestStatusStatusEnum = {
    Success: 'SUCCESS',
    AccessDeniedForBuyer: 'ACCESS_DENIED_FOR_BUYER',
    AccessDeniedForSeller: 'ACCESS_DENIED_FOR_SELLER',
    NotFound: 'NOT_FOUND'
} as const;

export type RestResponseConfirmReceiptPaymentRestStatusStatusEnum = typeof RestResponseConfirmReceiptPaymentRestStatusStatusEnum[keyof typeof RestResponseConfirmReceiptPaymentRestStatusStatusEnum];

/**
 * 
 * @export
 * @interface RestResponseConfirmSendingPaymentRestStatus
 */
export interface RestResponseConfirmSendingPaymentRestStatus {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestResponseConfirmSendingPaymentRestStatus
     */
    'status': RestResponseConfirmSendingPaymentRestStatusStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestResponseConfirmSendingPaymentRestStatus
     */
    'message'?: string;
}

export const RestResponseConfirmSendingPaymentRestStatusStatusEnum = {
    Success: 'SUCCESS',
    TimeoutExpired: 'TIMEOUT_EXPIRED',
    AccessDeniedForBuyer: 'ACCESS_DENIED_FOR_BUYER',
    NotFound: 'NOT_FOUND'
} as const;

export type RestResponseConfirmSendingPaymentRestStatusStatusEnum = typeof RestResponseConfirmSendingPaymentRestStatusStatusEnum[keyof typeof RestResponseConfirmSendingPaymentRestStatusStatusEnum];

/**
 * 
 * @export
 * @interface RestResponseCreateOrderEventResponseStatus
 */
export interface RestResponseCreateOrderEventResponseStatus {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestResponseCreateOrderEventResponseStatus
     */
    'status': RestResponseCreateOrderEventResponseStatusStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestResponseCreateOrderEventResponseStatus
     */
    'message'?: string;
}

export const RestResponseCreateOrderEventResponseStatusStatusEnum = {
    Success: 'SUCCESS'
} as const;

export type RestResponseCreateOrderEventResponseStatusStatusEnum = typeof RestResponseCreateOrderEventResponseStatusStatusEnum[keyof typeof RestResponseCreateOrderEventResponseStatusStatusEnum];

/**
 * 
 * @export
 * @interface RestResponseDeactivateOfferRestStatus
 */
export interface RestResponseDeactivateOfferRestStatus {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestResponseDeactivateOfferRestStatus
     */
    'status': RestResponseDeactivateOfferRestStatusStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestResponseDeactivateOfferRestStatus
     */
    'message'?: string;
}

export const RestResponseDeactivateOfferRestStatusStatusEnum = {
    Success: 'SUCCESS',
    NotCompleted: 'NOT_COMPLETED',
    NotFound: 'NOT_FOUND',
    IncompleteAcceptedOrders: 'INCOMPLETE_ACCEPTED_ORDERS',
    AccessDenied: 'ACCESS_DENIED'
} as const;

export type RestResponseDeactivateOfferRestStatusStatusEnum = typeof RestResponseDeactivateOfferRestStatusStatusEnum[keyof typeof RestResponseDeactivateOfferRestStatusStatusEnum];

/**
 * 
 * @export
 * @interface RestResponseDeletePaymentDetailsBlacklistRestStatus
 */
export interface RestResponseDeletePaymentDetailsBlacklistRestStatus {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestResponseDeletePaymentDetailsBlacklistRestStatus
     */
    'status': RestResponseDeletePaymentDetailsBlacklistRestStatusStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestResponseDeletePaymentDetailsBlacklistRestStatus
     */
    'message'?: string;
}

export const RestResponseDeletePaymentDetailsBlacklistRestStatusStatusEnum = {
    Success: 'SUCCESS',
    NotFound: 'NOT_FOUND'
} as const;

export type RestResponseDeletePaymentDetailsBlacklistRestStatusStatusEnum = typeof RestResponseDeletePaymentDetailsBlacklistRestStatusStatusEnum[keyof typeof RestResponseDeletePaymentDetailsBlacklistRestStatusStatusEnum];

/**
 * 
 * @export
 * @interface RestResponseOpenAppealRestStatus
 */
export interface RestResponseOpenAppealRestStatus {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestResponseOpenAppealRestStatus
     */
    'status': RestResponseOpenAppealRestStatusStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestResponseOpenAppealRestStatus
     */
    'message'?: string;
}

export const RestResponseOpenAppealRestStatusStatusEnum = {
    Success: 'SUCCESS',
    AlreadyAppealed: 'ALREADY_APPEALED',
    OrderIllegalState: 'ORDER_ILLEGAL_STATE',
    NotFound: 'NOT_FOUND'
} as const;

export type RestResponseOpenAppealRestStatusStatusEnum = typeof RestResponseOpenAppealRestStatusStatusEnum[keyof typeof RestResponseOpenAppealRestStatusStatusEnum];

/**
 * 
 * @export
 * @interface RestResponseOpenChatRestStatus
 */
export interface RestResponseOpenChatRestStatus {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestResponseOpenChatRestStatus
     */
    'status': RestResponseOpenChatRestStatusStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestResponseOpenChatRestStatus
     */
    'message'?: string;
}

export const RestResponseOpenChatRestStatusStatusEnum = {
    Success: 'SUCCESS',
    IllegalRequest: 'ILLEGAL_REQUEST',
    AccessDeniedForBuyer: 'ACCESS_DENIED_FOR_BUYER',
    AccessDeniedForSeller: 'ACCESS_DENIED_FOR_SELLER'
} as const;

export type RestResponseOpenChatRestStatusStatusEnum = typeof RestResponseOpenChatRestStatusStatusEnum[keyof typeof RestResponseOpenChatRestStatusStatusEnum];

/**
 * 
 * @export
 * @interface RestResponseResolveAppealResponseStatus
 */
export interface RestResponseResolveAppealResponseStatus {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestResponseResolveAppealResponseStatus
     */
    'status': RestResponseResolveAppealResponseStatusStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestResponseResolveAppealResponseStatus
     */
    'message'?: string;
}

export const RestResponseResolveAppealResponseStatusStatusEnum = {
    Success: 'SUCCESS',
    NoActiveAppeal: 'NO_ACTIVE_APPEAL',
    OrderIllegalStateForResolution: 'ORDER_ILLEGAL_STATE_FOR_RESOLUTION',
    NoVolumeEnoughForRefund: 'NO_VOLUME_ENOUGH_FOR_REFUND'
} as const;

export type RestResponseResolveAppealResponseStatusStatusEnum = typeof RestResponseResolveAppealResponseStatusStatusEnum[keyof typeof RestResponseResolveAppealResponseStatusStatusEnum];

/**
 * 
 * @export
 * @interface RestResponseResolveAppealViaScriptResponseStatus
 */
export interface RestResponseResolveAppealViaScriptResponseStatus {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestResponseResolveAppealViaScriptResponseStatus
     */
    'status': RestResponseResolveAppealViaScriptResponseStatusStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestResponseResolveAppealViaScriptResponseStatus
     */
    'message'?: string;
}

export const RestResponseResolveAppealViaScriptResponseStatusStatusEnum = {
    Success: 'SUCCESS'
} as const;

export type RestResponseResolveAppealViaScriptResponseStatusStatusEnum = typeof RestResponseResolveAppealViaScriptResponseStatusStatusEnum[keyof typeof RestResponseResolveAppealViaScriptResponseStatusStatusEnum];

/**
 * 
 * @export
 * @interface RestResponseSetWebhookUrlStatus
 */
export interface RestResponseSetWebhookUrlStatus {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestResponseSetWebhookUrlStatus
     */
    'status': RestResponseSetWebhookUrlStatusStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestResponseSetWebhookUrlStatus
     */
    'message'?: string;
}

export const RestResponseSetWebhookUrlStatusStatusEnum = {
    Success: 'SUCCESS',
    Error: 'ERROR'
} as const;

export type RestResponseSetWebhookUrlStatusStatusEnum = typeof RestResponseSetWebhookUrlStatusStatusEnum[keyof typeof RestResponseSetWebhookUrlStatusStatusEnum];

/**
 * 
 * @export
 * @interface RestResponseTerminateApiKeyStatus
 */
export interface RestResponseTerminateApiKeyStatus {
    /**
     * Operation result status, always present
     * @type {string}
     * @memberof RestResponseTerminateApiKeyStatus
     */
    'status': RestResponseTerminateApiKeyStatusStatusEnum;
    /**
     * Verbose reason of non-success result
     * @type {string}
     * @memberof RestResponseTerminateApiKeyStatus
     */
    'message'?: string;
}

export const RestResponseTerminateApiKeyStatusStatusEnum = {
    Success: 'SUCCESS',
    Error: 'ERROR'
} as const;

export type RestResponseTerminateApiKeyStatusStatusEnum = typeof RestResponseTerminateApiKeyStatusStatusEnum[keyof typeof RestResponseTerminateApiKeyStatusStatusEnum];

/**
 * 
 * @export
 * @interface SbpBankRestDto
 */
export interface SbpBankRestDto {
    /**
     * 
     * @type {string}
     * @memberof SbpBankRestDto
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof SbpBankRestDto
     */
    'nameRu': string;
    /**
     * 
     * @type {string}
     * @memberof SbpBankRestDto
     */
    'nameEn': string;
}
/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface SellOfferInfoRestDto
 */
export interface SellOfferInfoRestDto {
    /**
     * 
     * @type {number}
     * @memberof SellOfferInfoRestDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SellOfferInfoRestDto
     */
    'number': string;
    /**
     * 
     * @type {number}
     * @memberof SellOfferInfoRestDto
     */
    'userId': number;
    /**
     * 
     * @type {UserStatisticsBackOfficeRestDto}
     * @memberof SellOfferInfoRestDto
     */
    'userStatistics': UserStatisticsBackOfficeRestDto;
    /**
     * 
     * @type {string}
     * @memberof SellOfferInfoRestDto
     */
    'type': SellOfferInfoRestDtoTypeEnum;
    /**
     * 
     * @type {MoneyAmountRestDto}
     * @memberof SellOfferInfoRestDto
     */
    'initVolume': MoneyAmountRestDto;
    /**
     * 
     * @type {MoneyAmountRestDto}
     * @memberof SellOfferInfoRestDto
     */
    'availableVolume': MoneyAmountRestDto;
    /**
     * 
     * @type {string}
     * @memberof SellOfferInfoRestDto
     */
    'orderAcceptTimeout': string;
    /**
     * 
     * @type {string}
     * @memberof SellOfferInfoRestDto
     */
    'paymentConfirmTimeout': string;
    /**
     * 
     * @type {UserPrivatePriceRestDto}
     * @memberof SellOfferInfoRestDto
     */
    'price': UserPrivatePriceRestDto;
    /**
     * 
     * @type {MoneyAmountLimitsInfoRestDto}
     * @memberof SellOfferInfoRestDto
     */
    'orderAmountLimits': MoneyAmountLimitsInfoRestDto;
    /**
     * 
     * @type {MoneyAmountLimitsInfoRestDto}
     * @memberof SellOfferInfoRestDto
     */
    'orderVolumeLimits'?: MoneyAmountLimitsInfoRestDto;
    /**
     * 
     * @type {string}
     * @memberof SellOfferInfoRestDto
     */
    'status': SellOfferInfoRestDtoStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof SellOfferInfoRestDto
     */
    'createDateTime': string;
    /**
     * 
     * @type {string}
     * @memberof SellOfferInfoRestDto
     */
    'comment'?: string;
    /**
     * 
     * @type {ChangeLogInfoRestDtoOfferStatus}
     * @memberof SellOfferInfoRestDto
     */
    'changeLog': ChangeLogInfoRestDtoOfferStatus;
    /**
     * 
     * @type {FeeRestDto}
     * @memberof SellOfferInfoRestDto
     */
    'fee': FeeRestDto;
    /**
     * 
     * @type {Array<PaymentDetailsInfoRestDto>}
     * @memberof SellOfferInfoRestDto
     */
    'paymentDetails': Array<PaymentDetailsInfoRestDto>;
}

export const SellOfferInfoRestDtoTypeEnum = {
    Sale: 'SALE',
    Purchase: 'PURCHASE'
} as const;

export type SellOfferInfoRestDtoTypeEnum = typeof SellOfferInfoRestDtoTypeEnum[keyof typeof SellOfferInfoRestDtoTypeEnum];
export const SellOfferInfoRestDtoStatusEnum = {
    Inactive: 'INACTIVE',
    Activating: 'ACTIVATING',
    Active: 'ACTIVE',
    Deactivating: 'DEACTIVATING',
    Killed: 'KILLED',
    Deleted: 'DELETED',
    Updating: 'UPDATING'
} as const;

export type SellOfferInfoRestDtoStatusEnum = typeof SellOfferInfoRestDtoStatusEnum[keyof typeof SellOfferInfoRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface SellOfferRestDto
 */
export interface SellOfferRestDto extends BaseOfferRestDto {
    /**
     * 
     * @type {Array<PaymentDetailsRestDto>}
     * @memberof SellOfferRestDto
     */
    'paymentDetails': Array<PaymentDetailsRestDto>;
    /**
     * 
     * @type {FeeRestDto}
     * @memberof SellOfferRestDto
     */
    'fee': FeeRestDto;
}


/**
 * 
 * @export
 * @interface SellOfferRestDtoAllOf
 */
export interface SellOfferRestDtoAllOf {
    /**
     * 
     * @type {Array<PaymentDetailsRestDto>}
     * @memberof SellOfferRestDtoAllOf
     */
    'paymentDetails'?: Array<PaymentDetailsRestDto>;
    /**
     * 
     * @type {FeeRestDto}
     * @memberof SellOfferRestDtoAllOf
     */
    'fee'?: FeeRestDto;
}
/**
 * 
 * @export
 * @interface SendAttachmentRestRequest
 */
export interface SendAttachmentRestRequest {
    /**
     * 
     * @type {number}
     * @memberof SendAttachmentRestRequest
     */
    'orderId': number;
    /**
     * 
     * @type {number}
     * @memberof SendAttachmentRestRequest
     */
    'senderUserId': number;
    /**
     * 
     * @type {string}
     * @memberof SendAttachmentRestRequest
     */
    'idempotencyKey': string;
    /**
     * 
     * @type {string}
     * @memberof SendAttachmentRestRequest
     */
    'sentBySenderUserDateTime': string;
    /**
     * 
     * @type {string}
     * @memberof SendAttachmentRestRequest
     */
    'sentBySenderBotDateTime': string;
    /**
     * 
     * @type {Photo}
     * @memberof SendAttachmentRestRequest
     */
    'photo'?: Photo | null;
    /**
     * 
     * @type {Document}
     * @memberof SendAttachmentRestRequest
     */
    'document'?: Document | null;
    /**
     * 
     * @type {string}
     * @memberof SendAttachmentRestRequest
     */
    'caption'?: string | null;
}
/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface SendAttachmentRestResponse
 */
export interface SendAttachmentRestResponse {
    /**
     * 
     * @type {string}
     * @memberof SendAttachmentRestResponse
     */
    'localizedNotificationToSender': string;
    /**
     * 
     * @type {Array<ButtonRow>}
     * @memberof SendAttachmentRestResponse
     */
    'buttonRows': Array<ButtonRow>;
}
/**
 * 
 * @export
 * @interface SendMessageRestRequest
 */
export interface SendMessageRestRequest {
    /**
     * 
     * @type {number}
     * @memberof SendMessageRestRequest
     */
    'orderId': number;
    /**
     * 
     * @type {number}
     * @memberof SendMessageRestRequest
     */
    'senderUserId': number;
    /**
     * 
     * @type {string}
     * @memberof SendMessageRestRequest
     */
    'idempotencyKey': string;
    /**
     * 
     * @type {string}
     * @memberof SendMessageRestRequest
     */
    'sentBySenderUserDateTime': string;
    /**
     * 
     * @type {string}
     * @memberof SendMessageRestRequest
     */
    'sentBySenderBotDateTime': string;
    /**
     * 
     * @type {string}
     * @memberof SendMessageRestRequest
     */
    'message': string;
}
/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface SendMessageRestResponse
 */
export interface SendMessageRestResponse {
    /**
     * 
     * @type {string}
     * @memberof SendMessageRestResponse
     */
    'localizedNotificationToSender': string;
    /**
     * 
     * @type {Array<ButtonRow>}
     * @memberof SendMessageRestResponse
     */
    'buttonRows': Array<ButtonRow>;
}
/**
 * 
 * @export
 * @interface SetWebhookUrlRequest
 */
export interface SetWebhookUrlRequest {
    /**
     * 
     * @type {number}
     * @memberof SetWebhookUrlRequest
     */
    'userId': number;
    /**
     * 
     * @type {string}
     * @memberof SetWebhookUrlRequest
     */
    'webhookUrl': string;
}
/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface SettingsRestDto
 */
export interface SettingsRestDto {
    /**
     * 
     * @type {OfferSettingsRestDto}
     * @memberof SettingsRestDto
     */
    'offerSettings': OfferSettingsRestDto;
    /**
     * 
     * @type {OrderSettingsRestDto}
     * @memberof SettingsRestDto
     */
    'orderSettings': OrderSettingsRestDto;
    /**
     * 
     * @type {FeeSettings}
     * @memberof SettingsRestDto
     */
    'fee': FeeSettings;
    /**
     * 
     * @type {CurrencySettingsRestDto}
     * @memberof SettingsRestDto
     */
    'currencySettings': CurrencySettingsRestDto;
}
/**
 * 
 * @export
 * @interface Str
 */
export interface Str extends AttributeValueRestDto {
    /**
     * 
     * @type {string}
     * @memberof Str
     */
    'value': string;
}


/**
 * 
 * @export
 * @interface StrAllOf
 */
export interface StrAllOf {
    /**
     * 
     * @type {string}
     * @memberof StrAllOf
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface TerminateApiKeyRequest
 */
export interface TerminateApiKeyRequest {
    /**
     * 
     * @type {number}
     * @memberof TerminateApiKeyRequest
     */
    'userId': number;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'nickname': string;
    /**
     * 
     * @type {UserStatistics}
     * @memberof User
     */
    'statistics': UserStatistics;
}
/**
 * 
 * @export
 * @interface UserIdRestRequest
 */
export interface UserIdRestRequest {
    /**
     * 
     * @type {number}
     * @memberof UserIdRestRequest
     */
    'userId': number;
}
/**
 * 
 * @export
 * @interface UserOrderHistoryRequest
 */
export interface UserOrderHistoryRequest {
    /**
     * 
     * @type {number}
     * @memberof UserOrderHistoryRequest
     */
    'offset': number;
    /**
     * 
     * @type {number}
     * @memberof UserOrderHistoryRequest
     */
    'limit': number;
    /**
     * 
     * @type {Filter}
     * @memberof UserOrderHistoryRequest
     */
    'filter'?: Filter;
}
/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface UserPrivateBaseOfferRestDto
 */
export interface UserPrivateBaseOfferRestDto {
    /**
     * 
     * @type {number}
     * @memberof UserPrivateBaseOfferRestDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof UserPrivateBaseOfferRestDto
     */
    'number': string;
    /**
     * 
     * @type {UserRestDto}
     * @memberof UserPrivateBaseOfferRestDto
     */
    'user': UserRestDto;
    /**
     * 
     * @type {string}
     * @memberof UserPrivateBaseOfferRestDto
     */
    'type': UserPrivateBaseOfferRestDtoTypeEnum;
    /**
     * 
     * @type {MoneyAmountRestDto}
     * @memberof UserPrivateBaseOfferRestDto
     */
    'initVolume': MoneyAmountRestDto;
    /**
     * 
     * @type {MoneyAmountRestDto}
     * @memberof UserPrivateBaseOfferRestDto
     */
    'availableVolume': MoneyAmountRestDto;
    /**
     * 
     * @type {string}
     * @memberof UserPrivateBaseOfferRestDto
     */
    'paymentConfirmTimeout': string;
    /**
     * 
     * @type {UserPrivatePriceRestDto}
     * @memberof UserPrivateBaseOfferRestDto
     */
    'price': UserPrivatePriceRestDto;
    /**
     * 
     * @type {MoneyAmountLimitsRestDto}
     * @memberof UserPrivateBaseOfferRestDto
     */
    'orderAmountLimits': MoneyAmountLimitsRestDto;
    /**
     * 
     * @type {MoneyAmountLimitsRestDto}
     * @memberof UserPrivateBaseOfferRestDto
     */
    'orderVolumeLimits'?: MoneyAmountLimitsRestDto;
    /**
     * 
     * @type {string}
     * @memberof UserPrivateBaseOfferRestDto
     */
    'status': UserPrivateBaseOfferRestDtoStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UserPrivateBaseOfferRestDto
     */
    'createDateTime': string;
    /**
     * 
     * @type {string}
     * @memberof UserPrivateBaseOfferRestDto
     */
    'comment'?: string;
    /**
     * 
     * @type {ChangeLogRestDtoOfferStatus}
     * @memberof UserPrivateBaseOfferRestDto
     */
    'changeLog': ChangeLogRestDtoOfferStatus;
}

export const UserPrivateBaseOfferRestDtoTypeEnum = {
    Sale: 'SALE',
    Purchase: 'PURCHASE'
} as const;

export type UserPrivateBaseOfferRestDtoTypeEnum = typeof UserPrivateBaseOfferRestDtoTypeEnum[keyof typeof UserPrivateBaseOfferRestDtoTypeEnum];
export const UserPrivateBaseOfferRestDtoStatusEnum = {
    Inactive: 'INACTIVE',
    Activating: 'ACTIVATING',
    Active: 'ACTIVE',
    Deactivating: 'DEACTIVATING',
    Killed: 'KILLED',
    Deleted: 'DELETED',
    Updating: 'UPDATING'
} as const;

export type UserPrivateBaseOfferRestDtoStatusEnum = typeof UserPrivateBaseOfferRestDtoStatusEnum[keyof typeof UserPrivateBaseOfferRestDtoStatusEnum];

/**
 * 
 * @export
 * @interface UserPrivateBuyOfferRestDto
 */
export interface UserPrivateBuyOfferRestDto extends UserPrivateBaseOfferRestDto {
    /**
     * 
     * @type {Array<PaymentMethodRestDto>}
     * @memberof UserPrivateBuyOfferRestDto
     */
    'paymentMethods': Array<PaymentMethodRestDto>;
}


/**
 * 
 * @export
 * @interface UserPrivateMyBuyOffersListRestDto
 */
export interface UserPrivateMyBuyOffersListRestDto extends UserPrivateMyOffersListRestDto {
    /**
     * 
     * @type {Array<PaymentMethodRestDto>}
     * @memberof UserPrivateMyBuyOffersListRestDto
     */
    'paymentMethods': Array<PaymentMethodRestDto>;
}


/**
 * 
 * @export
 * @interface UserPrivateMyBuyOffersListRestDtoAllOf
 */
export interface UserPrivateMyBuyOffersListRestDtoAllOf {
    /**
     * 
     * @type {Array<PaymentMethodRestDto>}
     * @memberof UserPrivateMyBuyOffersListRestDtoAllOf
     */
    'paymentMethods'?: Array<PaymentMethodRestDto>;
}
/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface UserPrivateMyOffersListRestDto
 */
export interface UserPrivateMyOffersListRestDto {
    /**
     * 
     * @type {number}
     * @memberof UserPrivateMyOffersListRestDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof UserPrivateMyOffersListRestDto
     */
    'number': string;
    /**
     * 
     * @type {string}
     * @memberof UserPrivateMyOffersListRestDto
     */
    'status': UserPrivateMyOffersListRestDtoStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UserPrivateMyOffersListRestDto
     */
    'type': UserPrivateMyOffersListRestDtoTypeEnum;
    /**
     * 
     * @type {UserPrivatePriceRestDto}
     * @memberof UserPrivateMyOffersListRestDto
     */
    'price': UserPrivatePriceRestDto;
    /**
     * 
     * @type {MoneyAmountRestDto}
     * @memberof UserPrivateMyOffersListRestDto
     */
    'availableVolume': MoneyAmountRestDto;
    /**
     * 
     * @type {MoneyAmountLimitsRestDto}
     * @memberof UserPrivateMyOffersListRestDto
     */
    'orderAmountLimits': MoneyAmountLimitsRestDto;
    /**
     * 
     * @type {MoneyAmountLimitsRestDto}
     * @memberof UserPrivateMyOffersListRestDto
     */
    'orderVolumeLimits'?: MoneyAmountLimitsRestDto;
}

export const UserPrivateMyOffersListRestDtoStatusEnum = {
    Inactive: 'INACTIVE',
    Activating: 'ACTIVATING',
    Active: 'ACTIVE',
    Deactivating: 'DEACTIVATING',
    Killed: 'KILLED',
    Deleted: 'DELETED',
    Updating: 'UPDATING'
} as const;

export type UserPrivateMyOffersListRestDtoStatusEnum = typeof UserPrivateMyOffersListRestDtoStatusEnum[keyof typeof UserPrivateMyOffersListRestDtoStatusEnum];
export const UserPrivateMyOffersListRestDtoTypeEnum = {
    Sale: 'SALE',
    Purchase: 'PURCHASE'
} as const;

export type UserPrivateMyOffersListRestDtoTypeEnum = typeof UserPrivateMyOffersListRestDtoTypeEnum[keyof typeof UserPrivateMyOffersListRestDtoTypeEnum];

/**
 * 
 * @export
 * @interface UserPrivateMySellOffersListRestDto
 */
export interface UserPrivateMySellOffersListRestDto extends UserPrivateMyOffersListRestDto {
    /**
     * 
     * @type {Array<PaymentDetailsRestDto>}
     * @memberof UserPrivateMySellOffersListRestDto
     */
    'paymentDetails': Array<PaymentDetailsRestDto>;
}


/**
 * 
 * @export
 * @interface UserPrivateMySellOffersListRestDtoAllOf
 */
export interface UserPrivateMySellOffersListRestDtoAllOf {
    /**
     * 
     * @type {Array<PaymentDetailsRestDto>}
     * @memberof UserPrivateMySellOffersListRestDtoAllOf
     */
    'paymentDetails'?: Array<PaymentDetailsRestDto>;
}
/**
 * 
 * @export
 * @interface UserPrivatePriceRestDto
 */
export interface UserPrivatePriceRestDto {
    /**
     * 
     * @type {string}
     * @memberof UserPrivatePriceRestDto
     */
    'type': UserPrivatePriceRestDtoTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof UserPrivatePriceRestDto
     */
    'baseCurrencyCode': string;
    /**
     * 
     * @type {string}
     * @memberof UserPrivatePriceRestDto
     */
    'quoteCurrencyCode': string;
    /**
     * 
     * @type {string}
     * @memberof UserPrivatePriceRestDto
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof UserPrivatePriceRestDto
     */
    'estimated'?: string;
}

export const UserPrivatePriceRestDtoTypeEnum = {
    Fixed: 'FIXED',
    Floating: 'FLOATING'
} as const;

export type UserPrivatePriceRestDtoTypeEnum = typeof UserPrivatePriceRestDtoTypeEnum[keyof typeof UserPrivatePriceRestDtoTypeEnum];

/**
 * 
 * @export
 * @interface UserPrivateSellOfferRestDto
 */
export interface UserPrivateSellOfferRestDto extends UserPrivateBaseOfferRestDto {
    /**
     * 
     * @type {string}
     * @memberof UserPrivateSellOfferRestDto
     */
    'orderConfirmationTimeout': string;
    /**
     * 
     * @type {string}
     * @memberof UserPrivateSellOfferRestDto
     */
    'orderAcceptTimeout': string;
    /**
     * 
     * @type {Array<PaymentDetailsRestDto>}
     * @memberof UserPrivateSellOfferRestDto
     */
    'paymentDetails': Array<PaymentDetailsRestDto>;
    /**
     * 
     * @type {FeeRestDto}
     * @memberof UserPrivateSellOfferRestDto
     */
    'fee': FeeRestDto;
}


/**
 * 
 * @export
 * @interface UserPrivateSellOfferRestDtoAllOf
 */
export interface UserPrivateSellOfferRestDtoAllOf {
    /**
     * 
     * @type {string}
     * @memberof UserPrivateSellOfferRestDtoAllOf
     */
    'orderConfirmationTimeout'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserPrivateSellOfferRestDtoAllOf
     */
    'orderAcceptTimeout'?: string;
    /**
     * 
     * @type {Array<PaymentDetailsRestDto>}
     * @memberof UserPrivateSellOfferRestDtoAllOf
     */
    'paymentDetails'?: Array<PaymentDetailsRestDto>;
    /**
     * 
     * @type {FeeRestDto}
     * @memberof UserPrivateSellOfferRestDtoAllOf
     */
    'fee'?: FeeRestDto;
}
/**
 * 
 * @export
 * @interface UserRestDto
 */
export interface UserRestDto {
    /**
     * 
     * @type {number}
     * @memberof UserRestDto
     */
    'userId': number;
    /**
     * 
     * @type {string}
     * @memberof UserRestDto
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRestDto
     */
    'avatarCode'?: string;
    /**
     * 
     * @type {UserStatisticsRestDto}
     * @memberof UserRestDto
     */
    'statistics': UserStatisticsRestDto;
    /**
     * 
     * @type {boolean}
     * @memberof UserRestDto
     */
    'isVerified': boolean;
}
/**
 * 
 * @export
 * @interface UserStatistics
 */
export interface UserStatistics {
    /**
     * 
     * @type {number}
     * @memberof UserStatistics
     */
    'totalOrdersCount': number;
    /**
     * 
     * @type {number}
     * @memberof UserStatistics
     */
    'successPercent': number;
}
/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface UserStatisticsBackOfficeRestDto
 */
export interface UserStatisticsBackOfficeRestDto {
    /**
     * 
     * @type {number}
     * @memberof UserStatisticsBackOfficeRestDto
     */
    'userId': number;
    /**
     * 
     * @type {number}
     * @memberof UserStatisticsBackOfficeRestDto
     */
    'totalOrdersCount': number;
    /**
     * 
     * @type {string}
     * @memberof UserStatisticsBackOfficeRestDto
     */
    'successRate': string;
}
/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface UserStatisticsRestDto
 */
export interface UserStatisticsRestDto {
    /**
     * 
     * @type {number}
     * @memberof UserStatisticsRestDto
     */
    'userId': number;
    /**
     * 
     * @type {number}
     * @memberof UserStatisticsRestDto
     */
    'totalOrdersCount': number;
    /**
     * 
     * @type {string}
     * @memberof UserStatisticsRestDto
     */
    'successRate': string;
    /**
     * 
     * @type {number}
     * @memberof UserStatisticsRestDto
     */
    'successPercent': number;
}
/**
 * 
 * @export
 * @interface ValidationRuleRestDto
 */
export interface ValidationRuleRestDto {
    /**
     * 
     * @type {string}
     * @memberof ValidationRuleRestDto
     */
    'type': string;
}

/**
 * AntifraudApi - axios parameter creator
 * @export
 */
export const AntifraudApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Проверить пользователя на антифрод перед заполнением формы создания сделки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUserV2: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/p2p/public-api/v2/antifraud/check-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disable antifraud rule for user
         * @param {DisableAntifraudRestRequest} disableAntifraudRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableAntifraud1: async (disableAntifraudRestRequest: DisableAntifraudRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'disableAntifraudRestRequest' is not null or undefined
            assertParamExists('disableAntifraud1', 'disableAntifraudRestRequest', disableAntifraudRestRequest)
            const localVarPath = `/p2p/internal-api/v2/antifraud/disable-rule-for-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(disableAntifraudRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение последних результатов проверки антифрода для пользователя. Используется для тестов
         * @param {UserIdRestRequest} userIdRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCheckResultsForUser: async (userIdRestRequest: UserIdRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userIdRestRequest' is not null or undefined
            assertParamExists('getAllCheckResultsForUser', 'userIdRestRequest', userIdRestRequest)
            const localVarPath = `/p2p/internal-api/v1/antifraud/get-all-check-results-for-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userIdRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AntifraudApi - functional programming interface
 * @export
 */
export const AntifraudApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AntifraudApiAxiosParamCreator(configuration)
    return {
        /**
         * Проверить пользователя на антифрод перед заполнением формы создания сделки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkUserV2(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseCheckUserResponseStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkUserV2(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Disable antifraud rule for user
         * @param {DisableAntifraudRestRequest} disableAntifraudRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableAntifraud1(disableAntifraudRestRequest: DisableAntifraudRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseDisableAntifraudRestStatusDisableAntifraudRestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableAntifraud1(disableAntifraudRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Получение последних результатов проверки антифрода для пользователя. Используется для тестов
         * @param {UserIdRestRequest} userIdRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCheckResultsForUser(userIdRestRequest: UserIdRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseAntifraudLastResultRestStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllCheckResultsForUser(userIdRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AntifraudApi - factory interface
 * @export
 */
export const AntifraudApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AntifraudApiFp(configuration)
    return {
        /**
         * Проверить пользователя на антифрод перед заполнением формы создания сделки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUserV2(options?: any): AxiosPromise<RestResponseCheckUserResponseStatus> {
            return localVarFp.checkUserV2(options).then((request) => request(axios, basePath));
        },
        /**
         * Disable antifraud rule for user
         * @param {DisableAntifraudRestRequest} disableAntifraudRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableAntifraud1(disableAntifraudRestRequest: DisableAntifraudRestRequest, options?: any): AxiosPromise<RestDataResponseDisableAntifraudRestStatusDisableAntifraudRestResponse> {
            return localVarFp.disableAntifraud1(disableAntifraudRestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Получение последних результатов проверки антифрода для пользователя. Используется для тестов
         * @param {UserIdRestRequest} userIdRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCheckResultsForUser(userIdRestRequest: UserIdRestRequest, options?: any): AxiosPromise<RestResponseAntifraudLastResultRestStatus> {
            return localVarFp.getAllCheckResultsForUser(userIdRestRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AntifraudApi - object-oriented interface
 * @export
 * @class AntifraudApi
 * @extends {BaseAPI}
 */
export class AntifraudApi extends BaseAPI {
    /**
     * Проверить пользователя на антифрод перед заполнением формы создания сделки
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AntifraudApi
     */
    public checkUserV2(options?: AxiosRequestConfig) {
        return AntifraudApiFp(this.configuration).checkUserV2(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disable antifraud rule for user
     * @param {DisableAntifraudRestRequest} disableAntifraudRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AntifraudApi
     */
    public disableAntifraud1(disableAntifraudRestRequest: DisableAntifraudRestRequest, options?: AxiosRequestConfig) {
        return AntifraudApiFp(this.configuration).disableAntifraud1(disableAntifraudRestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение последних результатов проверки антифрода для пользователя. Используется для тестов
     * @param {UserIdRestRequest} userIdRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AntifraudApi
     */
    public getAllCheckResultsForUser(userIdRestRequest: UserIdRestRequest, options?: AxiosRequestConfig) {
        return AntifraudApiFp(this.configuration).getAllCheckResultsForUser(userIdRestRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AppealApi - axios parameter creator
 * @export
 */
export const AppealApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {OpenAppealRestRequest} openAppealRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openAppealV2: async (openAppealRestRequest: OpenAppealRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'openAppealRestRequest' is not null or undefined
            assertParamExists('openAppealV2', 'openAppealRestRequest', openAppealRestRequest)
            const localVarPath = `/p2p/public-api/v2/offer/order/appeal/open`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(openAppealRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppealApi - functional programming interface
 * @export
 */
export const AppealApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AppealApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {OpenAppealRestRequest} openAppealRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async openAppealV2(openAppealRestRequest: OpenAppealRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseOpenAppealRestStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.openAppealV2(openAppealRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AppealApi - factory interface
 * @export
 */
export const AppealApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AppealApiFp(configuration)
    return {
        /**
         * 
         * @param {OpenAppealRestRequest} openAppealRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openAppealV2(openAppealRestRequest: OpenAppealRestRequest, options?: any): AxiosPromise<RestResponseOpenAppealRestStatus> {
            return localVarFp.openAppealV2(openAppealRestRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AppealApi - object-oriented interface
 * @export
 * @class AppealApi
 * @extends {BaseAPI}
 */
export class AppealApi extends BaseAPI {
    /**
     * 
     * @param {OpenAppealRestRequest} openAppealRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppealApi
     */
    public openAppealV2(openAppealRestRequest: OpenAppealRestRequest, options?: AxiosRequestConfig) {
        return AppealApiFp(this.configuration).openAppealV2(openAppealRestRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApplicationRestApi - axios parameter creator
 * @export
 */
export const ApplicationRestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/p2p/internal-api/v1/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationRestApi - functional programming interface
 * @export
 */
export const ApplicationRestApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationRestApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatus(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationRestApi - factory interface
 * @export
 */
export const ApplicationRestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationRestApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(options?: any): AxiosPromise<ApplicationInfo> {
            return localVarFp.getStatus(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationRestApi - object-oriented interface
 * @export
 * @class ApplicationRestApi
 * @extends {BaseAPI}
 */
export class ApplicationRestApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationRestApi
     */
    public getStatus(options?: AxiosRequestConfig) {
        return ApplicationRestApiFp(this.configuration).getStatus(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BackofficeApi - axios parameter creator
 * @export
 */
export const BackofficeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create order appeal resolved event
         * @param {CreateOrderAppealResolvedEventRestRequest} createOrderAppealResolvedEventRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderAppealResolvedEventV2: async (createOrderAppealResolvedEventRestRequest: CreateOrderAppealResolvedEventRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOrderAppealResolvedEventRestRequest' is not null or undefined
            assertParamExists('createOrderAppealResolvedEventV2', 'createOrderAppealResolvedEventRestRequest', createOrderAppealResolvedEventRestRequest)
            const localVarPath = `/p2p/internal-api/v2/offer/order/appeal/create-resolved-event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrderAppealResolvedEventRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add payment details to blacklist
         * @param {CreatePaymentDetailsBlacklistRestRequest} createPaymentDetailsBlacklistRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentDetailsBlacklistV2: async (createPaymentDetailsBlacklistRestRequest: CreatePaymentDetailsBlacklistRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPaymentDetailsBlacklistRestRequest' is not null or undefined
            assertParamExists('createPaymentDetailsBlacklistV2', 'createPaymentDetailsBlacklistRestRequest', createPaymentDetailsBlacklistRestRequest)
            const localVarPath = `/p2p/internal-api/v2/blacklist/payment-details/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPaymentDetailsBlacklistRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete payment details from blacklist
         * @param {DeletePaymentDetailsBlacklistRestRequest} deletePaymentDetailsBlacklistRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentDetailsBlacklistV2: async (deletePaymentDetailsBlacklistRestRequest: DeletePaymentDetailsBlacklistRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deletePaymentDetailsBlacklistRestRequest' is not null or undefined
            assertParamExists('deletePaymentDetailsBlacklistV2', 'deletePaymentDetailsBlacklistRestRequest', deletePaymentDetailsBlacklistRestRequest)
            const localVarPath = `/p2p/internal-api/v2/blacklist/payment-details/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deletePaymentDetailsBlacklistRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit payment details in blacklist
         * @param {EditPaymentDetailsBlacklistRestRequest} editPaymentDetailsBlacklistRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editPaymentDetailsBlacklistV2: async (editPaymentDetailsBlacklistRestRequest: EditPaymentDetailsBlacklistRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'editPaymentDetailsBlacklistRestRequest' is not null or undefined
            assertParamExists('editPaymentDetailsBlacklistV2', 'editPaymentDetailsBlacklistRestRequest', editPaymentDetailsBlacklistRestRequest)
            const localVarPath = `/p2p/internal-api/v2/blacklist/payment-details/edit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editPaymentDetailsBlacklistRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about buy offer
         * @param {number} offerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuyOfferInformationV2: async (offerId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'offerId' is not null or undefined
            assertParamExists('getBuyOfferInformationV2', 'offerId', offerId)
            const localVarPath = `/p2p/internal-api/v2/offer/buy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offerId !== undefined) {
                localVarQueryParameter['offerId'] = offerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about order with it\'s payment details, appeals and chat history
         * @param {number} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderInformationV2: async (orderId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('getOrderInformationV2', 'orderId', orderId)
            const localVarPath = `/p2p/internal-api/v2/offer/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get payment details blacklist
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentDetailsBlacklistV2: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPaymentDetailsBlacklistV2', 'id', id)
            const localVarPath = `/p2p/internal-api/v2/blacklist/payment-details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about sell offer
         * @param {number} offerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSellOfferInformationV2: async (offerId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'offerId' is not null or undefined
            assertParamExists('getSellOfferInformationV2', 'offerId', offerId)
            const localVarPath = `/p2p/internal-api/v2/offer/sell`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offerId !== undefined) {
                localVarQueryParameter['offerId'] = offerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user statistics
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserStatisticsV21: async (userId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserStatisticsV21', 'userId', userId)
            const localVarPath = `/p2p/internal-api/v2/user/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List orders with filters sorted by accepted datetime. Unaccepted orders are additionally sorted by created datetime with same sort order. Default sort order is DESC (newest first).
         * @param {ListOrdersRestRequest} listOrdersRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrdersFilteredSortedV2: async (listOrdersRestRequest: ListOrdersRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listOrdersRestRequest' is not null or undefined
            assertParamExists('listOrdersFilteredSortedV2', 'listOrdersRestRequest', listOrdersRestRequest)
            const localVarPath = `/p2p/internal-api/v2/offer/order/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listOrdersRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List orders with unresolved appeal with optional filters and optional sorting
         * @param {ListOrdersWithActiveAppealRestRequest} listOrdersWithActiveAppealRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrdersWithActiveAppealFilteredSortedV2: async (listOrdersWithActiveAppealRestRequest: ListOrdersWithActiveAppealRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listOrdersWithActiveAppealRestRequest' is not null or undefined
            assertParamExists('listOrdersWithActiveAppealFilteredSortedV2', 'listOrdersWithActiveAppealRestRequest', listOrdersWithActiveAppealRestRequest)
            const localVarPath = `/p2p/internal-api/v2/offer/order/list-with-active-appeal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listOrdersWithActiveAppealRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find payment details blacklist by filter
         * @param {ListPaymentDetailsBlacklistRestRequest} listPaymentDetailsBlacklistRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPaymentDetailsBlacklistV2: async (listPaymentDetailsBlacklistRestRequest: ListPaymentDetailsBlacklistRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listPaymentDetailsBlacklistRestRequest' is not null or undefined
            assertParamExists('listPaymentDetailsBlacklistV2', 'listPaymentDetailsBlacklistRestRequest', listPaymentDetailsBlacklistRestRequest)
            const localVarPath = `/p2p/internal-api/v2/blacklist/payment-details/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listPaymentDetailsBlacklistRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resolve order appeal
         * @param {ResolveAppealRestRequest} resolveAppealRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveOrderAppealV2: async (resolveAppealRestRequest: ResolveAppealRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resolveAppealRestRequest' is not null or undefined
            assertParamExists('resolveOrderAppealV2', 'resolveAppealRestRequest', resolveAppealRestRequest)
            const localVarPath = `/p2p/internal-api/v2/offer/order/appeal/close`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resolveAppealRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resolve order appeal via script
         * @param {ResolveAppealViaScriptRestRequest} resolveAppealViaScriptRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveOrderAppealViaScriptV2: async (resolveAppealViaScriptRestRequest: ResolveAppealViaScriptRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resolveAppealViaScriptRestRequest' is not null or undefined
            assertParamExists('resolveOrderAppealViaScriptV2', 'resolveAppealViaScriptRestRequest', resolveAppealViaScriptRestRequest)
            const localVarPath = `/p2p/internal-api/v2/offer/order/appeal/resolve`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resolveAppealViaScriptRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BackofficeApi - functional programming interface
 * @export
 */
export const BackofficeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BackofficeApiAxiosParamCreator(configuration)
    return {
        /**
         * Create order appeal resolved event
         * @param {CreateOrderAppealResolvedEventRestRequest} createOrderAppealResolvedEventRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrderAppealResolvedEventV2(createOrderAppealResolvedEventRestRequest: CreateOrderAppealResolvedEventRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseCreateOrderEventResponseStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrderAppealResolvedEventV2(createOrderAppealResolvedEventRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add payment details to blacklist
         * @param {CreatePaymentDetailsBlacklistRestRequest} createPaymentDetailsBlacklistRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPaymentDetailsBlacklistV2(createPaymentDetailsBlacklistRestRequest: CreatePaymentDetailsBlacklistRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseCreatePaymentDetailsBlacklistRestStatusPaymentDetailsBlacklistInfoRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPaymentDetailsBlacklistV2(createPaymentDetailsBlacklistRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete payment details from blacklist
         * @param {DeletePaymentDetailsBlacklistRestRequest} deletePaymentDetailsBlacklistRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePaymentDetailsBlacklistV2(deletePaymentDetailsBlacklistRestRequest: DeletePaymentDetailsBlacklistRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseDeletePaymentDetailsBlacklistRestStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePaymentDetailsBlacklistV2(deletePaymentDetailsBlacklistRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit payment details in blacklist
         * @param {EditPaymentDetailsBlacklistRestRequest} editPaymentDetailsBlacklistRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editPaymentDetailsBlacklistV2(editPaymentDetailsBlacklistRestRequest: EditPaymentDetailsBlacklistRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseEditPaymentDetailsBlacklistRestStatusPaymentDetailsBlacklistInfoRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editPaymentDetailsBlacklistV2(editPaymentDetailsBlacklistRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get information about buy offer
         * @param {number} offerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBuyOfferInformationV2(offerId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseGetInfoRestStatusBuyOfferInfoRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBuyOfferInformationV2(offerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get information about order with it\'s payment details, appeals and chat history
         * @param {number} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderInformationV2(orderId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseGetInfoRestStatusOrderInfoRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderInformationV2(orderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get payment details blacklist
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentDetailsBlacklistV2(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseGetPaymentDetailsBlacklistRestStatusPaymentDetailsBlacklistInfoRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentDetailsBlacklistV2(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get information about sell offer
         * @param {number} offerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSellOfferInformationV2(offerId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseGetInfoRestStatusSellOfferInfoRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSellOfferInformationV2(offerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get user statistics
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserStatisticsV21(userId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseGetUserStatisticsResponseStatusUserStatisticsBackOfficeRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserStatisticsV21(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List orders with filters sorted by accepted datetime. Unaccepted orders are additionally sorted by created datetime with same sort order. Default sort order is DESC (newest first).
         * @param {ListOrdersRestRequest} listOrdersRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrdersFilteredSortedV2(listOrdersRestRequest: ListOrdersRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseListOrderViewRestStatusListListOrderViewRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrdersFilteredSortedV2(listOrdersRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List orders with unresolved appeal with optional filters and optional sorting
         * @param {ListOrdersWithActiveAppealRestRequest} listOrdersWithActiveAppealRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrdersWithActiveAppealFilteredSortedV2(listOrdersWithActiveAppealRestRequest: ListOrdersWithActiveAppealRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseListOrderViewRestStatusListListOrderViewWithActiveAppealRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrdersWithActiveAppealFilteredSortedV2(listOrdersWithActiveAppealRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Find payment details blacklist by filter
         * @param {ListPaymentDetailsBlacklistRestRequest} listPaymentDetailsBlacklistRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPaymentDetailsBlacklistV2(listPaymentDetailsBlacklistRestRequest: ListPaymentDetailsBlacklistRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseListPaymentDetailsBlacklistRestStatusListPaymentDetailsBlacklistInfoRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPaymentDetailsBlacklistV2(listPaymentDetailsBlacklistRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Resolve order appeal
         * @param {ResolveAppealRestRequest} resolveAppealRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resolveOrderAppealV2(resolveAppealRestRequest: ResolveAppealRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseResolveAppealResponseStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resolveOrderAppealV2(resolveAppealRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Resolve order appeal via script
         * @param {ResolveAppealViaScriptRestRequest} resolveAppealViaScriptRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resolveOrderAppealViaScriptV2(resolveAppealViaScriptRestRequest: ResolveAppealViaScriptRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseResolveAppealViaScriptResponseStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resolveOrderAppealViaScriptV2(resolveAppealViaScriptRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BackofficeApi - factory interface
 * @export
 */
export const BackofficeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BackofficeApiFp(configuration)
    return {
        /**
         * Create order appeal resolved event
         * @param {CreateOrderAppealResolvedEventRestRequest} createOrderAppealResolvedEventRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderAppealResolvedEventV2(createOrderAppealResolvedEventRestRequest: CreateOrderAppealResolvedEventRestRequest, options?: any): AxiosPromise<RestResponseCreateOrderEventResponseStatus> {
            return localVarFp.createOrderAppealResolvedEventV2(createOrderAppealResolvedEventRestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Add payment details to blacklist
         * @param {CreatePaymentDetailsBlacklistRestRequest} createPaymentDetailsBlacklistRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentDetailsBlacklistV2(createPaymentDetailsBlacklistRestRequest: CreatePaymentDetailsBlacklistRestRequest, options?: any): AxiosPromise<RestDataResponseCreatePaymentDetailsBlacklistRestStatusPaymentDetailsBlacklistInfoRestDto> {
            return localVarFp.createPaymentDetailsBlacklistV2(createPaymentDetailsBlacklistRestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete payment details from blacklist
         * @param {DeletePaymentDetailsBlacklistRestRequest} deletePaymentDetailsBlacklistRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentDetailsBlacklistV2(deletePaymentDetailsBlacklistRestRequest: DeletePaymentDetailsBlacklistRestRequest, options?: any): AxiosPromise<RestResponseDeletePaymentDetailsBlacklistRestStatus> {
            return localVarFp.deletePaymentDetailsBlacklistV2(deletePaymentDetailsBlacklistRestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit payment details in blacklist
         * @param {EditPaymentDetailsBlacklistRestRequest} editPaymentDetailsBlacklistRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editPaymentDetailsBlacklistV2(editPaymentDetailsBlacklistRestRequest: EditPaymentDetailsBlacklistRestRequest, options?: any): AxiosPromise<RestDataResponseEditPaymentDetailsBlacklistRestStatusPaymentDetailsBlacklistInfoRestDto> {
            return localVarFp.editPaymentDetailsBlacklistV2(editPaymentDetailsBlacklistRestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about buy offer
         * @param {number} offerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuyOfferInformationV2(offerId: number, options?: any): AxiosPromise<RestDataResponseGetInfoRestStatusBuyOfferInfoRestDto> {
            return localVarFp.getBuyOfferInformationV2(offerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about order with it\'s payment details, appeals and chat history
         * @param {number} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderInformationV2(orderId: number, options?: any): AxiosPromise<RestDataResponseGetInfoRestStatusOrderInfoRestDto> {
            return localVarFp.getOrderInformationV2(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get payment details blacklist
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentDetailsBlacklistV2(id: number, options?: any): AxiosPromise<RestDataResponseGetPaymentDetailsBlacklistRestStatusPaymentDetailsBlacklistInfoRestDto> {
            return localVarFp.getPaymentDetailsBlacklistV2(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about sell offer
         * @param {number} offerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSellOfferInformationV2(offerId: number, options?: any): AxiosPromise<RestDataResponseGetInfoRestStatusSellOfferInfoRestDto> {
            return localVarFp.getSellOfferInformationV2(offerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user statistics
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserStatisticsV21(userId: number, options?: any): AxiosPromise<RestDataResponseGetUserStatisticsResponseStatusUserStatisticsBackOfficeRestDto> {
            return localVarFp.getUserStatisticsV21(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * List orders with filters sorted by accepted datetime. Unaccepted orders are additionally sorted by created datetime with same sort order. Default sort order is DESC (newest first).
         * @param {ListOrdersRestRequest} listOrdersRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrdersFilteredSortedV2(listOrdersRestRequest: ListOrdersRestRequest, options?: any): AxiosPromise<RestDataResponseListOrderViewRestStatusListListOrderViewRestDto> {
            return localVarFp.listOrdersFilteredSortedV2(listOrdersRestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * List orders with unresolved appeal with optional filters and optional sorting
         * @param {ListOrdersWithActiveAppealRestRequest} listOrdersWithActiveAppealRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrdersWithActiveAppealFilteredSortedV2(listOrdersWithActiveAppealRestRequest: ListOrdersWithActiveAppealRestRequest, options?: any): AxiosPromise<RestDataResponseListOrderViewRestStatusListListOrderViewWithActiveAppealRestDto> {
            return localVarFp.listOrdersWithActiveAppealFilteredSortedV2(listOrdersWithActiveAppealRestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Find payment details blacklist by filter
         * @param {ListPaymentDetailsBlacklistRestRequest} listPaymentDetailsBlacklistRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPaymentDetailsBlacklistV2(listPaymentDetailsBlacklistRestRequest: ListPaymentDetailsBlacklistRestRequest, options?: any): AxiosPromise<RestDataResponseListPaymentDetailsBlacklistRestStatusListPaymentDetailsBlacklistInfoRestDto> {
            return localVarFp.listPaymentDetailsBlacklistV2(listPaymentDetailsBlacklistRestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Resolve order appeal
         * @param {ResolveAppealRestRequest} resolveAppealRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveOrderAppealV2(resolveAppealRestRequest: ResolveAppealRestRequest, options?: any): AxiosPromise<RestResponseResolveAppealResponseStatus> {
            return localVarFp.resolveOrderAppealV2(resolveAppealRestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Resolve order appeal via script
         * @param {ResolveAppealViaScriptRestRequest} resolveAppealViaScriptRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveOrderAppealViaScriptV2(resolveAppealViaScriptRestRequest: ResolveAppealViaScriptRestRequest, options?: any): AxiosPromise<RestResponseResolveAppealViaScriptResponseStatus> {
            return localVarFp.resolveOrderAppealViaScriptV2(resolveAppealViaScriptRestRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BackofficeApi - object-oriented interface
 * @export
 * @class BackofficeApi
 * @extends {BaseAPI}
 */
export class BackofficeApi extends BaseAPI {
    /**
     * Create order appeal resolved event
     * @param {CreateOrderAppealResolvedEventRestRequest} createOrderAppealResolvedEventRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackofficeApi
     */
    public createOrderAppealResolvedEventV2(createOrderAppealResolvedEventRestRequest: CreateOrderAppealResolvedEventRestRequest, options?: AxiosRequestConfig) {
        return BackofficeApiFp(this.configuration).createOrderAppealResolvedEventV2(createOrderAppealResolvedEventRestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add payment details to blacklist
     * @param {CreatePaymentDetailsBlacklistRestRequest} createPaymentDetailsBlacklistRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackofficeApi
     */
    public createPaymentDetailsBlacklistV2(createPaymentDetailsBlacklistRestRequest: CreatePaymentDetailsBlacklistRestRequest, options?: AxiosRequestConfig) {
        return BackofficeApiFp(this.configuration).createPaymentDetailsBlacklistV2(createPaymentDetailsBlacklistRestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete payment details from blacklist
     * @param {DeletePaymentDetailsBlacklistRestRequest} deletePaymentDetailsBlacklistRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackofficeApi
     */
    public deletePaymentDetailsBlacklistV2(deletePaymentDetailsBlacklistRestRequest: DeletePaymentDetailsBlacklistRestRequest, options?: AxiosRequestConfig) {
        return BackofficeApiFp(this.configuration).deletePaymentDetailsBlacklistV2(deletePaymentDetailsBlacklistRestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit payment details in blacklist
     * @param {EditPaymentDetailsBlacklistRestRequest} editPaymentDetailsBlacklistRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackofficeApi
     */
    public editPaymentDetailsBlacklistV2(editPaymentDetailsBlacklistRestRequest: EditPaymentDetailsBlacklistRestRequest, options?: AxiosRequestConfig) {
        return BackofficeApiFp(this.configuration).editPaymentDetailsBlacklistV2(editPaymentDetailsBlacklistRestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about buy offer
     * @param {number} offerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackofficeApi
     */
    public getBuyOfferInformationV2(offerId: number, options?: AxiosRequestConfig) {
        return BackofficeApiFp(this.configuration).getBuyOfferInformationV2(offerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about order with it\'s payment details, appeals and chat history
     * @param {number} orderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackofficeApi
     */
    public getOrderInformationV2(orderId: number, options?: AxiosRequestConfig) {
        return BackofficeApiFp(this.configuration).getOrderInformationV2(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get payment details blacklist
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackofficeApi
     */
    public getPaymentDetailsBlacklistV2(id: number, options?: AxiosRequestConfig) {
        return BackofficeApiFp(this.configuration).getPaymentDetailsBlacklistV2(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about sell offer
     * @param {number} offerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackofficeApi
     */
    public getSellOfferInformationV2(offerId: number, options?: AxiosRequestConfig) {
        return BackofficeApiFp(this.configuration).getSellOfferInformationV2(offerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user statistics
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackofficeApi
     */
    public getUserStatisticsV21(userId: number, options?: AxiosRequestConfig) {
        return BackofficeApiFp(this.configuration).getUserStatisticsV21(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List orders with filters sorted by accepted datetime. Unaccepted orders are additionally sorted by created datetime with same sort order. Default sort order is DESC (newest first).
     * @param {ListOrdersRestRequest} listOrdersRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackofficeApi
     */
    public listOrdersFilteredSortedV2(listOrdersRestRequest: ListOrdersRestRequest, options?: AxiosRequestConfig) {
        return BackofficeApiFp(this.configuration).listOrdersFilteredSortedV2(listOrdersRestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List orders with unresolved appeal with optional filters and optional sorting
     * @param {ListOrdersWithActiveAppealRestRequest} listOrdersWithActiveAppealRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackofficeApi
     */
    public listOrdersWithActiveAppealFilteredSortedV2(listOrdersWithActiveAppealRestRequest: ListOrdersWithActiveAppealRestRequest, options?: AxiosRequestConfig) {
        return BackofficeApiFp(this.configuration).listOrdersWithActiveAppealFilteredSortedV2(listOrdersWithActiveAppealRestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find payment details blacklist by filter
     * @param {ListPaymentDetailsBlacklistRestRequest} listPaymentDetailsBlacklistRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackofficeApi
     */
    public listPaymentDetailsBlacklistV2(listPaymentDetailsBlacklistRestRequest: ListPaymentDetailsBlacklistRestRequest, options?: AxiosRequestConfig) {
        return BackofficeApiFp(this.configuration).listPaymentDetailsBlacklistV2(listPaymentDetailsBlacklistRestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resolve order appeal
     * @param {ResolveAppealRestRequest} resolveAppealRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackofficeApi
     */
    public resolveOrderAppealV2(resolveAppealRestRequest: ResolveAppealRestRequest, options?: AxiosRequestConfig) {
        return BackofficeApiFp(this.configuration).resolveOrderAppealV2(resolveAppealRestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resolve order appeal via script
     * @param {ResolveAppealViaScriptRestRequest} resolveAppealViaScriptRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackofficeApi
     */
    public resolveOrderAppealViaScriptV2(resolveAppealViaScriptRestRequest: ResolveAppealViaScriptRestRequest, options?: AxiosRequestConfig) {
        return BackofficeApiFp(this.configuration).resolveOrderAppealViaScriptV2(resolveAppealViaScriptRestRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CountryApi - axios parameter creator
 * @export
 */
export const CountryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupportedCodesV2: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/p2p/public-api/v2/country/alpha2/get-supported-list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Alpha2CodeRequest} alpha2CodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isCodeSupportedV2: async (alpha2CodeRequest: Alpha2CodeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'alpha2CodeRequest' is not null or undefined
            assertParamExists('isCodeSupportedV2', 'alpha2CodeRequest', alpha2CodeRequest)
            const localVarPath = `/p2p/public-api/v2/country/alpha2/is-supported`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(alpha2CodeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CountryApi - functional programming interface
 * @export
 */
export const CountryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CountryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSupportedCodesV2(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseGetSupportedCodesStatusListString>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSupportedCodesV2(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Alpha2CodeRequest} alpha2CodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isCodeSupportedV2(alpha2CodeRequest: Alpha2CodeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseIsCodeSupportedStatusBoolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isCodeSupportedV2(alpha2CodeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CountryApi - factory interface
 * @export
 */
export const CountryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CountryApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupportedCodesV2(options?: any): AxiosPromise<RestDataResponseGetSupportedCodesStatusListString> {
            return localVarFp.getSupportedCodesV2(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Alpha2CodeRequest} alpha2CodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isCodeSupportedV2(alpha2CodeRequest: Alpha2CodeRequest, options?: any): AxiosPromise<RestDataResponseIsCodeSupportedStatusBoolean> {
            return localVarFp.isCodeSupportedV2(alpha2CodeRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CountryApi - object-oriented interface
 * @export
 * @class CountryApi
 * @extends {BaseAPI}
 */
export class CountryApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountryApi
     */
    public getSupportedCodesV2(options?: AxiosRequestConfig) {
        return CountryApiFp(this.configuration).getSupportedCodesV2(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Alpha2CodeRequest} alpha2CodeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountryApi
     */
    public isCodeSupportedV2(alpha2CodeRequest: Alpha2CodeRequest, options?: AxiosRequestConfig) {
        return CountryApiFp(this.configuration).isCodeSupportedV2(alpha2CodeRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CurrencyApi - axios parameter creator
 * @export
 */
export const CurrencyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Получение списка поддерживаемых фиатных валют для обмена
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllSupportedFiatV2: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/p2p/public-api/v2/currency/all-supported-fiat`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CurrencyApi - functional programming interface
 * @export
 */
export const CurrencyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CurrencyApiAxiosParamCreator(configuration)
    return {
        /**
         * Получение списка поддерживаемых фиатных валют для обмена
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllSupportedFiatV2(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseFindAllSupportedFiatStatusListString>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllSupportedFiatV2(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CurrencyApi - factory interface
 * @export
 */
export const CurrencyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CurrencyApiFp(configuration)
    return {
        /**
         * Получение списка поддерживаемых фиатных валют для обмена
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllSupportedFiatV2(options?: any): AxiosPromise<RestDataResponseFindAllSupportedFiatStatusListString> {
            return localVarFp.findAllSupportedFiatV2(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CurrencyApi - object-oriented interface
 * @export
 * @class CurrencyApi
 * @extends {BaseAPI}
 */
export class CurrencyApi extends BaseAPI {
    /**
     * Получение списка поддерживаемых фиатных валют для обмена
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public findAllSupportedFiatV2(options?: AxiosRequestConfig) {
        return CurrencyApiFp(this.configuration).findAllSupportedFiatV2(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ExpressApi - axios parameter creator
 * @export
 */
export const ExpressApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel request P2P Express
         * @param {ExpressIdRequest} expressIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelExpressRequest: async (expressIdRequest: ExpressIdRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'expressIdRequest' is not null or undefined
            assertParamExists('cancelExpressRequest', 'expressIdRequest', expressIdRequest)
            const localVarPath = `/p2p/public-api/v2/express/request/cancel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(expressIdRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Confirm user request P2P Express
         * @param {CreateExpressRequest} createExpressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExpressRequest: async (createExpressRequest: CreateExpressRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createExpressRequest' is not null or undefined
            assertParamExists('createExpressRequest', 'createExpressRequest', createExpressRequest)
            const localVarPath = `/p2p/public-api/v2/express/request/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createExpressRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find the currency pairs supported by P2P Express
         * @param {FindCurrencyPairsRequest} findCurrencyPairsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCurrencyPairs: async (findCurrencyPairsRequest: FindCurrencyPairsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'findCurrencyPairsRequest' is not null or undefined
            assertParamExists('findCurrencyPairs', 'findCurrencyPairsRequest', findCurrencyPairsRequest)
            const localVarPath = `/p2p/public-api/v2/express/currency-pairs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(findCurrencyPairsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find the payment methods supported by P2P Express
         * @param {FindPaymentMethodsRequest} findPaymentMethodsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPaymentMethods: async (findPaymentMethodsRequest: FindPaymentMethodsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'findPaymentMethodsRequest' is not null or undefined
            assertParamExists('findPaymentMethods', 'findPaymentMethodsRequest', findPaymentMethodsRequest)
            const localVarPath = `/p2p/public-api/v2/express/payment-methods`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(findPaymentMethodsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current user request in P2P Express
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentRequest: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/p2p/public-api/v2/express/request/current`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the limits for a given currency pair
         * @param {GetLimitsRequest} getLimitsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLimits: async (getLimitsRequest: GetLimitsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getLimitsRequest' is not null or undefined
            assertParamExists('getLimits', 'getLimitsRequest', getLimitsRequest)
            const localVarPath = `/p2p/public-api/v2/express/limits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getLimitsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExpressApi - functional programming interface
 * @export
 */
export const ExpressApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExpressApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancel request P2P Express
         * @param {ExpressIdRequest} expressIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelExpressRequest(expressIdRequest: ExpressIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseCancelExpressRequestStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelExpressRequest(expressIdRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Confirm user request P2P Express
         * @param {CreateExpressRequest} createExpressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createExpressRequest(createExpressRequest: CreateExpressRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseCreateExpressRequestStatusExpressRequestRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createExpressRequest(createExpressRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Find the currency pairs supported by P2P Express
         * @param {FindCurrencyPairsRequest} findCurrencyPairsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findCurrencyPairs(findCurrencyPairsRequest: FindCurrencyPairsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseFindCurrencyPairsStatusFindCurrencyPairsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findCurrencyPairs(findCurrencyPairsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Find the payment methods supported by P2P Express
         * @param {FindPaymentMethodsRequest} findPaymentMethodsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findPaymentMethods(findPaymentMethodsRequest: FindPaymentMethodsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseFindPaymentMethodsStatusFindPaymentMethodsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findPaymentMethods(findPaymentMethodsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get current user request in P2P Express
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentRequest(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseGetCurrentRequestStatusExpressRequestRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentRequest(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the limits for a given currency pair
         * @param {GetLimitsRequest} getLimitsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLimits(getLimitsRequest: GetLimitsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseGetLimitsStatusGetLimitsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLimits(getLimitsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ExpressApi - factory interface
 * @export
 */
export const ExpressApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExpressApiFp(configuration)
    return {
        /**
         * Cancel request P2P Express
         * @param {ExpressIdRequest} expressIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelExpressRequest(expressIdRequest: ExpressIdRequest, options?: any): AxiosPromise<RestResponseCancelExpressRequestStatus> {
            return localVarFp.cancelExpressRequest(expressIdRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Confirm user request P2P Express
         * @param {CreateExpressRequest} createExpressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExpressRequest(createExpressRequest: CreateExpressRequest, options?: any): AxiosPromise<RestDataResponseCreateExpressRequestStatusExpressRequestRestDto> {
            return localVarFp.createExpressRequest(createExpressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Find the currency pairs supported by P2P Express
         * @param {FindCurrencyPairsRequest} findCurrencyPairsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCurrencyPairs(findCurrencyPairsRequest: FindCurrencyPairsRequest, options?: any): AxiosPromise<RestDataResponseFindCurrencyPairsStatusFindCurrencyPairsResponse> {
            return localVarFp.findCurrencyPairs(findCurrencyPairsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Find the payment methods supported by P2P Express
         * @param {FindPaymentMethodsRequest} findPaymentMethodsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPaymentMethods(findPaymentMethodsRequest: FindPaymentMethodsRequest, options?: any): AxiosPromise<RestDataResponseFindPaymentMethodsStatusFindPaymentMethodsResponse> {
            return localVarFp.findPaymentMethods(findPaymentMethodsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current user request in P2P Express
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentRequest(options?: any): AxiosPromise<RestDataResponseGetCurrentRequestStatusExpressRequestRestDto> {
            return localVarFp.getCurrentRequest(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the limits for a given currency pair
         * @param {GetLimitsRequest} getLimitsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLimits(getLimitsRequest: GetLimitsRequest, options?: any): AxiosPromise<RestDataResponseGetLimitsStatusGetLimitsResponse> {
            return localVarFp.getLimits(getLimitsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExpressApi - object-oriented interface
 * @export
 * @class ExpressApi
 * @extends {BaseAPI}
 */
export class ExpressApi extends BaseAPI {
    /**
     * Cancel request P2P Express
     * @param {ExpressIdRequest} expressIdRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpressApi
     */
    public cancelExpressRequest(expressIdRequest: ExpressIdRequest, options?: AxiosRequestConfig) {
        return ExpressApiFp(this.configuration).cancelExpressRequest(expressIdRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Confirm user request P2P Express
     * @param {CreateExpressRequest} createExpressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpressApi
     */
    public createExpressRequest(createExpressRequest: CreateExpressRequest, options?: AxiosRequestConfig) {
        return ExpressApiFp(this.configuration).createExpressRequest(createExpressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find the currency pairs supported by P2P Express
     * @param {FindCurrencyPairsRequest} findCurrencyPairsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpressApi
     */
    public findCurrencyPairs(findCurrencyPairsRequest: FindCurrencyPairsRequest, options?: AxiosRequestConfig) {
        return ExpressApiFp(this.configuration).findCurrencyPairs(findCurrencyPairsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find the payment methods supported by P2P Express
     * @param {FindPaymentMethodsRequest} findPaymentMethodsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpressApi
     */
    public findPaymentMethods(findPaymentMethodsRequest: FindPaymentMethodsRequest, options?: AxiosRequestConfig) {
        return ExpressApiFp(this.configuration).findPaymentMethods(findPaymentMethodsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current user request in P2P Express
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpressApi
     */
    public getCurrentRequest(options?: AxiosRequestConfig) {
        return ExpressApiFp(this.configuration).getCurrentRequest(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the limits for a given currency pair
     * @param {GetLimitsRequest} getLimitsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpressApi
     */
    public getLimits(getLimitsRequest: GetLimitsRequest, options?: AxiosRequestConfig) {
        return ExpressApiFp(this.configuration).getLimits(getLimitsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HealthCheckRestApi - axios parameter creator
 * @export
 */
export const HealthCheckRestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourcesHealthStatus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthCheckRestApi - functional programming interface
 * @export
 */
export const HealthCheckRestApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthCheckRestApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resourcesHealthStatus(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resourcesHealthStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HealthCheckRestApi - factory interface
 * @export
 */
export const HealthCheckRestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthCheckRestApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourcesHealthStatus(options?: any): AxiosPromise<HealthStatusResponse> {
            return localVarFp.resourcesHealthStatus(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthCheckRestApi - object-oriented interface
 * @export
 * @class HealthCheckRestApi
 * @extends {BaseAPI}
 */
export class HealthCheckRestApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthCheckRestApi
     */
    public resourcesHealthStatus(options?: AxiosRequestConfig) {
        return HealthCheckRestApiFp(this.configuration).resourcesHealthStatus(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MerchantRestControllerApi - axios parameter creator
 * @export
 */
export const MerchantRestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generates new api key for merchant
         * @param {GenerateApiKeyRequest} generateApiKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateApiKey: async (generateApiKeyRequest: GenerateApiKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'generateApiKeyRequest' is not null or undefined
            assertParamExists('generateApiKey', 'generateApiKeyRequest', generateApiKeyRequest)
            const localVarPath = `/p2p/internal-api/v1/merchant/generate-api-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateApiKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update webhook url for merchant API of user. Note, that you should enable merchant api user with POST /generate-api-key operation.
         * @param {SetWebhookUrlRequest} setWebhookUrlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setWebHookUrl: async (setWebhookUrlRequest: SetWebhookUrlRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setWebhookUrlRequest' is not null or undefined
            assertParamExists('setWebHookUrl', 'setWebhookUrlRequest', setWebhookUrlRequest)
            const localVarPath = `/p2p/internal-api/v1/merchant/set-webhook-url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setWebhookUrlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TerminateApiKeyRequest} terminateApiKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateApiKey: async (terminateApiKeyRequest: TerminateApiKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'terminateApiKeyRequest' is not null or undefined
            assertParamExists('terminateApiKey', 'terminateApiKeyRequest', terminateApiKeyRequest)
            const localVarPath = `/p2p/internal-api/v1/merchant/terminate-api-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(terminateApiKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MerchantRestControllerApi - functional programming interface
 * @export
 */
export const MerchantRestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MerchantRestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * Generates new api key for merchant
         * @param {GenerateApiKeyRequest} generateApiKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateApiKey(generateApiKeyRequest: GenerateApiKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseGenerateApiKeyStatusGenerateApiKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateApiKey(generateApiKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update webhook url for merchant API of user. Note, that you should enable merchant api user with POST /generate-api-key operation.
         * @param {SetWebhookUrlRequest} setWebhookUrlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setWebHookUrl(setWebhookUrlRequest: SetWebhookUrlRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseSetWebhookUrlStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setWebHookUrl(setWebhookUrlRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {TerminateApiKeyRequest} terminateApiKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async terminateApiKey(terminateApiKeyRequest: TerminateApiKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseTerminateApiKeyStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.terminateApiKey(terminateApiKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MerchantRestControllerApi - factory interface
 * @export
 */
export const MerchantRestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MerchantRestControllerApiFp(configuration)
    return {
        /**
         * Generates new api key for merchant
         * @param {GenerateApiKeyRequest} generateApiKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateApiKey(generateApiKeyRequest: GenerateApiKeyRequest, options?: any): AxiosPromise<RestDataResponseGenerateApiKeyStatusGenerateApiKeyResponse> {
            return localVarFp.generateApiKey(generateApiKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update webhook url for merchant API of user. Note, that you should enable merchant api user with POST /generate-api-key operation.
         * @param {SetWebhookUrlRequest} setWebhookUrlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setWebHookUrl(setWebhookUrlRequest: SetWebhookUrlRequest, options?: any): AxiosPromise<RestResponseSetWebhookUrlStatus> {
            return localVarFp.setWebHookUrl(setWebhookUrlRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TerminateApiKeyRequest} terminateApiKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateApiKey(terminateApiKeyRequest: TerminateApiKeyRequest, options?: any): AxiosPromise<RestResponseTerminateApiKeyStatus> {
            return localVarFp.terminateApiKey(terminateApiKeyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MerchantRestControllerApi - object-oriented interface
 * @export
 * @class MerchantRestControllerApi
 * @extends {BaseAPI}
 */
export class MerchantRestControllerApi extends BaseAPI {
    /**
     * Generates new api key for merchant
     * @param {GenerateApiKeyRequest} generateApiKeyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantRestControllerApi
     */
    public generateApiKey(generateApiKeyRequest: GenerateApiKeyRequest, options?: AxiosRequestConfig) {
        return MerchantRestControllerApiFp(this.configuration).generateApiKey(generateApiKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update webhook url for merchant API of user. Note, that you should enable merchant api user with POST /generate-api-key operation.
     * @param {SetWebhookUrlRequest} setWebhookUrlRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantRestControllerApi
     */
    public setWebHookUrl(setWebhookUrlRequest: SetWebhookUrlRequest, options?: AxiosRequestConfig) {
        return MerchantRestControllerApiFp(this.configuration).setWebHookUrl(setWebhookUrlRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TerminateApiKeyRequest} terminateApiKeyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantRestControllerApi
     */
    public terminateApiKey(terminateApiKeyRequest: TerminateApiKeyRequest, options?: AxiosRequestConfig) {
        return MerchantRestControllerApiFp(this.configuration).terminateApiKey(terminateApiKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NotificationApi - axios parameter creator
 * @export
 */
export const NotificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Получение нотификаций пользователя отсортированных по времени появления по убыванию.
         * @param {NotificationPageRestRequest} notificationPageRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationsByUserIdOrderedByCreatedDateTimeDesc: async (notificationPageRestRequest: NotificationPageRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notificationPageRestRequest' is not null or undefined
            assertParamExists('getNotificationsByUserIdOrderedByCreatedDateTimeDesc', 'notificationPageRestRequest', notificationPageRestRequest)
            const localVarPath = `/p2p/internal-api/v1/notification/get-by-user-id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notificationPageRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationApi - functional programming interface
 * @export
 */
export const NotificationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationApiAxiosParamCreator(configuration)
    return {
        /**
         * Получение нотификаций пользователя отсортированных по времени появления по убыванию.
         * @param {NotificationPageRestRequest} notificationPageRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotificationsByUserIdOrderedByCreatedDateTimeDesc(notificationPageRestRequest: NotificationPageRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseGetNotificationsByUserIdListNotificationRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotificationsByUserIdOrderedByCreatedDateTimeDesc(notificationPageRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NotificationApi - factory interface
 * @export
 */
export const NotificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationApiFp(configuration)
    return {
        /**
         * Получение нотификаций пользователя отсортированных по времени появления по убыванию.
         * @param {NotificationPageRestRequest} notificationPageRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationsByUserIdOrderedByCreatedDateTimeDesc(notificationPageRestRequest: NotificationPageRestRequest, options?: any): AxiosPromise<RestDataResponseGetNotificationsByUserIdListNotificationRestDto> {
            return localVarFp.getNotificationsByUserIdOrderedByCreatedDateTimeDesc(notificationPageRestRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationApi - object-oriented interface
 * @export
 * @class NotificationApi
 * @extends {BaseAPI}
 */
export class NotificationApi extends BaseAPI {
    /**
     * Получение нотификаций пользователя отсортированных по времени появления по убыванию.
     * @param {NotificationPageRestRequest} notificationPageRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public getNotificationsByUserIdOrderedByCreatedDateTimeDesc(notificationPageRestRequest: NotificationPageRestRequest, options?: AxiosRequestConfig) {
        return NotificationApiFp(this.configuration).getNotificationsByUserIdOrderedByCreatedDateTimeDesc(notificationPageRestRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OfferApi - axios parameter creator
 * @export
 */
export const OfferApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Активация объявления, объявление должно быть в статусе INACTIVE
         * @param {ActivateOfferRestRequest} activateOfferRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateOfferV2: async (activateOfferRestRequest: ActivateOfferRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'activateOfferRestRequest' is not null or undefined
            assertParamExists('activateOfferV2', 'activateOfferRestRequest', activateOfferRestRequest)
            const localVarPath = `/p2p/public-api/v2/offer/activate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(activateOfferRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Узнать, можно ли создавать сделки в этом объявлении
         * @param {CanCreateOrdersOnOfferRestRequest} canCreateOrdersOnOfferRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkCanCreateOrdersOnOffer: async (canCreateOrdersOnOfferRestRequest: CanCreateOrdersOnOfferRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'canCreateOrdersOnOfferRestRequest' is not null or undefined
            assertParamExists('checkCanCreateOrdersOnOffer', 'canCreateOrdersOnOfferRestRequest', canCreateOrdersOnOfferRestRequest)
            const localVarPath = `/p2p/public-api/v2/offer/check-can-create-orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(canCreateOrdersOnOfferRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CheckMakerLimitsToBuyOfferRestRequest} checkMakerLimitsToBuyOfferRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkMakerLimitsToBuyOffer: async (checkMakerLimitsToBuyOfferRestRequest: CheckMakerLimitsToBuyOfferRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkMakerLimitsToBuyOfferRestRequest' is not null or undefined
            assertParamExists('checkMakerLimitsToBuyOffer', 'checkMakerLimitsToBuyOfferRestRequest', checkMakerLimitsToBuyOfferRestRequest)
            const localVarPath = `/p2p/public-api/v2/offer/limits-check-to-buy-offer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkMakerLimitsToBuyOfferRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Создание нового объявления в статусе INACTIVE
         * @param {CreateBuyOfferRestRequest | CreateSellOfferRestRequest} createBuyOfferRestRequestCreateSellOfferRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOfferV2: async (createBuyOfferRestRequestCreateSellOfferRestRequest: CreateBuyOfferRestRequest | CreateSellOfferRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createBuyOfferRestRequestCreateSellOfferRestRequest' is not null or undefined
            assertParamExists('createOfferV2', 'createBuyOfferRestRequestCreateSellOfferRestRequest', createBuyOfferRestRequestCreateSellOfferRestRequest)
            const localVarPath = `/p2p/public-api/v2/offer/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createBuyOfferRestRequestCreateSellOfferRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Деактивация объявления, объявление должно быть в статусе ACTIVE. Используется для ручной деактивации объявления сотрудниками тех. поддержки при спорных ситуациях
         * @param {DeactivateOfferRestRequest} deactivateOfferRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateOffer: async (deactivateOfferRestRequest: DeactivateOfferRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deactivateOfferRestRequest' is not null or undefined
            assertParamExists('deactivateOffer', 'deactivateOfferRestRequest', deactivateOfferRestRequest)
            const localVarPath = `/p2p/internal-api/v1/offer/deactivate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deactivateOfferRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Деактивация объявления, объявление должно быть в статусе ACTIVE
         * @param {DeactivateOfferRestRequest} deactivateOfferRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateOfferV2: async (deactivateOfferRestRequest: DeactivateOfferRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deactivateOfferRestRequest' is not null or undefined
            assertParamExists('deactivateOfferV2', 'deactivateOfferRestRequest', deactivateOfferRestRequest)
            const localVarPath = `/p2p/public-api/v2/offer/deactivate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deactivateOfferRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Editing already created offer. Offer must be in INACTIVE or ACTIVE statuses
         * @param {EditBuyOfferRestRequest | EditSellOfferRestRequest} editBuyOfferRestRequestEditSellOfferRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOfferV2: async (editBuyOfferRestRequestEditSellOfferRestRequest: EditBuyOfferRestRequest | EditSellOfferRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'editBuyOfferRestRequestEditSellOfferRestRequest' is not null or undefined
            assertParamExists('editOfferV2', 'editBuyOfferRestRequestEditSellOfferRestRequest', editBuyOfferRestRequestEditSellOfferRestRequest)
            const localVarPath = `/p2p/public-api/v2/offer/edit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editBuyOfferRestRequestEditSellOfferRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOfferById: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOfferById', 'id', id)
            const localVarPath = `/p2p/merchant-api/v1/offer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Getting offer fixed price limits for currency pair
         * @param {GetOfferFixedPriceLimitsRestRequest} getOfferFixedPriceLimitsRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOfferFixedPriceLimitsByCurrencyPair: async (getOfferFixedPriceLimitsRestRequest: GetOfferFixedPriceLimitsRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getOfferFixedPriceLimitsRestRequest' is not null or undefined
            assertParamExists('getOfferFixedPriceLimitsByCurrencyPair', 'getOfferFixedPriceLimitsRestRequest', getOfferFixedPriceLimitsRestRequest)
            const localVarPath = `/p2p/public-api/v2/offer/limits/fixed-price/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getOfferFixedPriceLimitsRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получить Id объявлений, которые следует исключить из стакана
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOfferIdsToExcludeFromDom: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/p2p/public-api/v2/offer/get-offer-ids-to-exclude-from-dom`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение объявления на покупку и продажу по его id
         * @param {GetOfferRestRequest} getOfferRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOfferV2: async (getOfferRestRequest: GetOfferRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getOfferRestRequest' is not null or undefined
            assertParamExists('getOfferV2', 'getOfferRestRequest', getOfferRestRequest)
            const localVarPath = `/p2p/public-api/v2/offer/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getOfferRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffersById: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/p2p/merchant-api/v1/all-offers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение всех объявлений пользователя
         * @param {GetOffersByUserIdV2Request} [getOffersByUserIdV2Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffersByUserIdV2: async (getOffersByUserIdV2Request?: GetOffersByUserIdV2Request, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/p2p/public-api/v2/offer/user-own/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getOffersByUserIdV2Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettings: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/p2p/public-api/v2/offer/settings/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение объявления по его id
         * @param {GetUserPrivateOfferRestRequest} getUserPrivateOfferRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPrivateOfferV2: async (getUserPrivateOfferRestRequest: GetUserPrivateOfferRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getUserPrivateOfferRestRequest' is not null or undefined
            assertParamExists('getUserPrivateOfferV2', 'getUserPrivateOfferRestRequest', getUserPrivateOfferRestRequest)
            const localVarPath = `/p2p/public-api/v2/offer/get-user-own`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getUserPrivateOfferRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение стакана объявлений с фиксированной ценой. Объявления на продажу отсортированы по возрастанию цены, на покупку - по убыванию.
         * @param {InternalDomOffersRestRequest} internalDomOffersRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDomOffers: async (internalDomOffersRestRequest: InternalDomOffersRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'internalDomOffersRestRequest' is not null or undefined
            assertParamExists('listDomOffers', 'internalDomOffersRestRequest', internalDomOffersRestRequest)
            const localVarPath = `/p2p/internal-api/v1/offer/depth-of-market`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(internalDomOffersRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение стакана объявлений с фиксированной ценой. Объявления на продажу отсортированы по возрастанию цены, на покупку - по убыванию.
         * @param {DomOffersRestRequest} domOffersRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDomOffersV2: async (domOffersRestRequest: DomOffersRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domOffersRestRequest' is not null or undefined
            assertParamExists('listDomOffersV2', 'domOffersRestRequest', domOffersRestRequest)
            const localVarPath = `/p2p/public-api/v2/offer/depth-of-market`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domOffersRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OfferApi - functional programming interface
 * @export
 */
export const OfferApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OfferApiAxiosParamCreator(configuration)
    return {
        /**
         * Активация объявления, объявление должно быть в статусе INACTIVE
         * @param {ActivateOfferRestRequest} activateOfferRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateOfferV2(activateOfferRestRequest: ActivateOfferRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailedRestResponseActivateOfferRestStatusKycPromotionRequiredDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateOfferV2(activateOfferRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Узнать, можно ли создавать сделки в этом объявлении
         * @param {CanCreateOrdersOnOfferRestRequest} canCreateOrdersOnOfferRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkCanCreateOrdersOnOffer(canCreateOrdersOnOfferRestRequest: CanCreateOrdersOnOfferRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseCanCreateOrdersOnOfferRestStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkCanCreateOrdersOnOffer(canCreateOrdersOnOfferRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CheckMakerLimitsToBuyOfferRestRequest} checkMakerLimitsToBuyOfferRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkMakerLimitsToBuyOffer(checkMakerLimitsToBuyOfferRestRequest: CheckMakerLimitsToBuyOfferRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailedRestResponseCheckMakerLimitsToBuyOfferRestStatusKycPromotionRequiredDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkMakerLimitsToBuyOffer(checkMakerLimitsToBuyOfferRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Создание нового объявления в статусе INACTIVE
         * @param {CreateBuyOfferRestRequest | CreateSellOfferRestRequest} createBuyOfferRestRequestCreateSellOfferRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOfferV2(createBuyOfferRestRequestCreateSellOfferRestRequest: CreateBuyOfferRestRequest | CreateSellOfferRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailedRestDataResponseCreateOfferRestStatusUserPrivateBaseOfferRestDtoKycPromotionRequiredDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOfferV2(createBuyOfferRestRequestCreateSellOfferRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Деактивация объявления, объявление должно быть в статусе ACTIVE. Используется для ручной деактивации объявления сотрудниками тех. поддержки при спорных ситуациях
         * @param {DeactivateOfferRestRequest} deactivateOfferRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateOffer(deactivateOfferRestRequest: DeactivateOfferRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseDeactivateOfferRestStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateOffer(deactivateOfferRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Деактивация объявления, объявление должно быть в статусе ACTIVE
         * @param {DeactivateOfferRestRequest} deactivateOfferRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateOfferV2(deactivateOfferRestRequest: DeactivateOfferRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseDeactivateOfferRestStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateOfferV2(deactivateOfferRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Editing already created offer. Offer must be in INACTIVE or ACTIVE statuses
         * @param {EditBuyOfferRestRequest | EditSellOfferRestRequest} editBuyOfferRestRequestEditSellOfferRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editOfferV2(editBuyOfferRestRequestEditSellOfferRestRequest: EditBuyOfferRestRequest | EditSellOfferRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailedRestDataResponseEditOfferRestStatusUserPrivateBaseOfferRestDtoKycPromotionRequiredDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editOfferV2(editBuyOfferRestRequestEditSellOfferRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOfferById(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MerchantApiResponseGetOfferByIdStatusOffer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOfferById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Getting offer fixed price limits for currency pair
         * @param {GetOfferFixedPriceLimitsRestRequest} getOfferFixedPriceLimitsRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOfferFixedPriceLimitsByCurrencyPair(getOfferFixedPriceLimitsRestRequest: GetOfferFixedPriceLimitsRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseFixedPriceLimitsStatusOfferFixedPriceLimitsRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOfferFixedPriceLimitsByCurrencyPair(getOfferFixedPriceLimitsRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Получить Id объявлений, которые следует исключить из стакана
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOfferIdsToExcludeFromDom(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfferIdsToExcludeFromDomRestStatusOfferIdsExcludeFromDomListRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOfferIdsToExcludeFromDom(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Получение объявления на покупку и продажу по его id
         * @param {GetOfferRestRequest} getOfferRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOfferV2(getOfferRestRequest: GetOfferRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseGetOfferStatusBaseOfferRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOfferV2(getOfferRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOffersById(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MerchantApiResponseAllOffersStatusPageOfferLong>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOffersById(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Получение всех объявлений пользователя
         * @param {GetOffersByUserIdV2Request} [getOffersByUserIdV2Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOffersByUserIdV2(getOffersByUserIdV2Request?: GetOffersByUserIdV2Request, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseGetOfferByUserIdStatusListUserPrivateMyOffersListRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOffersByUserIdV2(getOffersByUserIdV2Request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSettings(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseSettingsStatusSettingsRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSettings(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Получение объявления по его id
         * @param {GetUserPrivateOfferRestRequest} getUserPrivateOfferRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserPrivateOfferV2(getUserPrivateOfferRestRequest: GetUserPrivateOfferRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseGetUserPrivateOfferStatusUserPrivateBaseOfferRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserPrivateOfferV2(getUserPrivateOfferRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Получение стакана объявлений с фиксированной ценой. Объявления на продажу отсортированы по возрастанию цены, на покупку - по убыванию.
         * @param {InternalDomOffersRestRequest} internalDomOffersRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDomOffers(internalDomOffersRestRequest: InternalDomOffersRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseDomOffersStatusListDomOfferRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDomOffers(internalDomOffersRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Получение стакана объявлений с фиксированной ценой. Объявления на продажу отсортированы по возрастанию цены, на покупку - по убыванию.
         * @param {DomOffersRestRequest} domOffersRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDomOffersV2(domOffersRestRequest: DomOffersRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseDomOffersStatusListDomOfferRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDomOffersV2(domOffersRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OfferApi - factory interface
 * @export
 */
export const OfferApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OfferApiFp(configuration)
    return {
        /**
         * Активация объявления, объявление должно быть в статусе INACTIVE
         * @param {ActivateOfferRestRequest} activateOfferRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateOfferV2(activateOfferRestRequest: ActivateOfferRestRequest, options?: any): AxiosPromise<DetailedRestResponseActivateOfferRestStatusKycPromotionRequiredDetails> {
            return localVarFp.activateOfferV2(activateOfferRestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Узнать, можно ли создавать сделки в этом объявлении
         * @param {CanCreateOrdersOnOfferRestRequest} canCreateOrdersOnOfferRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkCanCreateOrdersOnOffer(canCreateOrdersOnOfferRestRequest: CanCreateOrdersOnOfferRestRequest, options?: any): AxiosPromise<RestResponseCanCreateOrdersOnOfferRestStatus> {
            return localVarFp.checkCanCreateOrdersOnOffer(canCreateOrdersOnOfferRestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CheckMakerLimitsToBuyOfferRestRequest} checkMakerLimitsToBuyOfferRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkMakerLimitsToBuyOffer(checkMakerLimitsToBuyOfferRestRequest: CheckMakerLimitsToBuyOfferRestRequest, options?: any): AxiosPromise<DetailedRestResponseCheckMakerLimitsToBuyOfferRestStatusKycPromotionRequiredDetails> {
            return localVarFp.checkMakerLimitsToBuyOffer(checkMakerLimitsToBuyOfferRestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Создание нового объявления в статусе INACTIVE
         * @param {CreateBuyOfferRestRequest | CreateSellOfferRestRequest} createBuyOfferRestRequestCreateSellOfferRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOfferV2(createBuyOfferRestRequestCreateSellOfferRestRequest: CreateBuyOfferRestRequest | CreateSellOfferRestRequest, options?: any): AxiosPromise<DetailedRestDataResponseCreateOfferRestStatusUserPrivateBaseOfferRestDtoKycPromotionRequiredDetails> {
            return localVarFp.createOfferV2(createBuyOfferRestRequestCreateSellOfferRestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Деактивация объявления, объявление должно быть в статусе ACTIVE. Используется для ручной деактивации объявления сотрудниками тех. поддержки при спорных ситуациях
         * @param {DeactivateOfferRestRequest} deactivateOfferRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateOffer(deactivateOfferRestRequest: DeactivateOfferRestRequest, options?: any): AxiosPromise<RestResponseDeactivateOfferRestStatus> {
            return localVarFp.deactivateOffer(deactivateOfferRestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Деактивация объявления, объявление должно быть в статусе ACTIVE
         * @param {DeactivateOfferRestRequest} deactivateOfferRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateOfferV2(deactivateOfferRestRequest: DeactivateOfferRestRequest, options?: any): AxiosPromise<RestResponseDeactivateOfferRestStatus> {
            return localVarFp.deactivateOfferV2(deactivateOfferRestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Editing already created offer. Offer must be in INACTIVE or ACTIVE statuses
         * @param {EditBuyOfferRestRequest | EditSellOfferRestRequest} editBuyOfferRestRequestEditSellOfferRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOfferV2(editBuyOfferRestRequestEditSellOfferRestRequest: EditBuyOfferRestRequest | EditSellOfferRestRequest, options?: any): AxiosPromise<DetailedRestDataResponseEditOfferRestStatusUserPrivateBaseOfferRestDtoKycPromotionRequiredDetails> {
            return localVarFp.editOfferV2(editBuyOfferRestRequestEditSellOfferRestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOfferById(id: number, options?: any): AxiosPromise<MerchantApiResponseGetOfferByIdStatusOffer> {
            return localVarFp.getOfferById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Getting offer fixed price limits for currency pair
         * @param {GetOfferFixedPriceLimitsRestRequest} getOfferFixedPriceLimitsRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOfferFixedPriceLimitsByCurrencyPair(getOfferFixedPriceLimitsRestRequest: GetOfferFixedPriceLimitsRestRequest, options?: any): AxiosPromise<RestDataResponseFixedPriceLimitsStatusOfferFixedPriceLimitsRestDto> {
            return localVarFp.getOfferFixedPriceLimitsByCurrencyPair(getOfferFixedPriceLimitsRestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Получить Id объявлений, которые следует исключить из стакана
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOfferIdsToExcludeFromDom(options?: any): AxiosPromise<RestDataResponseOfferIdsToExcludeFromDomRestStatusOfferIdsExcludeFromDomListRestDto> {
            return localVarFp.getOfferIdsToExcludeFromDom(options).then((request) => request(axios, basePath));
        },
        /**
         * Получение объявления на покупку и продажу по его id
         * @param {GetOfferRestRequest} getOfferRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOfferV2(getOfferRestRequest: GetOfferRestRequest, options?: any): AxiosPromise<RestDataResponseGetOfferStatusBaseOfferRestDto> {
            return localVarFp.getOfferV2(getOfferRestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffersById(limit?: number, offset?: number, options?: any): AxiosPromise<MerchantApiResponseAllOffersStatusPageOfferLong> {
            return localVarFp.getOffersById(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Получение всех объявлений пользователя
         * @param {GetOffersByUserIdV2Request} [getOffersByUserIdV2Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffersByUserIdV2(getOffersByUserIdV2Request?: GetOffersByUserIdV2Request, options?: any): AxiosPromise<RestDataResponseGetOfferByUserIdStatusListUserPrivateMyOffersListRestDto> {
            return localVarFp.getOffersByUserIdV2(getOffersByUserIdV2Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettings(options?: any): AxiosPromise<RestDataResponseSettingsStatusSettingsRestDto> {
            return localVarFp.getSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Получение объявления по его id
         * @param {GetUserPrivateOfferRestRequest} getUserPrivateOfferRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPrivateOfferV2(getUserPrivateOfferRestRequest: GetUserPrivateOfferRestRequest, options?: any): AxiosPromise<RestDataResponseGetUserPrivateOfferStatusUserPrivateBaseOfferRestDto> {
            return localVarFp.getUserPrivateOfferV2(getUserPrivateOfferRestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Получение стакана объявлений с фиксированной ценой. Объявления на продажу отсортированы по возрастанию цены, на покупку - по убыванию.
         * @param {InternalDomOffersRestRequest} internalDomOffersRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDomOffers(internalDomOffersRestRequest: InternalDomOffersRestRequest, options?: any): AxiosPromise<RestDataResponseDomOffersStatusListDomOfferRestDto> {
            return localVarFp.listDomOffers(internalDomOffersRestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Получение стакана объявлений с фиксированной ценой. Объявления на продажу отсортированы по возрастанию цены, на покупку - по убыванию.
         * @param {DomOffersRestRequest} domOffersRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDomOffersV2(domOffersRestRequest: DomOffersRestRequest, options?: any): AxiosPromise<RestDataResponseDomOffersStatusListDomOfferRestDto> {
            return localVarFp.listDomOffersV2(domOffersRestRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OfferApi - object-oriented interface
 * @export
 * @class OfferApi
 * @extends {BaseAPI}
 */
export class OfferApi extends BaseAPI {
    /**
     * Активация объявления, объявление должно быть в статусе INACTIVE
     * @param {ActivateOfferRestRequest} activateOfferRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfferApi
     */
    public activateOfferV2(activateOfferRestRequest: ActivateOfferRestRequest, options?: AxiosRequestConfig) {
        return OfferApiFp(this.configuration).activateOfferV2(activateOfferRestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Узнать, можно ли создавать сделки в этом объявлении
     * @param {CanCreateOrdersOnOfferRestRequest} canCreateOrdersOnOfferRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfferApi
     */
    public checkCanCreateOrdersOnOffer(canCreateOrdersOnOfferRestRequest: CanCreateOrdersOnOfferRestRequest, options?: AxiosRequestConfig) {
        return OfferApiFp(this.configuration).checkCanCreateOrdersOnOffer(canCreateOrdersOnOfferRestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CheckMakerLimitsToBuyOfferRestRequest} checkMakerLimitsToBuyOfferRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfferApi
     */
    public checkMakerLimitsToBuyOffer(checkMakerLimitsToBuyOfferRestRequest: CheckMakerLimitsToBuyOfferRestRequest, options?: AxiosRequestConfig) {
        return OfferApiFp(this.configuration).checkMakerLimitsToBuyOffer(checkMakerLimitsToBuyOfferRestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Создание нового объявления в статусе INACTIVE
     * @param {CreateBuyOfferRestRequest | CreateSellOfferRestRequest} createBuyOfferRestRequestCreateSellOfferRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfferApi
     */
    public createOfferV2(createBuyOfferRestRequestCreateSellOfferRestRequest: CreateBuyOfferRestRequest | CreateSellOfferRestRequest, options?: AxiosRequestConfig) {
        return OfferApiFp(this.configuration).createOfferV2(createBuyOfferRestRequestCreateSellOfferRestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Деактивация объявления, объявление должно быть в статусе ACTIVE. Используется для ручной деактивации объявления сотрудниками тех. поддержки при спорных ситуациях
     * @param {DeactivateOfferRestRequest} deactivateOfferRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfferApi
     */
    public deactivateOffer(deactivateOfferRestRequest: DeactivateOfferRestRequest, options?: AxiosRequestConfig) {
        return OfferApiFp(this.configuration).deactivateOffer(deactivateOfferRestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Деактивация объявления, объявление должно быть в статусе ACTIVE
     * @param {DeactivateOfferRestRequest} deactivateOfferRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfferApi
     */
    public deactivateOfferV2(deactivateOfferRestRequest: DeactivateOfferRestRequest, options?: AxiosRequestConfig) {
        return OfferApiFp(this.configuration).deactivateOfferV2(deactivateOfferRestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Editing already created offer. Offer must be in INACTIVE or ACTIVE statuses
     * @param {EditBuyOfferRestRequest | EditSellOfferRestRequest} editBuyOfferRestRequestEditSellOfferRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfferApi
     */
    public editOfferV2(editBuyOfferRestRequestEditSellOfferRestRequest: EditBuyOfferRestRequest | EditSellOfferRestRequest, options?: AxiosRequestConfig) {
        return OfferApiFp(this.configuration).editOfferV2(editBuyOfferRestRequestEditSellOfferRestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfferApi
     */
    public getOfferById(id: number, options?: AxiosRequestConfig) {
        return OfferApiFp(this.configuration).getOfferById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Getting offer fixed price limits for currency pair
     * @param {GetOfferFixedPriceLimitsRestRequest} getOfferFixedPriceLimitsRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfferApi
     */
    public getOfferFixedPriceLimitsByCurrencyPair(getOfferFixedPriceLimitsRestRequest: GetOfferFixedPriceLimitsRestRequest, options?: AxiosRequestConfig) {
        return OfferApiFp(this.configuration).getOfferFixedPriceLimitsByCurrencyPair(getOfferFixedPriceLimitsRestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получить Id объявлений, которые следует исключить из стакана
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfferApi
     */
    public getOfferIdsToExcludeFromDom(options?: AxiosRequestConfig) {
        return OfferApiFp(this.configuration).getOfferIdsToExcludeFromDom(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение объявления на покупку и продажу по его id
     * @param {GetOfferRestRequest} getOfferRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfferApi
     */
    public getOfferV2(getOfferRestRequest: GetOfferRestRequest, options?: AxiosRequestConfig) {
        return OfferApiFp(this.configuration).getOfferV2(getOfferRestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfferApi
     */
    public getOffersById(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return OfferApiFp(this.configuration).getOffersById(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение всех объявлений пользователя
     * @param {GetOffersByUserIdV2Request} [getOffersByUserIdV2Request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfferApi
     */
    public getOffersByUserIdV2(getOffersByUserIdV2Request?: GetOffersByUserIdV2Request, options?: AxiosRequestConfig) {
        return OfferApiFp(this.configuration).getOffersByUserIdV2(getOffersByUserIdV2Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfferApi
     */
    public getSettings(options?: AxiosRequestConfig) {
        return OfferApiFp(this.configuration).getSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение объявления по его id
     * @param {GetUserPrivateOfferRestRequest} getUserPrivateOfferRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfferApi
     */
    public getUserPrivateOfferV2(getUserPrivateOfferRestRequest: GetUserPrivateOfferRestRequest, options?: AxiosRequestConfig) {
        return OfferApiFp(this.configuration).getUserPrivateOfferV2(getUserPrivateOfferRestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение стакана объявлений с фиксированной ценой. Объявления на продажу отсортированы по возрастанию цены, на покупку - по убыванию.
     * @param {InternalDomOffersRestRequest} internalDomOffersRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfferApi
     */
    public listDomOffers(internalDomOffersRestRequest: InternalDomOffersRestRequest, options?: AxiosRequestConfig) {
        return OfferApiFp(this.configuration).listDomOffers(internalDomOffersRestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение стакана объявлений с фиксированной ценой. Объявления на продажу отсортированы по возрастанию цены, на покупку - по убыванию.
     * @param {DomOffersRestRequest} domOffersRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfferApi
     */
    public listDomOffersV2(domOffersRestRequest: DomOffersRestRequest, options?: AxiosRequestConfig) {
        return OfferApiFp(this.configuration).listDomOffersV2(domOffersRestRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrderApi - axios parameter creator
 * @export
 */
export const OrderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AcceptOrderRestRequest} acceptOrderRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptOrderV2: async (acceptOrderRestRequest: AcceptOrderRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'acceptOrderRestRequest' is not null or undefined
            assertParamExists('acceptOrderV2', 'acceptOrderRestRequest', acceptOrderRestRequest)
            const localVarPath = `/p2p/public-api/v2/offer/order/accept`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(acceptOrderRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OrderIdRestRequest} orderIdRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrderByBuyerV2: async (orderIdRestRequest: OrderIdRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderIdRestRequest' is not null or undefined
            assertParamExists('cancelOrderByBuyerV2', 'orderIdRestRequest', orderIdRestRequest)
            const localVarPath = `/p2p/public-api/v2/offer/order/cancel/by-buyer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderIdRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OrderIdRestRequest} orderIdRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrderBySellerV2: async (orderIdRestRequest: OrderIdRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderIdRestRequest' is not null or undefined
            assertParamExists('cancelOrderBySellerV2', 'orderIdRestRequest', orderIdRestRequest)
            const localVarPath = `/p2p/public-api/v2/offer/order/cancel/by-seller`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderIdRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OrderConfirmRestRequest} orderConfirmRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmOrderV2: async (orderConfirmRestRequest: OrderConfirmRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderConfirmRestRequest' is not null or undefined
            assertParamExists('confirmOrderV2', 'orderConfirmRestRequest', orderConfirmRestRequest)
            const localVarPath = `/p2p/public-api/v2/offer/order/confirm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderConfirmRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ConfirmReceiptPaymentRestRequest} confirmReceiptPaymentRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmReceiptPaymentV2: async (confirmReceiptPaymentRestRequest: ConfirmReceiptPaymentRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'confirmReceiptPaymentRestRequest' is not null or undefined
            assertParamExists('confirmReceiptPaymentV2', 'confirmReceiptPaymentRestRequest', confirmReceiptPaymentRestRequest)
            const localVarPath = `/p2p/public-api/v2/offer/order/confirm-receipt-payment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(confirmReceiptPaymentRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ConfirmSendingPaymentRestRequest} confirmSendingPaymentRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmSendingPaymentV2: async (confirmSendingPaymentRestRequest: ConfirmSendingPaymentRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'confirmSendingPaymentRestRequest' is not null or undefined
            assertParamExists('confirmSendingPaymentV2', 'confirmSendingPaymentRestRequest', confirmSendingPaymentRestRequest)
            const localVarPath = `/p2p/public-api/v2/offer/order/confirm-sending-payment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(confirmSendingPaymentRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ByAmount} byAmount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderByAmountV2: async (byAmount: ByAmount, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'byAmount' is not null or undefined
            assertParamExists('createOrderByAmountV2', 'byAmount', byAmount)
            const localVarPath = `/p2p/public-api/v2/offer/order/create-by-amount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(byAmount, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ByVolume} byVolume 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderByVolumeV2: async (byVolume: ByVolume, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'byVolume' is not null or undefined
            assertParamExists('createOrderByVolumeV2', 'byVolume', byVolume)
            const localVarPath = `/p2p/public-api/v2/offer/order/create-by-volume`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(byVolume, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OrderIdRestRequest} orderIdRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderByIdV2: async (orderIdRestRequest: OrderIdRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderIdRestRequest' is not null or undefined
            assertParamExists('getOrderByIdV2', 'orderIdRestRequest', orderIdRestRequest)
            const localVarPath = `/p2p/public-api/v2/offer/order/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderIdRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserOrderHistoryRequest} userOrderHistoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersHistoryByUserIdV2: async (userOrderHistoryRequest: UserOrderHistoryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userOrderHistoryRequest' is not null or undefined
            assertParamExists('getOrdersHistoryByUserIdV2', 'userOrderHistoryRequest', userOrderHistoryRequest)
            const localVarPath = `/p2p/public-api/v2/offer/order/get-history/by-user-id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userOrderHistoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetUserAvailableBalanceWithoutBuyOrderFeeRestRequest} getUserAvailableBalanceWithoutBuyOrderFeeRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAvailableBalanceWithoutBuyOrderFeeV2: async (getUserAvailableBalanceWithoutBuyOrderFeeRestRequest: GetUserAvailableBalanceWithoutBuyOrderFeeRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getUserAvailableBalanceWithoutBuyOrderFeeRestRequest' is not null or undefined
            assertParamExists('getUserAvailableBalanceWithoutBuyOrderFeeV2', 'getUserAvailableBalanceWithoutBuyOrderFeeRestRequest', getUserAvailableBalanceWithoutBuyOrderFeeRestRequest)
            const localVarPath = `/p2p/public-api/v2/offer/order/get-user-available-balance-without-buy-fee`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getUserAvailableBalanceWithoutBuyOrderFeeRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderApi - functional programming interface
 * @export
 */
export const OrderApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrderApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AcceptOrderRestRequest} acceptOrderRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptOrderV2(acceptOrderRestRequest: AcceptOrderRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailedRestResponseAcceptOrderRestStatusAcceptOrderErrorDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptOrderV2(acceptOrderRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OrderIdRestRequest} orderIdRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelOrderByBuyerV2(orderIdRestRequest: OrderIdRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseCancelRestStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelOrderByBuyerV2(orderIdRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OrderIdRestRequest} orderIdRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelOrderBySellerV2(orderIdRestRequest: OrderIdRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseCancelRestStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelOrderBySellerV2(orderIdRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OrderConfirmRestRequest} orderConfirmRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmOrderV2(orderConfirmRestRequest: OrderConfirmRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailedRestResponseConfirmOrderRestStatusConfirmOrderErrorDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmOrderV2(orderConfirmRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ConfirmReceiptPaymentRestRequest} confirmReceiptPaymentRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmReceiptPaymentV2(confirmReceiptPaymentRestRequest: ConfirmReceiptPaymentRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseConfirmReceiptPaymentRestStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmReceiptPaymentV2(confirmReceiptPaymentRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ConfirmSendingPaymentRestRequest} confirmSendingPaymentRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmSendingPaymentV2(confirmSendingPaymentRestRequest: ConfirmSendingPaymentRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseConfirmSendingPaymentRestStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmSendingPaymentV2(confirmSendingPaymentRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ByAmount} byAmount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrderByAmountV2(byAmount: ByAmount, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseCreateOrderRestStatusOrderRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrderByAmountV2(byAmount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ByVolume} byVolume 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrderByVolumeV2(byVolume: ByVolume, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseCreateOrderRestStatusOrderRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrderByVolumeV2(byVolume, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OrderIdRestRequest} orderIdRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderByIdV2(orderIdRestRequest: OrderIdRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseGetOrderRestStatusOrderRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderByIdV2(orderIdRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UserOrderHistoryRequest} userOrderHistoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrdersHistoryByUserIdV2(userOrderHistoryRequest: UserOrderHistoryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseGetOrdersByUserRestStatusListOrderRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrdersHistoryByUserIdV2(userOrderHistoryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {GetUserAvailableBalanceWithoutBuyOrderFeeRestRequest} getUserAvailableBalanceWithoutBuyOrderFeeRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAvailableBalanceWithoutBuyOrderFeeV2(getUserAvailableBalanceWithoutBuyOrderFeeRestRequest: GetUserAvailableBalanceWithoutBuyOrderFeeRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseGetUserAvailableBalanceWithoutBuyOrderFeeStatusGetUserAvailableBalanceWithoutBuyOrderFeeRestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAvailableBalanceWithoutBuyOrderFeeV2(getUserAvailableBalanceWithoutBuyOrderFeeRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrderApi - factory interface
 * @export
 */
export const OrderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrderApiFp(configuration)
    return {
        /**
         * 
         * @param {AcceptOrderRestRequest} acceptOrderRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptOrderV2(acceptOrderRestRequest: AcceptOrderRestRequest, options?: any): AxiosPromise<DetailedRestResponseAcceptOrderRestStatusAcceptOrderErrorDetails> {
            return localVarFp.acceptOrderV2(acceptOrderRestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OrderIdRestRequest} orderIdRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrderByBuyerV2(orderIdRestRequest: OrderIdRestRequest, options?: any): AxiosPromise<RestResponseCancelRestStatus> {
            return localVarFp.cancelOrderByBuyerV2(orderIdRestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OrderIdRestRequest} orderIdRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrderBySellerV2(orderIdRestRequest: OrderIdRestRequest, options?: any): AxiosPromise<RestResponseCancelRestStatus> {
            return localVarFp.cancelOrderBySellerV2(orderIdRestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OrderConfirmRestRequest} orderConfirmRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmOrderV2(orderConfirmRestRequest: OrderConfirmRestRequest, options?: any): AxiosPromise<DetailedRestResponseConfirmOrderRestStatusConfirmOrderErrorDetails> {
            return localVarFp.confirmOrderV2(orderConfirmRestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ConfirmReceiptPaymentRestRequest} confirmReceiptPaymentRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmReceiptPaymentV2(confirmReceiptPaymentRestRequest: ConfirmReceiptPaymentRestRequest, options?: any): AxiosPromise<RestResponseConfirmReceiptPaymentRestStatus> {
            return localVarFp.confirmReceiptPaymentV2(confirmReceiptPaymentRestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ConfirmSendingPaymentRestRequest} confirmSendingPaymentRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmSendingPaymentV2(confirmSendingPaymentRestRequest: ConfirmSendingPaymentRestRequest, options?: any): AxiosPromise<RestResponseConfirmSendingPaymentRestStatus> {
            return localVarFp.confirmSendingPaymentV2(confirmSendingPaymentRestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ByAmount} byAmount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderByAmountV2(byAmount: ByAmount, options?: any): AxiosPromise<RestDataResponseCreateOrderRestStatusOrderRestDto> {
            return localVarFp.createOrderByAmountV2(byAmount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ByVolume} byVolume 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderByVolumeV2(byVolume: ByVolume, options?: any): AxiosPromise<RestDataResponseCreateOrderRestStatusOrderRestDto> {
            return localVarFp.createOrderByVolumeV2(byVolume, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OrderIdRestRequest} orderIdRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderByIdV2(orderIdRestRequest: OrderIdRestRequest, options?: any): AxiosPromise<RestDataResponseGetOrderRestStatusOrderRestDto> {
            return localVarFp.getOrderByIdV2(orderIdRestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserOrderHistoryRequest} userOrderHistoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersHistoryByUserIdV2(userOrderHistoryRequest: UserOrderHistoryRequest, options?: any): AxiosPromise<RestDataResponseGetOrdersByUserRestStatusListOrderRestDto> {
            return localVarFp.getOrdersHistoryByUserIdV2(userOrderHistoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetUserAvailableBalanceWithoutBuyOrderFeeRestRequest} getUserAvailableBalanceWithoutBuyOrderFeeRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAvailableBalanceWithoutBuyOrderFeeV2(getUserAvailableBalanceWithoutBuyOrderFeeRestRequest: GetUserAvailableBalanceWithoutBuyOrderFeeRestRequest, options?: any): AxiosPromise<RestDataResponseGetUserAvailableBalanceWithoutBuyOrderFeeStatusGetUserAvailableBalanceWithoutBuyOrderFeeRestResponse> {
            return localVarFp.getUserAvailableBalanceWithoutBuyOrderFeeV2(getUserAvailableBalanceWithoutBuyOrderFeeRestRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrderApi - object-oriented interface
 * @export
 * @class OrderApi
 * @extends {BaseAPI}
 */
export class OrderApi extends BaseAPI {
    /**
     * 
     * @param {AcceptOrderRestRequest} acceptOrderRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public acceptOrderV2(acceptOrderRestRequest: AcceptOrderRestRequest, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).acceptOrderV2(acceptOrderRestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OrderIdRestRequest} orderIdRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public cancelOrderByBuyerV2(orderIdRestRequest: OrderIdRestRequest, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).cancelOrderByBuyerV2(orderIdRestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OrderIdRestRequest} orderIdRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public cancelOrderBySellerV2(orderIdRestRequest: OrderIdRestRequest, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).cancelOrderBySellerV2(orderIdRestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OrderConfirmRestRequest} orderConfirmRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public confirmOrderV2(orderConfirmRestRequest: OrderConfirmRestRequest, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).confirmOrderV2(orderConfirmRestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ConfirmReceiptPaymentRestRequest} confirmReceiptPaymentRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public confirmReceiptPaymentV2(confirmReceiptPaymentRestRequest: ConfirmReceiptPaymentRestRequest, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).confirmReceiptPaymentV2(confirmReceiptPaymentRestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ConfirmSendingPaymentRestRequest} confirmSendingPaymentRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public confirmSendingPaymentV2(confirmSendingPaymentRestRequest: ConfirmSendingPaymentRestRequest, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).confirmSendingPaymentV2(confirmSendingPaymentRestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ByAmount} byAmount 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public createOrderByAmountV2(byAmount: ByAmount, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).createOrderByAmountV2(byAmount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ByVolume} byVolume 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public createOrderByVolumeV2(byVolume: ByVolume, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).createOrderByVolumeV2(byVolume, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OrderIdRestRequest} orderIdRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getOrderByIdV2(orderIdRestRequest: OrderIdRestRequest, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).getOrderByIdV2(orderIdRestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserOrderHistoryRequest} userOrderHistoryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getOrdersHistoryByUserIdV2(userOrderHistoryRequest: UserOrderHistoryRequest, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).getOrdersHistoryByUserIdV2(userOrderHistoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetUserAvailableBalanceWithoutBuyOrderFeeRestRequest} getUserAvailableBalanceWithoutBuyOrderFeeRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getUserAvailableBalanceWithoutBuyOrderFeeV2(getUserAvailableBalanceWithoutBuyOrderFeeRestRequest: GetUserAvailableBalanceWithoutBuyOrderFeeRestRequest, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).getUserAvailableBalanceWithoutBuyOrderFeeV2(getUserAvailableBalanceWithoutBuyOrderFeeRestRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrderChatApi - axios parameter creator
 * @export
 */
export const OrderChatApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {OpenChatInternalRestRequest} openChatInternalRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openChatFromBot: async (openChatInternalRestRequest: OpenChatInternalRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'openChatInternalRestRequest' is not null or undefined
            assertParamExists('openChatFromBot', 'openChatInternalRestRequest', openChatInternalRestRequest)
            const localVarPath = `/p2p/internal-api/v1/offer/order/chat/open`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(openChatInternalRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OpenChatPublicRestRequest} openChatPublicRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openChatFromWebview: async (openChatPublicRestRequest: OpenChatPublicRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'openChatPublicRestRequest' is not null or undefined
            assertParamExists('openChatFromWebview', 'openChatPublicRestRequest', openChatPublicRestRequest)
            const localVarPath = `/p2p/public-api/v1/offer/order/chat/open`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(openChatPublicRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OpenChatPublicRestRequest} openChatPublicRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openChatFromWebviewV2: async (openChatPublicRestRequest: OpenChatPublicRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'openChatPublicRestRequest' is not null or undefined
            assertParamExists('openChatFromWebviewV2', 'openChatPublicRestRequest', openChatPublicRestRequest)
            const localVarPath = `/p2p/public-api/v2/offer/order/chat/open`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(openChatPublicRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SendAttachmentRestRequest} sendAttachmentRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendAttachment: async (sendAttachmentRestRequest: SendAttachmentRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendAttachmentRestRequest' is not null or undefined
            assertParamExists('sendAttachment', 'sendAttachmentRestRequest', sendAttachmentRestRequest)
            const localVarPath = `/p2p/internal-api/v1/offer/order/chat/send-attachment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendAttachmentRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SendMessageRestRequest} sendMessageRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessage: async (sendMessageRestRequest: SendMessageRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendMessageRestRequest' is not null or undefined
            assertParamExists('sendMessage', 'sendMessageRestRequest', sendMessageRestRequest)
            const localVarPath = `/p2p/internal-api/v1/offer/order/chat/send-message`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendMessageRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderChatApi - functional programming interface
 * @export
 */
export const OrderChatApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrderChatApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {OpenChatInternalRestRequest} openChatInternalRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async openChatFromBot(openChatInternalRestRequest: OpenChatInternalRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseOpenChatRestStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.openChatFromBot(openChatInternalRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OpenChatPublicRestRequest} openChatPublicRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async openChatFromWebview(openChatPublicRestRequest: OpenChatPublicRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseOpenChatRestStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.openChatFromWebview(openChatPublicRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OpenChatPublicRestRequest} openChatPublicRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async openChatFromWebviewV2(openChatPublicRestRequest: OpenChatPublicRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseOpenChatRestStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.openChatFromWebviewV2(openChatPublicRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SendAttachmentRestRequest} sendAttachmentRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendAttachment(sendAttachmentRestRequest: SendAttachmentRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseSendAttachmentRestStatusSendAttachmentRestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendAttachment(sendAttachmentRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SendMessageRestRequest} sendMessageRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendMessage(sendMessageRestRequest: SendMessageRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseSendMessageRestStatusSendMessageRestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendMessage(sendMessageRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrderChatApi - factory interface
 * @export
 */
export const OrderChatApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrderChatApiFp(configuration)
    return {
        /**
         * 
         * @param {OpenChatInternalRestRequest} openChatInternalRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openChatFromBot(openChatInternalRestRequest: OpenChatInternalRestRequest, options?: any): AxiosPromise<RestResponseOpenChatRestStatus> {
            return localVarFp.openChatFromBot(openChatInternalRestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OpenChatPublicRestRequest} openChatPublicRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openChatFromWebview(openChatPublicRestRequest: OpenChatPublicRestRequest, options?: any): AxiosPromise<RestResponseOpenChatRestStatus> {
            return localVarFp.openChatFromWebview(openChatPublicRestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OpenChatPublicRestRequest} openChatPublicRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openChatFromWebviewV2(openChatPublicRestRequest: OpenChatPublicRestRequest, options?: any): AxiosPromise<RestResponseOpenChatRestStatus> {
            return localVarFp.openChatFromWebviewV2(openChatPublicRestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SendAttachmentRestRequest} sendAttachmentRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendAttachment(sendAttachmentRestRequest: SendAttachmentRestRequest, options?: any): AxiosPromise<RestDataResponseSendAttachmentRestStatusSendAttachmentRestResponse> {
            return localVarFp.sendAttachment(sendAttachmentRestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SendMessageRestRequest} sendMessageRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessage(sendMessageRestRequest: SendMessageRestRequest, options?: any): AxiosPromise<RestDataResponseSendMessageRestStatusSendMessageRestResponse> {
            return localVarFp.sendMessage(sendMessageRestRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrderChatApi - object-oriented interface
 * @export
 * @class OrderChatApi
 * @extends {BaseAPI}
 */
export class OrderChatApi extends BaseAPI {
    /**
     * 
     * @param {OpenChatInternalRestRequest} openChatInternalRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderChatApi
     */
    public openChatFromBot(openChatInternalRestRequest: OpenChatInternalRestRequest, options?: AxiosRequestConfig) {
        return OrderChatApiFp(this.configuration).openChatFromBot(openChatInternalRestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OpenChatPublicRestRequest} openChatPublicRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderChatApi
     */
    public openChatFromWebview(openChatPublicRestRequest: OpenChatPublicRestRequest, options?: AxiosRequestConfig) {
        return OrderChatApiFp(this.configuration).openChatFromWebview(openChatPublicRestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OpenChatPublicRestRequest} openChatPublicRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderChatApi
     */
    public openChatFromWebviewV2(openChatPublicRestRequest: OpenChatPublicRestRequest, options?: AxiosRequestConfig) {
        return OrderChatApiFp(this.configuration).openChatFromWebviewV2(openChatPublicRestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SendAttachmentRestRequest} sendAttachmentRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderChatApi
     */
    public sendAttachment(sendAttachmentRestRequest: SendAttachmentRestRequest, options?: AxiosRequestConfig) {
        return OrderChatApiFp(this.configuration).sendAttachment(sendAttachmentRestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SendMessageRestRequest} sendMessageRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderChatApi
     */
    public sendMessage(sendMessageRestRequest: SendMessageRestRequest, options?: AxiosRequestConfig) {
        return OrderChatApiFp(this.configuration).sendMessage(sendMessageRestRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrderControllerApi - axios parameter creator
 * @export
 */
export const OrderControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} limit 
         * @param {number} offset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenOrders: async (limit: number, offset: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('getOpenOrders', 'limit', limit)
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('getOpenOrders', 'offset', offset)
            const localVarPath = `/p2p/merchant-api/v1/order/open-orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrder: async (orderId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('getOrder', 'orderId', orderId)
            const localVarPath = `/p2p/merchant-api/v1/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderControllerApi - functional programming interface
 * @export
 */
export const OrderControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrderControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} limit 
         * @param {number} offset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOpenOrders(limit: number, offset: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MerchantApiResponseGetOpenOrdersStatusPageOrderLong>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOpenOrders(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrder(orderId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MerchantApiResponseGetOrderStatusOrder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrder(orderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrderControllerApi - factory interface
 * @export
 */
export const OrderControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrderControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {number} limit 
         * @param {number} offset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenOrders(limit: number, offset: number, options?: any): AxiosPromise<MerchantApiResponseGetOpenOrdersStatusPageOrderLong> {
            return localVarFp.getOpenOrders(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrder(orderId: number, options?: any): AxiosPromise<MerchantApiResponseGetOrderStatusOrder> {
            return localVarFp.getOrder(orderId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrderControllerApi - object-oriented interface
 * @export
 * @class OrderControllerApi
 * @extends {BaseAPI}
 */
export class OrderControllerApi extends BaseAPI {
    /**
     * 
     * @param {number} limit 
     * @param {number} offset 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderControllerApi
     */
    public getOpenOrders(limit: number, offset: number, options?: AxiosRequestConfig) {
        return OrderControllerApiFp(this.configuration).getOpenOrders(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} orderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderControllerApi
     */
    public getOrder(orderId: number, options?: AxiosRequestConfig) {
        return OrderControllerApiFp(this.configuration).getOrder(orderId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PaymentDetailsApi - axios parameter creator
 * @export
 */
export const PaymentDetailsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Создание реквизитов пользователя
         * @param {CreatePaymentDetailsRestRequest} createPaymentDetailsRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentDetailsV2: async (createPaymentDetailsRestRequest: CreatePaymentDetailsRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPaymentDetailsRestRequest' is not null or undefined
            assertParamExists('createPaymentDetailsV2', 'createPaymentDetailsRestRequest', createPaymentDetailsRestRequest)
            const localVarPath = `/p2p/public-api/v2/payment-details/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPaymentDetailsRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Удаление реквизитов пользователя
         * @param {DeletePaymentDetailsRestRequest} deletePaymentDetailsRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentDetailsV2: async (deletePaymentDetailsRestRequest: DeletePaymentDetailsRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deletePaymentDetailsRestRequest' is not null or undefined
            assertParamExists('deletePaymentDetailsV2', 'deletePaymentDetailsRestRequest', deletePaymentDetailsRestRequest)
            const localVarPath = `/p2p/public-api/v2/payment-details/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deletePaymentDetailsRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Редактирование реквизитов пользователя
         * @param {EditPaymentDetailsRestRequest} editPaymentDetailsRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editPaymentDetailsV2: async (editPaymentDetailsRestRequest: EditPaymentDetailsRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'editPaymentDetailsRestRequest' is not null or undefined
            assertParamExists('editPaymentDetailsV2', 'editPaymentDetailsRestRequest', editPaymentDetailsRestRequest)
            const localVarPath = `/p2p/public-api/v2/payment-details/edit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editPaymentDetailsRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение методов оплаты поддерживающие выбранную для обмена фиатную валюту
         * @param {CurrencyCodeRestRequest} currencyCodeRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllPaymentMethodsByCurrencyCodeV2: async (currencyCodeRestRequest: CurrencyCodeRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'currencyCodeRestRequest' is not null or undefined
            assertParamExists('findAllPaymentMethodsByCurrencyCodeV2', 'currencyCodeRestRequest', currencyCodeRestRequest)
            const localVarPath = `/p2p/public-api/v2/payment-details/get-methods/by-currency-code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(currencyCodeRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение реквизитов пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPaymentDetailsByUserIdV2: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/p2p/public-api/v2/payment-details/get/by-user-id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение схемы метода оплаты поддерживающие выбранную для обмена фиатную валюту
         * @param {FindPaymentMethodSchemaRestRequest} findPaymentMethodSchemaRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPaymentMethodSchema: async (findPaymentMethodSchemaRestRequest: FindPaymentMethodSchemaRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'findPaymentMethodSchemaRestRequest' is not null or undefined
            assertParamExists('findPaymentMethodSchema', 'findPaymentMethodSchemaRestRequest', findPaymentMethodSchemaRestRequest)
            const localVarPath = `/p2p/public-api/v2/payment-details/get-method-schema`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(findPaymentMethodSchemaRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentDetailsApi - functional programming interface
 * @export
 */
export const PaymentDetailsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentDetailsApiAxiosParamCreator(configuration)
    return {
        /**
         * Создание реквизитов пользователя
         * @param {CreatePaymentDetailsRestRequest} createPaymentDetailsRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPaymentDetailsV2(createPaymentDetailsRestRequest: CreatePaymentDetailsRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseCreatePaymentDetailsStatusPaymentDetailsRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPaymentDetailsV2(createPaymentDetailsRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Удаление реквизитов пользователя
         * @param {DeletePaymentDetailsRestRequest} deletePaymentDetailsRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePaymentDetailsV2(deletePaymentDetailsRestRequest: DeletePaymentDetailsRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseDeletePaymentDetailsStatusDeletedPaymentDetailsRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePaymentDetailsV2(deletePaymentDetailsRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Редактирование реквизитов пользователя
         * @param {EditPaymentDetailsRestRequest} editPaymentDetailsRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editPaymentDetailsV2(editPaymentDetailsRestRequest: EditPaymentDetailsRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseEditPaymentDetailsStatusPaymentDetailsRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editPaymentDetailsV2(editPaymentDetailsRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Получение методов оплаты поддерживающие выбранную для обмена фиатную валюту
         * @param {CurrencyCodeRestRequest} currencyCodeRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllPaymentMethodsByCurrencyCodeV2(currencyCodeRestRequest: CurrencyCodeRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseFindPaymentMethodsStatusListPaymentMethodRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllPaymentMethodsByCurrencyCodeV2(currencyCodeRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Получение реквизитов пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findPaymentDetailsByUserIdV2(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseFindPaymentDetailsStatusListPaymentDetailsRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findPaymentDetailsByUserIdV2(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Получение схемы метода оплаты поддерживающие выбранную для обмена фиатную валюту
         * @param {FindPaymentMethodSchemaRestRequest} findPaymentMethodSchemaRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findPaymentMethodSchema(findPaymentMethodSchemaRestRequest: FindPaymentMethodSchemaRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseFindPaymentMethodSchemaStatusAttributeTypesRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findPaymentMethodSchema(findPaymentMethodSchemaRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PaymentDetailsApi - factory interface
 * @export
 */
export const PaymentDetailsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentDetailsApiFp(configuration)
    return {
        /**
         * Создание реквизитов пользователя
         * @param {CreatePaymentDetailsRestRequest} createPaymentDetailsRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentDetailsV2(createPaymentDetailsRestRequest: CreatePaymentDetailsRestRequest, options?: any): AxiosPromise<RestDataResponseCreatePaymentDetailsStatusPaymentDetailsRestDto> {
            return localVarFp.createPaymentDetailsV2(createPaymentDetailsRestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Удаление реквизитов пользователя
         * @param {DeletePaymentDetailsRestRequest} deletePaymentDetailsRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentDetailsV2(deletePaymentDetailsRestRequest: DeletePaymentDetailsRestRequest, options?: any): AxiosPromise<RestDataResponseDeletePaymentDetailsStatusDeletedPaymentDetailsRestDto> {
            return localVarFp.deletePaymentDetailsV2(deletePaymentDetailsRestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Редактирование реквизитов пользователя
         * @param {EditPaymentDetailsRestRequest} editPaymentDetailsRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editPaymentDetailsV2(editPaymentDetailsRestRequest: EditPaymentDetailsRestRequest, options?: any): AxiosPromise<RestDataResponseEditPaymentDetailsStatusPaymentDetailsRestDto> {
            return localVarFp.editPaymentDetailsV2(editPaymentDetailsRestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Получение методов оплаты поддерживающие выбранную для обмена фиатную валюту
         * @param {CurrencyCodeRestRequest} currencyCodeRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllPaymentMethodsByCurrencyCodeV2(currencyCodeRestRequest: CurrencyCodeRestRequest, options?: any): AxiosPromise<RestDataResponseFindPaymentMethodsStatusListPaymentMethodRestDto> {
            return localVarFp.findAllPaymentMethodsByCurrencyCodeV2(currencyCodeRestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Получение реквизитов пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPaymentDetailsByUserIdV2(options?: any): AxiosPromise<RestDataResponseFindPaymentDetailsStatusListPaymentDetailsRestDto> {
            return localVarFp.findPaymentDetailsByUserIdV2(options).then((request) => request(axios, basePath));
        },
        /**
         * Получение схемы метода оплаты поддерживающие выбранную для обмена фиатную валюту
         * @param {FindPaymentMethodSchemaRestRequest} findPaymentMethodSchemaRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPaymentMethodSchema(findPaymentMethodSchemaRestRequest: FindPaymentMethodSchemaRestRequest, options?: any): AxiosPromise<RestDataResponseFindPaymentMethodSchemaStatusAttributeTypesRestDto> {
            return localVarFp.findPaymentMethodSchema(findPaymentMethodSchemaRestRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentDetailsApi - object-oriented interface
 * @export
 * @class PaymentDetailsApi
 * @extends {BaseAPI}
 */
export class PaymentDetailsApi extends BaseAPI {
    /**
     * Создание реквизитов пользователя
     * @param {CreatePaymentDetailsRestRequest} createPaymentDetailsRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentDetailsApi
     */
    public createPaymentDetailsV2(createPaymentDetailsRestRequest: CreatePaymentDetailsRestRequest, options?: AxiosRequestConfig) {
        return PaymentDetailsApiFp(this.configuration).createPaymentDetailsV2(createPaymentDetailsRestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Удаление реквизитов пользователя
     * @param {DeletePaymentDetailsRestRequest} deletePaymentDetailsRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentDetailsApi
     */
    public deletePaymentDetailsV2(deletePaymentDetailsRestRequest: DeletePaymentDetailsRestRequest, options?: AxiosRequestConfig) {
        return PaymentDetailsApiFp(this.configuration).deletePaymentDetailsV2(deletePaymentDetailsRestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Редактирование реквизитов пользователя
     * @param {EditPaymentDetailsRestRequest} editPaymentDetailsRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentDetailsApi
     */
    public editPaymentDetailsV2(editPaymentDetailsRestRequest: EditPaymentDetailsRestRequest, options?: AxiosRequestConfig) {
        return PaymentDetailsApiFp(this.configuration).editPaymentDetailsV2(editPaymentDetailsRestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение методов оплаты поддерживающие выбранную для обмена фиатную валюту
     * @param {CurrencyCodeRestRequest} currencyCodeRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentDetailsApi
     */
    public findAllPaymentMethodsByCurrencyCodeV2(currencyCodeRestRequest: CurrencyCodeRestRequest, options?: AxiosRequestConfig) {
        return PaymentDetailsApiFp(this.configuration).findAllPaymentMethodsByCurrencyCodeV2(currencyCodeRestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение реквизитов пользователя
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentDetailsApi
     */
    public findPaymentDetailsByUserIdV2(options?: AxiosRequestConfig) {
        return PaymentDetailsApiFp(this.configuration).findPaymentDetailsByUserIdV2(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение схемы метода оплаты поддерживающие выбранную для обмена фиатную валюту
     * @param {FindPaymentMethodSchemaRestRequest} findPaymentMethodSchemaRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentDetailsApi
     */
    public findPaymentMethodSchema(findPaymentMethodSchemaRestRequest: FindPaymentMethodSchemaRestRequest, options?: AxiosRequestConfig) {
        return PaymentDetailsApiFp(this.configuration).findPaymentMethodSchema(findPaymentMethodSchemaRestRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProfilerReporterRestApi - axios parameter creator
 * @export
 */
export const ProfilerReporterRestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metrics: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system/prometheus/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfilerReporterRestApi - functional programming interface
 * @export
 */
export const ProfilerReporterRestApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfilerReporterRestApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metrics(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metrics(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProfilerReporterRestApi - factory interface
 * @export
 */
export const ProfilerReporterRestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfilerReporterRestApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metrics(options?: any): AxiosPromise<string> {
            return localVarFp.metrics(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProfilerReporterRestApi - object-oriented interface
 * @export
 * @class ProfilerReporterRestApi
 * @extends {BaseAPI}
 */
export class ProfilerReporterRestApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilerReporterRestApi
     */
    public metrics(options?: AxiosRequestConfig) {
        return ProfilerReporterRestApiFp(this.configuration).metrics(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RetoolApi - axios parameter creator
 * @export
 */
export const RetoolApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Disable antifraud rule for user
         * @param {DisableAntifraudRestRequest} disableAntifraudRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableAntifraud: async (disableAntifraudRestRequest: DisableAntifraudRestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'disableAntifraudRestRequest' is not null or undefined
            assertParamExists('disableAntifraud', 'disableAntifraudRestRequest', disableAntifraudRestRequest)
            const localVarPath = `/p2p/retool-api/v1/antifraud/disable-rule-for-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(disableAntifraudRestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RetoolApi - functional programming interface
 * @export
 */
export const RetoolApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RetoolApiAxiosParamCreator(configuration)
    return {
        /**
         * Disable antifraud rule for user
         * @param {DisableAntifraudRestRequest} disableAntifraudRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableAntifraud(disableAntifraudRestRequest: DisableAntifraudRestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseDisableAntifraudRestStatusDisableAntifraudRestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableAntifraud(disableAntifraudRestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RetoolApi - factory interface
 * @export
 */
export const RetoolApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RetoolApiFp(configuration)
    return {
        /**
         * Disable antifraud rule for user
         * @param {DisableAntifraudRestRequest} disableAntifraudRestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableAntifraud(disableAntifraudRestRequest: DisableAntifraudRestRequest, options?: any): AxiosPromise<RestDataResponseDisableAntifraudRestStatusDisableAntifraudRestResponse> {
            return localVarFp.disableAntifraud(disableAntifraudRestRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RetoolApi - object-oriented interface
 * @export
 * @class RetoolApi
 * @extends {BaseAPI}
 */
export class RetoolApi extends BaseAPI {
    /**
     * Disable antifraud rule for user
     * @param {DisableAntifraudRestRequest} disableAntifraudRestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RetoolApi
     */
    public disableAntifraud(disableAntifraudRestRequest: DisableAntifraudRestRequest, options?: AxiosRequestConfig) {
        return RetoolApiFp(this.configuration).disableAntifraud(disableAntifraudRestRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserSettingsApi - axios parameter creator
 * @export
 */
export const UserSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Выключить торги пользователя, объявления перестанут показываться в стакане
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableBiddingV2: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/p2p/public-api/v2/user-settings/disable-bidding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Включить торги пользователя, объявления начнут показываться в стакане
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableBiddingV2: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/p2p/public-api/v2/user-settings/enable-bidding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Узнать, какие A/B тесты включены у пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getABTests: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/p2p/public-api/v2/user-settings/get-ab-tests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Узнать, включены ли торги у пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBiddingSettingsV2: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/p2p/public-api/v2/user-settings/get-bidding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserSettingsApi - functional programming interface
 * @export
 */
export const UserSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Выключить торги пользователя, объявления перестанут показываться в стакане
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableBiddingV2(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseBiddingSettingsResponseStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableBiddingV2(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Включить торги пользователя, объявления начнут показываться в стакане
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableBiddingV2(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponseBiddingSettingsResponseStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableBiddingV2(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Узнать, какие A/B тесты включены у пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getABTests(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseGetAbTestsStatusABTestsDict>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getABTests(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Узнать, включены ли торги у пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBiddingSettingsV2(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseBiddingSettingsResponseStatusBiddingSettingsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBiddingSettingsV2(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserSettingsApi - factory interface
 * @export
 */
export const UserSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserSettingsApiFp(configuration)
    return {
        /**
         * Выключить торги пользователя, объявления перестанут показываться в стакане
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableBiddingV2(options?: any): AxiosPromise<RestResponseBiddingSettingsResponseStatus> {
            return localVarFp.disableBiddingV2(options).then((request) => request(axios, basePath));
        },
        /**
         * Включить торги пользователя, объявления начнут показываться в стакане
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableBiddingV2(options?: any): AxiosPromise<RestResponseBiddingSettingsResponseStatus> {
            return localVarFp.enableBiddingV2(options).then((request) => request(axios, basePath));
        },
        /**
         * Узнать, какие A/B тесты включены у пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getABTests(options?: any): AxiosPromise<RestDataResponseGetAbTestsStatusABTestsDict> {
            return localVarFp.getABTests(options).then((request) => request(axios, basePath));
        },
        /**
         * Узнать, включены ли торги у пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBiddingSettingsV2(options?: any): AxiosPromise<RestDataResponseBiddingSettingsResponseStatusBiddingSettingsDto> {
            return localVarFp.getBiddingSettingsV2(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserSettingsApi - object-oriented interface
 * @export
 * @class UserSettingsApi
 * @extends {BaseAPI}
 */
export class UserSettingsApi extends BaseAPI {
    /**
     * Выключить торги пользователя, объявления перестанут показываться в стакане
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSettingsApi
     */
    public disableBiddingV2(options?: AxiosRequestConfig) {
        return UserSettingsApiFp(this.configuration).disableBiddingV2(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Включить торги пользователя, объявления начнут показываться в стакане
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSettingsApi
     */
    public enableBiddingV2(options?: AxiosRequestConfig) {
        return UserSettingsApiFp(this.configuration).enableBiddingV2(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Узнать, какие A/B тесты включены у пользователя
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSettingsApi
     */
    public getABTests(options?: AxiosRequestConfig) {
        return UserSettingsApiFp(this.configuration).getABTests(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Узнать, включены ли торги у пользователя
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSettingsApi
     */
    public getBiddingSettingsV2(options?: AxiosRequestConfig) {
        return UserSettingsApiFp(this.configuration).getBiddingSettingsV2(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserStatisticsApi - axios parameter creator
 * @export
 */
export const UserStatisticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Получить статистику пользователя для отображения в личном кабинете
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserStatisticsV2: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/p2p/public-api/v2/user-statistics/get/by-user-id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserStatisticsApi - functional programming interface
 * @export
 */
export const UserStatisticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserStatisticsApiAxiosParamCreator(configuration)
    return {
        /**
         * Получить статистику пользователя для отображения в личном кабинете
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserStatisticsV2(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseGetUserStatisticsResponseStatusUserStatisticsRestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserStatisticsV2(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserStatisticsApi - factory interface
 * @export
 */
export const UserStatisticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserStatisticsApiFp(configuration)
    return {
        /**
         * Получить статистику пользователя для отображения в личном кабинете
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserStatisticsV2(options?: any): AxiosPromise<RestDataResponseGetUserStatisticsResponseStatusUserStatisticsRestDto> {
            return localVarFp.getUserStatisticsV2(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserStatisticsApi - object-oriented interface
 * @export
 * @class UserStatisticsApi
 * @extends {BaseAPI}
 */
export class UserStatisticsApi extends BaseAPI {
    /**
     * Получить статистику пользователя для отображения в личном кабинете
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserStatisticsApi
     */
    public getUserStatisticsV2(options?: AxiosRequestConfig) {
        return UserStatisticsApiFp(this.configuration).getUserStatisticsV2(options).then((request) => request(this.axios, this.basePath));
    }
}


