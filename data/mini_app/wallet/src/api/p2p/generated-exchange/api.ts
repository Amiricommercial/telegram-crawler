/* tslint:disable */

/* eslint-disable */

/**
 * Exchange Rate Provider
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: DEVELOPMENT
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import globalAxios, {
  AxiosInstance,
  AxiosPromise,
  AxiosRequestConfig,
} from 'axios';

// @ts-ignore
import {
  BASE_PATH,
  BaseAPI,
  COLLECTION_FORMATS,
  RequestArgs,
  RequiredError,
} from './base';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  createRequestFunction,
  serializeDataIfNeeded,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  toPathString,
} from './common';
import { Configuration } from './configuration';

/**
 *
 * @export
 * @interface ApiUsage
 */
export interface ApiUsage {
  /**
   *
   * @type {RequestsUsage}
   * @memberof ApiUsage
   */
  current_minute: RequestsUsage;
  /**
   *
   * @type {CreditsUsage}
   * @memberof ApiUsage
   */
  current_day: CreditsUsage;
  /**
   *
   * @type {CreditsUsage}
   * @memberof ApiUsage
   */
  current_month: CreditsUsage;
}
/**
 *
 * @export
 * @interface ApplicationInfo
 */
export interface ApplicationInfo {
  /**
   *
   * @type {string}
   * @memberof ApplicationInfo
   */
  app_name: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationInfo
   */
  app_version: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationInfo
   */
  host_name?: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationInfo
   */
  app_time: string;
}
/**
 *
 * @export
 * @interface CreditsUsage
 */
export interface CreditsUsage {
  /**
   *
   * @type {number}
   * @memberof CreditsUsage
   */
  credits_used: number;
  /**
   *
   * @type {number}
   * @memberof CreditsUsage
   */
  credits_left: number;
}
/**
 *
 * @export
 * @interface HealthStatusResponse
 */
export interface HealthStatusResponse {
  /**
   *
   * @type {string}
   * @memberof HealthStatusResponse
   */
  instance_id: string;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof HealthStatusResponse
   */
  resources_status: { [key: string]: string };
}

export const HealthStatusResponseResourcesStatusEnum = {
  Ok: 'OK',
  ConnectionFailed: 'CONNECTION_FAILED',
} as const;

export type HealthStatusResponseResourcesStatusEnum =
  typeof HealthStatusResponseResourcesStatusEnum[keyof typeof HealthStatusResponseResourcesStatusEnum];

/**
 *
 * @export
 * @interface KeyInfo
 */
export interface KeyInfo {
  /**
   *
   * @type {ApiUsage}
   * @memberof KeyInfo
   */
  usage: ApiUsage;
}
/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface RateDto
 */
export interface RateDto {
  /**
   *
   * @type {string}
   * @memberof RateDto
   */
  base: string;
  /**
   *
   * @type {string}
   * @memberof RateDto
   */
  quote: string;
  /**
   *
   * @type {string}
   * @memberof RateDto
   */
  rate: string;
  /**
   *
   * @type {string}
   * @memberof RateDto
   */
  lastUpdateDateTime: string;
}
/**
 *
 * @export
 * @interface RequestsUsage
 */
export interface RequestsUsage {
  /**
   *
   * @type {number}
   * @memberof RequestsUsage
   */
  requests_made: number;
  /**
   *
   * @type {number}
   * @memberof RequestsUsage
   */
  requests_left: number;
}
/**
 *
 * @export
 * @interface RestDataResponseGetRateStatusRateDto
 */
export interface RestDataResponseGetRateStatusRateDto {
  /**
   * Operation result status, always present
   * @type {string}
   * @memberof RestDataResponseGetRateStatusRateDto
   */
  status: RestDataResponseGetRateStatusRateDtoStatusEnum;
  /**
   * Verbose reason of non-success result
   * @type {string}
   * @memberof RestDataResponseGetRateStatusRateDto
   */
  message?: string;
  /**
   *
   * @type {RateDto}
   * @memberof RestDataResponseGetRateStatusRateDto
   */
  data?: RateDto;
}

export const RestDataResponseGetRateStatusRateDtoStatusEnum = {
  Success: 'SUCCESS',
  UnsupportedBaseCurrency: 'UNSUPPORTED_BASE_CURRENCY',
  UnsupportedQuoteCurrency: 'UNSUPPORTED_QUOTE_CURRENCY',
  RateIsNotAvailable: 'RATE_IS_NOT_AVAILABLE',
} as const;

export type RestDataResponseGetRateStatusRateDtoStatusEnum =
  typeof RestDataResponseGetRateStatusRateDtoStatusEnum[keyof typeof RestDataResponseGetRateStatusRateDtoStatusEnum];

/**
 * ApplicationRestApi - axios parameter creator
 * @export
 */
export const ApplicationRestApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCoinMarketCapKeyInfo: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/system/coin-market-cap/key-info`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatus: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/system/info`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ApplicationRestApi - functional programming interface
 * @export
 */
export const ApplicationRestApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ApplicationRestApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCoinMarketCapKeyInfo(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyInfo>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCoinMarketCapKeyInfo(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStatus(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ApplicationInfo>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStatus(
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * ApplicationRestApi - factory interface
 * @export
 */
export const ApplicationRestApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ApplicationRestApiFp(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCoinMarketCapKeyInfo(options?: any): AxiosPromise<KeyInfo> {
      return localVarFp
        .getCoinMarketCapKeyInfo(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatus(options?: any): AxiosPromise<ApplicationInfo> {
      return localVarFp
        .getStatus(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ApplicationRestApi - object-oriented interface
 * @export
 * @class ApplicationRestApi
 * @extends {BaseAPI}
 */
export class ApplicationRestApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApplicationRestApi
   */
  public getCoinMarketCapKeyInfo(options?: AxiosRequestConfig) {
    return ApplicationRestApiFp(this.configuration)
      .getCoinMarketCapKeyInfo(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApplicationRestApi
   */
  public getStatus(options?: AxiosRequestConfig) {
    return ApplicationRestApiFp(this.configuration)
      .getStatus(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * HealthCheckRestApi - axios parameter creator
 * @export
 */
export const HealthCheckRestApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resourcesHealthStatus: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/system/health`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * HealthCheckRestApi - functional programming interface
 * @export
 */
export const HealthCheckRestApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    HealthCheckRestApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async resourcesHealthStatus(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<HealthStatusResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.resourcesHealthStatus(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * HealthCheckRestApi - factory interface
 * @export
 */
export const HealthCheckRestApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = HealthCheckRestApiFp(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resourcesHealthStatus(options?: any): AxiosPromise<HealthStatusResponse> {
      return localVarFp
        .resourcesHealthStatus(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * HealthCheckRestApi - object-oriented interface
 * @export
 * @class HealthCheckRestApi
 * @extends {BaseAPI}
 */
export class HealthCheckRestApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HealthCheckRestApi
   */
  public resourcesHealthStatus(options?: AxiosRequestConfig) {
    return HealthCheckRestApiFp(this.configuration)
      .resourcesHealthStatus(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ProfilerReporterRestApi - axios parameter creator
 * @export
 */
export const ProfilerReporterRestApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metrics: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/system/prometheus/metrics`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ProfilerReporterRestApi - functional programming interface
 * @export
 */
export const ProfilerReporterRestApiFp = function (
  configuration?: Configuration,
) {
  const localVarAxiosParamCreator =
    ProfilerReporterRestApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async metrics(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.metrics(
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * ProfilerReporterRestApi - factory interface
 * @export
 */
export const ProfilerReporterRestApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ProfilerReporterRestApiFp(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metrics(options?: any): AxiosPromise<string> {
      return localVarFp
        .metrics(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ProfilerReporterRestApi - object-oriented interface
 * @export
 * @class ProfilerReporterRestApi
 * @extends {BaseAPI}
 */
export class ProfilerReporterRestApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProfilerReporterRestApi
   */
  public metrics(options?: AxiosRequestConfig) {
    return ProfilerReporterRestApiFp(this.configuration)
      .metrics(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * RateApi - axios parameter creator
 * @export
 */
export const RateApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Получение рыночного курса валют
     * @param {string} base
     * @param {string} quote
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRate: async (
      base: string,
      quote: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'base' is not null or undefined
      assertParamExists('getRate', 'base', base);
      // verify required parameter 'quote' is not null or undefined
      assertParamExists('getRate', 'quote', quote);
      const localVarPath = `/rates/internal-api/v1/rate/crypto-to-fiat`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (base !== undefined) {
        localVarQueryParameter['base'] = base;
      }

      if (quote !== undefined) {
        localVarQueryParameter['quote'] = quote;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Получение рыночного курса валют
     * @param {string} base
     * @param {string} quote
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRate1: async (
      base: string,
      quote: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'base' is not null or undefined
      assertParamExists('getRate1', 'base', base);
      // verify required parameter 'quote' is not null or undefined
      assertParamExists('getRate1', 'quote', quote);
      const localVarPath = `/rates/public-api/v1/rate/crypto-to-fiat`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (base !== undefined) {
        localVarQueryParameter['base'] = base;
      }

      if (quote !== undefined) {
        localVarQueryParameter['quote'] = quote;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RateApi - functional programming interface
 * @export
 */
export const RateApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = RateApiAxiosParamCreator(configuration);
  return {
    /**
     * Получение рыночного курса валют
     * @param {string} base
     * @param {string} quote
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRate(
      base: string,
      quote: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<RestDataResponseGetRateStatusRateDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRate(
        base,
        quote,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Получение рыночного курса валют
     * @param {string} base
     * @param {string} quote
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRate1(
      base: string,
      quote: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<RestDataResponseGetRateStatusRateDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRate1(
        base,
        quote,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * RateApi - factory interface
 * @export
 */
export const RateApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = RateApiFp(configuration);
  return {
    /**
     * Получение рыночного курса валют
     * @param {string} base
     * @param {string} quote
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRate(
      base: string,
      quote: string,
      options?: any,
    ): AxiosPromise<RestDataResponseGetRateStatusRateDto> {
      return localVarFp
        .getRate(base, quote, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Получение рыночного курса валют
     * @param {string} base
     * @param {string} quote
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRate1(
      base: string,
      quote: string,
      options?: any,
    ): AxiosPromise<RestDataResponseGetRateStatusRateDto> {
      return localVarFp
        .getRate1(base, quote, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * RateApi - object-oriented interface
 * @export
 * @class RateApi
 * @extends {BaseAPI}
 */
export class RateApi extends BaseAPI {
  /**
   * Получение рыночного курса валют
   * @param {string} base
   * @param {string} quote
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RateApi
   */
  public getRate(base: string, quote: string, options?: AxiosRequestConfig) {
    return RateApiFp(this.configuration)
      .getRate(base, quote, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Получение рыночного курса валют
   * @param {string} base
   * @param {string} quote
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RateApi
   */
  public getRate1(base: string, quote: string, options?: AxiosRequestConfig) {
    return RateApiFp(this.configuration)
      .getRate1(base, quote, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
