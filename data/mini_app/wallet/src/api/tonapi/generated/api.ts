/* tslint:disable */

/* eslint-disable */

/**
 * REST api to TON blockchain explorer
 * Provide access to indexed TON blockchain
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: support@tonkeeper.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import globalAxios, {
  AxiosInstance,
  AxiosPromise,
  AxiosRequestConfig,
} from 'axios';

// @ts-ignore
import {
  BASE_PATH,
  BaseAPI,
  COLLECTION_FORMATS,
  RequestArgs,
  RequiredError,
} from './base';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  createRequestFunction,
  serializeDataIfNeeded,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  toPathString,
} from './common';
import { Configuration } from './configuration';

// mannually added due to openapi-generator issue
type UNKNOWN_BASE_TYPE = any;

/**
 *
 * @export
 * @enum {string}
 */

export const AccStatusChange = {
  Unchanged: 'acst_unchanged',
  Frozen: 'acst_frozen',
  Deleted: 'acst_deleted',
} as const;

export type AccStatusChange =
  typeof AccStatusChange[keyof typeof AccStatusChange];

/**
 *
 * @export
 * @interface Account
 */
export interface Account {
  /**
   *
   * @type {string}
   * @memberof Account
   */
  address: string;
  /**
   *
   * @type {number}
   * @memberof Account
   */
  balance: number;
  /**
   * unix timestamp
   * @type {number}
   * @memberof Account
   */
  last_activity: number;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  status: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Account
   */
  interfaces?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  name?: string;
  /**
   *
   * @type {boolean}
   * @memberof Account
   */
  is_scam?: boolean;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  icon?: string;
  /**
   *
   * @type {boolean}
   * @memberof Account
   */
  memo_required?: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof Account
   */
  get_methods: Array<string>;
}
/**
 *
 * @export
 * @interface AccountAddress
 */
export interface AccountAddress {
  /**
   *
   * @type {string}
   * @memberof AccountAddress
   */
  address: string;
  /**
   * Display name. Data collected from different sources like moderation lists, dns, collections names and over.
   * @type {string}
   * @memberof AccountAddress
   */
  name?: string;
  /**
   * Is this account was marked as part of scammers activity
   * @type {boolean}
   * @memberof AccountAddress
   */
  is_scam: boolean;
  /**
   *
   * @type {string}
   * @memberof AccountAddress
   */
  icon?: string;
}
/**
 * An event is built on top of a trace which is a series of transactions caused by one inbound message. TonAPI looks for known patterns inside the trace and splits the trace into actions, where a single action represents a meaningful high-level operation like a Jetton Transfer or an NFT Purchase. Actions are expected to be shown to users. It is advised not to build any logic on top of actions because actions can be changed at any time.
 * @export
 * @interface AccountEvent
 */
export interface AccountEvent {
  /**
   *
   * @type {string}
   * @memberof AccountEvent
   */
  event_id: string;
  /**
   *
   * @type {AccountAddress}
   * @memberof AccountEvent
   */
  account: AccountAddress;
  /**
   *
   * @type {number}
   * @memberof AccountEvent
   */
  timestamp: number;
  /**
   *
   * @type {Array<Action>}
   * @memberof AccountEvent
   */
  actions: Array<Action>;
  /**
   * scam
   * @type {boolean}
   * @memberof AccountEvent
   */
  is_scam: boolean;
  /**
   *
   * @type {number}
   * @memberof AccountEvent
   */
  lt: number;
  /**
   * Event is not finished yet. Transactions still happening
   * @type {boolean}
   * @memberof AccountEvent
   */
  in_progress: boolean;
  /**
   * TODO
   * @type {number}
   * @memberof AccountEvent
   */
  extra: number;
}
/**
 *
 * @export
 * @interface AccountEvents
 */
export interface AccountEvents {
  /**
   *
   * @type {Array<AccountEvent>}
   * @memberof AccountEvents
   */
  events: Array<AccountEvent>;
  /**
   *
   * @type {number}
   * @memberof AccountEvents
   */
  next_from: number;
}
/**
 *
 * @export
 * @interface AccountInfoByStateInit
 */
export interface AccountInfoByStateInit {
  /**
   *
   * @type {string}
   * @memberof AccountInfoByStateInit
   */
  public_key: string;
  /**
   *
   * @type {string}
   * @memberof AccountInfoByStateInit
   */
  address: string;
}
/**
 *
 * @export
 * @interface AccountStaking
 */
export interface AccountStaking {
  /**
   *
   * @type {Array<AccountStakingInfo>}
   * @memberof AccountStaking
   */
  pools: Array<AccountStakingInfo>;
}
/**
 *
 * @export
 * @interface AccountStakingInfo
 */
export interface AccountStakingInfo {
  /**
   *
   * @type {string}
   * @memberof AccountStakingInfo
   */
  pool: string;
  /**
   *
   * @type {number}
   * @memberof AccountStakingInfo
   */
  amount: number;
  /**
   *
   * @type {number}
   * @memberof AccountStakingInfo
   */
  pending_deposit: number;
  /**
   *
   * @type {number}
   * @memberof AccountStakingInfo
   */
  pending_withdraw: number;
  /**
   *
   * @type {number}
   * @memberof AccountStakingInfo
   */
  ready_withdraw: number;
}
/**
 *
 * @export
 * @enum {string}
 */

export const AccountStatus = {
  Nonexist: 'nonexist',
  Uninit: 'uninit',
  Active: 'active',
  Frozen: 'frozen',
} as const;

export type AccountStatus = typeof AccountStatus[keyof typeof AccountStatus];

/**
 *
 * @export
 * @interface AccountStorageInfo
 */
export interface AccountStorageInfo {
  /**
   *
   * @type {number}
   * @memberof AccountStorageInfo
   */
  used_cells: number;
  /**
   *
   * @type {number}
   * @memberof AccountStorageInfo
   */
  used_bits: number;
  /**
   *
   * @type {number}
   * @memberof AccountStorageInfo
   */
  used_public_cells: number;
  /**
   *
   * @type {number}
   * @memberof AccountStorageInfo
   */
  last_paid: number;
  /**
   *
   * @type {number}
   * @memberof AccountStorageInfo
   */
  due_payment: number;
}
/**
 *
 * @export
 * @interface Accounts
 */
export interface Accounts {
  /**
   *
   * @type {Array<Account>}
   * @memberof Accounts
   */
  accounts: Array<Account>;
}
/**
 *
 * @export
 * @interface Action
 */
export interface Action {
  /**
   *
   * @type {string}
   * @memberof Action
   */
  type: ActionTypeEnum;
  /**
   *
   * @type {string}
   * @memberof Action
   */
  status: ActionStatusEnum;
  /**
   *
   * @type {TonTransferAction}
   * @memberof Action
   */
  TonTransfer?: TonTransferAction;
  /**
   *
   * @type {ContractDeployAction}
   * @memberof Action
   */
  ContractDeploy?: ContractDeployAction;
  /**
   *
   * @type {JettonTransferAction}
   * @memberof Action
   */
  JettonTransfer?: JettonTransferAction;
  /**
   *
   * @type {NftItemTransferAction}
   * @memberof Action
   */
  NftItemTransfer?: NftItemTransferAction;
  /**
   *
   * @type {SubscriptionAction}
   * @memberof Action
   */
  Subscribe?: SubscriptionAction;
  /**
   *
   * @type {UnSubscriptionAction}
   * @memberof Action
   */
  UnSubscribe?: UnSubscriptionAction;
  /**
   *
   * @type {AuctionBidAction}
   * @memberof Action
   */
  AuctionBid?: AuctionBidAction;
  /**
   *
   * @type {NftPurchaseAction}
   * @memberof Action
   */
  NftPurchase?: NftPurchaseAction;
  /**
   *
   * @type {DepositStakeAction}
   * @memberof Action
   */
  DepositStake?: DepositStakeAction;
  /**
   *
   * @type {RecoverStakeAction}
   * @memberof Action
   */
  RecoverStake?: RecoverStakeAction;
  /**
   *
   * @type {STONfiSwapAction}
   * @memberof Action
   */
  STONfiSwap?: STONfiSwapAction;
  /**
   *
   * @type {SmartContractAction}
   * @memberof Action
   */
  SmartContractExec?: SmartContractAction;
  /**
   *
   * @type {ActionSimplePreview}
   * @memberof Action
   */
  simple_preview: ActionSimplePreview;
}

export const ActionTypeEnum = {
  TonTransfer: 'TonTransfer',
  JettonTransfer: 'JettonTransfer',
  NftItemTransfer: 'NftItemTransfer',
  ContractDeploy: 'ContractDeploy',
  Subscribe: 'Subscribe',
  UnSubscribe: 'UnSubscribe',
  AuctionBid: 'AuctionBid',
  NftPurchase: 'NftPurchase',
  DepositStake: 'DepositStake',
  RecoverStake: 'RecoverStake',
  StoNfiSwap: 'STONfiSwap',
  SmartContractExec: 'SmartContractExec',
  Unknown: 'Unknown',
} as const;

export type ActionTypeEnum = typeof ActionTypeEnum[keyof typeof ActionTypeEnum];
export const ActionStatusEnum = {
  Ok: 'ok',
  Failed: 'failed',
  Pending: 'pending',
} as const;

export type ActionStatusEnum =
  typeof ActionStatusEnum[keyof typeof ActionStatusEnum];

/**
 *
 * @export
 * @interface ActionPhase
 */
export interface ActionPhase {
  /**
   *
   * @type {boolean}
   * @memberof ActionPhase
   */
  success: boolean;
  /**
   *
   * @type {number}
   * @memberof ActionPhase
   */
  total_actions: number;
  /**
   *
   * @type {number}
   * @memberof ActionPhase
   */
  skipped_actions: number;
  /**
   *
   * @type {number}
   * @memberof ActionPhase
   */
  fwd_fees: number;
  /**
   *
   * @type {number}
   * @memberof ActionPhase
   */
  total_fees: number;
}
/**
 * shortly describes what this action is about.
 * @export
 * @interface ActionSimplePreview
 */
export interface ActionSimplePreview {
  /**
   *
   * @type {string}
   * @memberof ActionSimplePreview
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof ActionSimplePreview
   */
  description: string;
  /**
   * a link to an image for this particular action.
   * @type {string}
   * @memberof ActionSimplePreview
   */
  action_image?: string;
  /**
   *
   * @type {string}
   * @memberof ActionSimplePreview
   */
  value?: string;
  /**
   * a link to an image that depicts this action\'s asset.
   * @type {string}
   * @memberof ActionSimplePreview
   */
  value_image?: string;
  /**
   *
   * @type {Array<AccountAddress>}
   * @memberof ActionSimplePreview
   */
  accounts: Array<AccountAddress>;
}
/**
 *
 * @export
 * @interface ApyHistory
 */
export interface ApyHistory {
  /**
   *
   * @type {number}
   * @memberof ApyHistory
   */
  apy: number;
  /**
   *
   * @type {number}
   * @memberof ApyHistory
   */
  time: number;
}
/**
 *
 * @export
 * @interface Auction
 */
export interface Auction {
  /**
   *
   * @type {string}
   * @memberof Auction
   */
  domain: string;
  /**
   *
   * @type {string}
   * @memberof Auction
   */
  owner: string;
  /**
   *
   * @type {number}
   * @memberof Auction
   */
  price: number;
  /**
   *
   * @type {number}
   * @memberof Auction
   */
  bids: number;
  /**
   *
   * @type {number}
   * @memberof Auction
   */
  date: number;
}
/**
 *
 * @export
 * @interface AuctionBidAction
 */
export interface AuctionBidAction {
  /**
   *
   * @type {string}
   * @memberof AuctionBidAction
   */
  auction_type: AuctionBidActionAuctionTypeEnum;
  /**
   *
   * @type {Price}
   * @memberof AuctionBidAction
   */
  amount: Price;
  /**
   *
   * @type {NftItem}
   * @memberof AuctionBidAction
   */
  nft?: NftItem;
  /**
   *
   * @type {AccountAddress}
   * @memberof AuctionBidAction
   */
  beneficiary: AccountAddress;
  /**
   *
   * @type {AccountAddress}
   * @memberof AuctionBidAction
   */
  bidder: AccountAddress;
}

export const AuctionBidActionAuctionTypeEnum = {
  DnsTon: 'DNS.ton',
  DnsTg: 'DNS.tg',
  NumberTg: 'NUMBER.tg',
  Getgems: 'getgems',
} as const;

export type AuctionBidActionAuctionTypeEnum =
  typeof AuctionBidActionAuctionTypeEnum[keyof typeof AuctionBidActionAuctionTypeEnum];

/**
 *
 * @export
 * @interface Auctions
 */
export interface Auctions {
  /**
   *
   * @type {Array<Auction>}
   * @memberof Auctions
   */
  data: Array<Auction>;
  /**
   *
   * @type {number}
   * @memberof Auctions
   */
  total: number;
}
/**
 *
 * @export
 * @interface Block
 */
export interface Block {
  /**
   *
   * @type {number}
   * @memberof Block
   */
  workchain_id: number;
  /**
   *
   * @type {string}
   * @memberof Block
   */
  shard: string;
  /**
   *
   * @type {number}
   * @memberof Block
   */
  seqno: number;
  /**
   *
   * @type {string}
   * @memberof Block
   */
  root_hash: string;
  /**
   *
   * @type {string}
   * @memberof Block
   */
  file_hash: string;
  /**
   *
   * @type {number}
   * @memberof Block
   */
  global_id: number;
  /**
   *
   * @type {number}
   * @memberof Block
   */
  version: number;
  /**
   *
   * @type {boolean}
   * @memberof Block
   */
  after_merge: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Block
   */
  before_split: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Block
   */
  after_split: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Block
   */
  want_split: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Block
   */
  want_merge: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Block
   */
  key_block: boolean;
  /**
   *
   * @type {number}
   * @memberof Block
   */
  gen_utime: number;
  /**
   *
   * @type {number}
   * @memberof Block
   */
  start_lt: number;
  /**
   *
   * @type {number}
   * @memberof Block
   */
  end_lt: number;
  /**
   *
   * @type {number}
   * @memberof Block
   */
  vert_seqno: number;
  /**
   *
   * @type {number}
   * @memberof Block
   */
  gen_catchain_seqno: number;
  /**
   *
   * @type {number}
   * @memberof Block
   */
  min_ref_mc_seqno: number;
  /**
   *
   * @type {number}
   * @memberof Block
   */
  prev_key_block_seqno: number;
  /**
   *
   * @type {number}
   * @memberof Block
   */
  gen_software_version?: number;
  /**
   *
   * @type {number}
   * @memberof Block
   */
  gen_software_capabilities?: number;
  /**
   *
   * @type {string}
   * @memberof Block
   */
  master_ref?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Block
   */
  prev_refs: Array<string>;
  /**
   *
   * @type {number}
   * @memberof Block
   */
  in_msg_descr_length: number;
  /**
   *
   * @type {number}
   * @memberof Block
   */
  out_msg_descr_length: number;
  /**
   *
   * @type {string}
   * @memberof Block
   */
  rand_seed: string;
  /**
   *
   * @type {string}
   * @memberof Block
   */
  created_by: string;
}
/**
 *
 * @export
 * @interface BlockRaw
 */
export interface BlockRaw {
  /**
   *
   * @type {number}
   * @memberof BlockRaw
   */
  workchain: number;
  /**
   *
   * @type {number}
   * @memberof BlockRaw
   */
  shard: number;
  /**
   *
   * @type {number}
   * @memberof BlockRaw
   */
  seqno: number;
  /**
   *
   * @type {string}
   * @memberof BlockRaw
   */
  root_hash: string;
  /**
   *
   * @type {string}
   * @memberof BlockRaw
   */
  file_hash: string;
}
/**
 *
 * @export
 * @enum {string}
 */

export const BouncePhaseType = {
  TrPhaseBounceNegfunds: 'TrPhaseBounceNegfunds',
  TrPhaseBounceNofunds: 'TrPhaseBounceNofunds',
  TrPhaseBounceOk: 'TrPhaseBounceOk',
} as const;

export type BouncePhaseType =
  typeof BouncePhaseType[keyof typeof BouncePhaseType];

/**
 *
 * @export
 * @interface ComputePhase
 */
export interface ComputePhase {
  /**
   *
   * @type {boolean}
   * @memberof ComputePhase
   */
  skipped: boolean;
  /**
   *
   * @type {ComputeSkipReason}
   * @memberof ComputePhase
   */
  skip_reason?: ComputeSkipReason;
  /**
   *
   * @type {boolean}
   * @memberof ComputePhase
   */
  success?: boolean;
  /**
   *
   * @type {number}
   * @memberof ComputePhase
   */
  gas_fees?: number;
  /**
   *
   * @type {number}
   * @memberof ComputePhase
   */
  gas_used?: number;
  /**
   *
   * @type {number}
   * @memberof ComputePhase
   */
  vm_steps?: number;
  /**
   *
   * @type {number}
   * @memberof ComputePhase
   */
  exit_code?: number;
}
/**
 *
 * @export
 * @enum {string}
 */

export const ComputeSkipReason = {
  NoState: 'cskip_no_state',
  BadState: 'cskip_bad_state',
  NoGas: 'cskip_no_gas',
} as const;

export type ComputeSkipReason =
  typeof ComputeSkipReason[keyof typeof ComputeSkipReason];

/**
 *
 * @export
 * @interface Config
 */
export interface Config {
  /**
   * config address
   * @type {string}
   * @memberof Config
   */
  '0': string;
  /**
   * elector address
   * @type {string}
   * @memberof Config
   */
  '1': string;
  /**
   * minter address
   * @type {string}
   * @memberof Config
   */
  '2': string;
  /**
   * dns root address
   * @type {string}
   * @memberof Config
   */
  '4': string;
  /**
   *
   * @type {ValidatorsSet}
   * @memberof Config
   */
  '32'?: ValidatorsSet;
  /**
   *
   * @type {ValidatorsSet}
   * @memberof Config
   */
  '33'?: ValidatorsSet;
  /**
   *
   * @type {ValidatorsSet}
   * @memberof Config
   */
  '34'?: ValidatorsSet;
  /**
   *
   * @type {ValidatorsSet}
   * @memberof Config
   */
  '35'?: ValidatorsSet;
  /**
   *
   * @type {ValidatorsSet}
   * @memberof Config
   */
  '36'?: ValidatorsSet;
  /**
   *
   * @type {ValidatorsSet}
   * @memberof Config
   */
  '37'?: ValidatorsSet;
  /**
   * config boc in base64 format
   * @type {string}
   * @memberof Config
   */
  raw: string;
}
/**
 *
 * @export
 * @interface ContractDeployAction
 */
export interface ContractDeployAction {
  /**
   *
   * @type {string}
   * @memberof ContractDeployAction
   */
  address: string;
  /**
   *
   * @type {Array<string>}
   * @memberof ContractDeployAction
   */
  interfaces: Array<string>;
}
/**
 *
 * @export
 * @interface CreditPhase
 */
export interface CreditPhase {
  /**
   *
   * @type {number}
   * @memberof CreditPhase
   */
  fees_collected: number;
  /**
   *
   * @type {number}
   * @memberof CreditPhase
   */
  credit: number;
}
/**
 *
 * @export
 * @interface DepositStakeAction
 */
export interface DepositStakeAction {
  /**
   *
   * @type {number}
   * @memberof DepositStakeAction
   */
  amount: number;
  /**
   *
   * @type {AccountAddress}
   * @memberof DepositStakeAction
   */
  staker: AccountAddress;
}
/**
 *
 * @export
 * @interface DnsExpiring
 */
export interface DnsExpiring {
  /**
   *
   * @type {Array<DnsExpiringItems>}
   * @memberof DnsExpiring
   */
  items: Array<DnsExpiringItems>;
}
/**
 *
 * @export
 * @interface DnsExpiringItems
 */
export interface DnsExpiringItems {
  /**
   *
   * @type {number}
   * @memberof DnsExpiringItems
   */
  expiring_at: number;
  /**
   *
   * @type {string}
   * @memberof DnsExpiringItems
   */
  name: string;
  /**
   *
   * @type {NftItem}
   * @memberof DnsExpiringItems
   */
  dns_item?: NftItem;
}
/**
 *
 * @export
 * @interface DnsRecord
 */
export interface DnsRecord {
  /**
   *
   * @type {WalletDNS}
   * @memberof DnsRecord
   */
  wallet?: WalletDNS;
  /**
   *
   * @type {string}
   * @memberof DnsRecord
   */
  next_resolver?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof DnsRecord
   */
  sites: Array<string>;
  /**
   * tonstorage bag id
   * @type {string}
   * @memberof DnsRecord
   */
  storage?: string;
}
/**
 *
 * @export
 * @interface DomainBid
 */
export interface DomainBid {
  /**
   *
   * @type {boolean}
   * @memberof DomainBid
   */
  success: boolean;
  /**
   *
   * @type {number}
   * @memberof DomainBid
   */
  value: number;
  /**
   *
   * @type {number}
   * @memberof DomainBid
   */
  txTime: number;
  /**
   *
   * @type {string}
   * @memberof DomainBid
   */
  txHash: string;
  /**
   *
   * @type {AccountAddress}
   * @memberof DomainBid
   */
  bidder: AccountAddress;
}
/**
 *
 * @export
 * @interface DomainBids
 */
export interface DomainBids {
  /**
   *
   * @type {Array<DomainBid>}
   * @memberof DomainBids
   */
  data: Array<DomainBid>;
}
/**
 *
 * @export
 * @interface DomainInfo
 */
export interface DomainInfo {
  /**
   *
   * @type {string}
   * @memberof DomainInfo
   */
  name: string;
  /**
   * date of expiring. optional. not all domain in ton has expiration date
   * @type {number}
   * @memberof DomainInfo
   */
  expiring_at?: number;
  /**
   *
   * @type {NftItem}
   * @memberof DomainInfo
   */
  item?: NftItem;
}
/**
 *
 * @export
 * @interface DomainNames
 */
export interface DomainNames {
  /**
   *
   * @type {Array<string>}
   * @memberof DomainNames
   */
  domains: Array<string>;
}
/**
 *
 * @export
 * @interface Event
 */
export interface Event {
  /**
   *
   * @type {string}
   * @memberof Event
   */
  event_id: string;
  /**
   *
   * @type {number}
   * @memberof Event
   */
  timestamp: number;
  /**
   *
   * @type {Array<Action>}
   * @memberof Event
   */
  actions: Array<Action>;
  /**
   *
   * @type {Array<ValueFlow>}
   * @memberof Event
   */
  value_flow: Array<ValueFlow>;
  /**
   * scam
   * @type {boolean}
   * @memberof Event
   */
  is_scam: boolean;
  /**
   *
   * @type {number}
   * @memberof Event
   */
  lt: number;
  /**
   * Event is not finished yet. Transactions still happening
   * @type {boolean}
   * @memberof Event
   */
  in_progress: boolean;
}
/**
 *
 * @export
 * @interface FoundAccounts
 */
export interface FoundAccounts {
  /**
   *
   * @type {Array<FoundAccountsAddresses>}
   * @memberof FoundAccounts
   */
  addresses: Array<FoundAccountsAddresses>;
}
/**
 *
 * @export
 * @interface FoundAccountsAddresses
 */
export interface FoundAccountsAddresses {
  /**
   *
   * @type {string}
   * @memberof FoundAccountsAddresses
   */
  address: string;
  /**
   *
   * @type {string}
   * @memberof FoundAccountsAddresses
   */
  name: string;
}
/**
 *
 * @export
 * @interface ImagePreview
 */
export interface ImagePreview {
  /**
   *
   * @type {string}
   * @memberof ImagePreview
   */
  resolution: string;
  /**
   *
   * @type {string}
   * @memberof ImagePreview
   */
  url: string;
}
/**
 *
 * @export
 * @interface InitStateRaw
 */
export interface InitStateRaw {
  /**
   *
   * @type {number}
   * @memberof InitStateRaw
   */
  workchain: number;
  /**
   *
   * @type {string}
   * @memberof InitStateRaw
   */
  root_hash: string;
  /**
   *
   * @type {string}
   * @memberof InitStateRaw
   */
  file_hash: string;
}
/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse200
   */
  public_key: string;
}
/**
 *
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
  /**
   *
   * @type {PoolImplementation}
   * @memberof InlineResponse2001
   */
  implementation: PoolImplementation;
  /**
   *
   * @type {PoolInfo}
   * @memberof InlineResponse2001
   */
  pool: PoolInfo;
}
/**
 *
 * @export
 * @interface InlineResponse20010
 */
export interface InlineResponse20010 {
  /**
   *
   * @type {number}
   * @memberof InlineResponse20010
   */
  mode: number;
  /**
   *
   * @type {number}
   * @memberof InlineResponse20010
   */
  version: number;
  /**
   *
   * @type {number}
   * @memberof InlineResponse20010
   */
  capabilities: number;
  /**
   *
   * @type {BlockRaw}
   * @memberof InlineResponse20010
   */
  last: BlockRaw;
  /**
   *
   * @type {number}
   * @memberof InlineResponse20010
   */
  last_utime: number;
  /**
   *
   * @type {number}
   * @memberof InlineResponse20010
   */
  now: number;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20010
   */
  state_root_hash: string;
  /**
   *
   * @type {InitStateRaw}
   * @memberof InlineResponse20010
   */
  init: InitStateRaw;
}
/**
 *
 * @export
 * @interface InlineResponse20011
 */
export interface InlineResponse20011 {
  /**
   *
   * @type {number}
   * @memberof InlineResponse20011
   */
  time: number;
}
/**
 *
 * @export
 * @interface InlineResponse20012
 */
export interface InlineResponse20012 {
  /**
   *
   * @type {BlockRaw}
   * @memberof InlineResponse20012
   */
  id: BlockRaw;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20012
   */
  data: string;
}
/**
 *
 * @export
 * @interface InlineResponse20013
 */
export interface InlineResponse20013 {
  /**
   *
   * @type {BlockRaw}
   * @memberof InlineResponse20013
   */
  id: BlockRaw;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20013
   */
  root_hash: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20013
   */
  file_hash: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20013
   */
  data: string;
}
/**
 *
 * @export
 * @interface InlineResponse20014
 */
export interface InlineResponse20014 {
  /**
   *
   * @type {BlockRaw}
   * @memberof InlineResponse20014
   */
  id: BlockRaw;
  /**
   *
   * @type {number}
   * @memberof InlineResponse20014
   */
  mode: number;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20014
   */
  header_proof: string;
}
/**
 *
 * @export
 * @interface InlineResponse20015
 */
export interface InlineResponse20015 {
  /**
   *
   * @type {number}
   * @memberof InlineResponse20015
   */
  code: number;
}
/**
 *
 * @export
 * @interface InlineResponse20016
 */
export interface InlineResponse20016 {
  /**
   *
   * @type {BlockRaw}
   * @memberof InlineResponse20016
   */
  id: BlockRaw;
  /**
   *
   * @type {BlockRaw}
   * @memberof InlineResponse20016
   */
  shardblk: BlockRaw;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20016
   */
  shard_proof: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20016
   */
  proof: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20016
   */
  state: string;
}
/**
 *
 * @export
 * @interface InlineResponse20017
 */
export interface InlineResponse20017 {
  /**
   *
   * @type {BlockRaw}
   * @memberof InlineResponse20017
   */
  id: BlockRaw;
  /**
   *
   * @type {BlockRaw}
   * @memberof InlineResponse20017
   */
  shardblk: BlockRaw;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20017
   */
  shard_proof: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20017
   */
  shard_descr: string;
}
/**
 *
 * @export
 * @interface InlineResponse20018
 */
export interface InlineResponse20018 {
  /**
   *
   * @type {BlockRaw}
   * @memberof InlineResponse20018
   */
  id: BlockRaw;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20018
   */
  proof: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20018
   */
  data: string;
}
/**
 *
 * @export
 * @interface InlineResponse20019
 */
export interface InlineResponse20019 {
  /**
   *
   * @type {Array<BlockRaw>}
   * @memberof InlineResponse20019
   */
  ids: Array<BlockRaw>;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20019
   */
  transactions: string;
}
/**
 *
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
  /**
   *
   * @type {Array<ApyHistory>}
   * @memberof InlineResponse2002
   */
  apy: Array<ApyHistory>;
}
/**
 *
 * @export
 * @interface InlineResponse20020
 */
export interface InlineResponse20020 {
  /**
   *
   * @type {BlockRaw}
   * @memberof InlineResponse20020
   */
  id: BlockRaw;
  /**
   *
   * @type {number}
   * @memberof InlineResponse20020
   */
  req_count: number;
  /**
   *
   * @type {boolean}
   * @memberof InlineResponse20020
   */
  incomplete: boolean;
  /**
   *
   * @type {Array<InlineResponse20020Ids>}
   * @memberof InlineResponse20020
   */
  ids: Array<InlineResponse20020Ids>;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20020
   */
  proof: string;
}
/**
 *
 * @export
 * @interface InlineResponse20020Ids
 */
export interface InlineResponse20020Ids {
  /**
   *
   * @type {number}
   * @memberof InlineResponse20020Ids
   */
  mode: number;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20020Ids
   */
  account?: string;
  /**
   *
   * @type {number}
   * @memberof InlineResponse20020Ids
   */
  lt?: number;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20020Ids
   */
  hash?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20021
 */
export interface InlineResponse20021 {
  /**
   *
   * @type {boolean}
   * @memberof InlineResponse20021
   */
  complete: boolean;
  /**
   *
   * @type {BlockRaw}
   * @memberof InlineResponse20021
   */
  from: BlockRaw;
  /**
   *
   * @type {BlockRaw}
   * @memberof InlineResponse20021
   */
  to: BlockRaw;
  /**
   *
   * @type {Array<InlineResponse20021Steps>}
   * @memberof InlineResponse20021
   */
  steps: Array<InlineResponse20021Steps>;
}
/**
 *
 * @export
 * @interface InlineResponse20021LiteServerBlockLinkBack
 */
export interface InlineResponse20021LiteServerBlockLinkBack {
  /**
   *
   * @type {boolean}
   * @memberof InlineResponse20021LiteServerBlockLinkBack
   */
  to_key_block: boolean;
  /**
   *
   * @type {BlockRaw}
   * @memberof InlineResponse20021LiteServerBlockLinkBack
   */
  from: BlockRaw;
  /**
   *
   * @type {BlockRaw}
   * @memberof InlineResponse20021LiteServerBlockLinkBack
   */
  to: BlockRaw;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20021LiteServerBlockLinkBack
   */
  dest_proof: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20021LiteServerBlockLinkBack
   */
  proof: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20021LiteServerBlockLinkBack
   */
  state_proof: string;
}
/**
 *
 * @export
 * @interface InlineResponse20021LiteServerBlockLinkForward
 */
export interface InlineResponse20021LiteServerBlockLinkForward {
  /**
   *
   * @type {boolean}
   * @memberof InlineResponse20021LiteServerBlockLinkForward
   */
  to_key_block: boolean;
  /**
   *
   * @type {BlockRaw}
   * @memberof InlineResponse20021LiteServerBlockLinkForward
   */
  from: BlockRaw;
  /**
   *
   * @type {BlockRaw}
   * @memberof InlineResponse20021LiteServerBlockLinkForward
   */
  to: BlockRaw;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20021LiteServerBlockLinkForward
   */
  dest_proof: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20021LiteServerBlockLinkForward
   */
  config_proof: string;
  /**
   *
   * @type {InlineResponse20021LiteServerBlockLinkForwardSignatures}
   * @memberof InlineResponse20021LiteServerBlockLinkForward
   */
  signatures: InlineResponse20021LiteServerBlockLinkForwardSignatures;
}
/**
 *
 * @export
 * @interface InlineResponse20021LiteServerBlockLinkForwardSignatures
 */
export interface InlineResponse20021LiteServerBlockLinkForwardSignatures {
  /**
   *
   * @type {number}
   * @memberof InlineResponse20021LiteServerBlockLinkForwardSignatures
   */
  validator_set_hash: number;
  /**
   *
   * @type {number}
   * @memberof InlineResponse20021LiteServerBlockLinkForwardSignatures
   */
  catchain_seqno: number;
  /**
   *
   * @type {Array<InlineResponse20021LiteServerBlockLinkForwardSignaturesSignatures>}
   * @memberof InlineResponse20021LiteServerBlockLinkForwardSignatures
   */
  signatures: Array<InlineResponse20021LiteServerBlockLinkForwardSignaturesSignatures>;
}
/**
 *
 * @export
 * @interface InlineResponse20021LiteServerBlockLinkForwardSignaturesSignatures
 */
export interface InlineResponse20021LiteServerBlockLinkForwardSignaturesSignatures {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20021LiteServerBlockLinkForwardSignaturesSignatures
   */
  node_id_short: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20021LiteServerBlockLinkForwardSignaturesSignatures
   */
  signature: string;
}
/**
 *
 * @export
 * @interface InlineResponse20021Steps
 */
export interface InlineResponse20021Steps {
  /**
   *
   * @type {InlineResponse20021LiteServerBlockLinkBack}
   * @memberof InlineResponse20021Steps
   */
  lite_server_block_link_back: InlineResponse20021LiteServerBlockLinkBack;
  /**
   *
   * @type {InlineResponse20021LiteServerBlockLinkForward}
   * @memberof InlineResponse20021Steps
   */
  lite_server_block_link_forward: InlineResponse20021LiteServerBlockLinkForward;
}
/**
 *
 * @export
 * @interface InlineResponse20022
 */
export interface InlineResponse20022 {
  /**
   *
   * @type {number}
   * @memberof InlineResponse20022
   */
  mode: number;
  /**
   *
   * @type {BlockRaw}
   * @memberof InlineResponse20022
   */
  id: BlockRaw;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20022
   */
  state_proof: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20022
   */
  config_proof: string;
}
/**
 *
 * @export
 * @interface InlineResponse20023
 */
export interface InlineResponse20023 {
  /**
   *
   * @type {BlockRaw}
   * @memberof InlineResponse20023
   */
  masterchain_id: BlockRaw;
  /**
   *
   * @type {Array<InlineResponse20023Links>}
   * @memberof InlineResponse20023
   */
  links: Array<InlineResponse20023Links>;
}
/**
 *
 * @export
 * @interface InlineResponse20023Links
 */
export interface InlineResponse20023Links {
  /**
   *
   * @type {BlockRaw}
   * @memberof InlineResponse20023Links
   */
  id: BlockRaw;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20023Links
   */
  proof: string;
}
/**
 *
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
  /**
   *
   * @type {Array<PoolInfo>}
   * @memberof InlineResponse2003
   */
  pools: Array<PoolInfo>;
  /**
   *
   * @type {{ [key: string]: PoolImplementation; }}
   * @memberof InlineResponse2003
   */
  implementations: { [key: string]: PoolImplementation };
}
/**
 *
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
  /**
   *
   * @type {Array<StorageProvider>}
   * @memberof InlineResponse2004
   */
  providers: Array<StorageProvider>;
}
/**
 *
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
  /**
   *
   * @type {{ [key: string]: object; }}
   * @memberof InlineResponse2005
   */
  rates: { [key: string]: object };
}
/**
 *
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2006
   */
  payload: string;
}
/**
 *
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2007
   */
  dump: string;
}
/**
 *
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2008
   */
  token: string;
}
/**
 *
 * @export
 * @interface InlineResponse2009
 */
export interface InlineResponse2009 {
  /**
   *
   * @type {BlockRaw}
   * @memberof InlineResponse2009
   */
  last: BlockRaw;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2009
   */
  state_root_hash: string;
  /**
   *
   * @type {InitStateRaw}
   * @memberof InlineResponse2009
   */
  init: InitStateRaw;
}
/**
 *
 * @export
 * @interface InlineResponse400
 */
export interface InlineResponse400 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse400
   */
  error: string;
}
/**
 *
 * @export
 * @interface JettonBalance
 */
export interface JettonBalance {
  /**
   *
   * @type {string}
   * @memberof JettonBalance
   */
  balance: string;
  /**
   *
   * @type {AccountAddress}
   * @memberof JettonBalance
   */
  wallet_address: AccountAddress;
  /**
   *
   * @type {JettonPreview}
   * @memberof JettonBalance
   */
  jetton: JettonPreview;
}
/**
 *
 * @export
 * @interface JettonInfo
 */
export interface JettonInfo {
  /**
   *
   * @type {boolean}
   * @memberof JettonInfo
   */
  mintable: boolean;
  /**
   *
   * @type {string}
   * @memberof JettonInfo
   */
  total_supply: string;
  /**
   *
   * @type {JettonMetadata}
   * @memberof JettonInfo
   */
  metadata: JettonMetadata;
  /**
   *
   * @type {JettonVerificationType}
   * @memberof JettonInfo
   */
  verification: JettonVerificationType;
}
/**
 *
 * @export
 * @interface JettonMetadata
 */
export interface JettonMetadata {
  /**
   *
   * @type {string}
   * @memberof JettonMetadata
   */
  address: string;
  /**
   *
   * @type {string}
   * @memberof JettonMetadata
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof JettonMetadata
   */
  symbol: string;
  /**
   *
   * @type {string}
   * @memberof JettonMetadata
   */
  decimals: string;
  /**
   *
   * @type {string}
   * @memberof JettonMetadata
   */
  image?: string;
  /**
   *
   * @type {string}
   * @memberof JettonMetadata
   */
  description?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof JettonMetadata
   */
  social?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof JettonMetadata
   */
  websites?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof JettonMetadata
   */
  catalogs?: Array<string>;
}
/**
 *
 * @export
 * @interface JettonPreview
 */
export interface JettonPreview {
  /**
   *
   * @type {string}
   * @memberof JettonPreview
   */
  address: string;
  /**
   *
   * @type {string}
   * @memberof JettonPreview
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof JettonPreview
   */
  symbol: string;
  /**
   *
   * @type {number}
   * @memberof JettonPreview
   */
  decimals: number;
  /**
   *
   * @type {string}
   * @memberof JettonPreview
   */
  image: string;
  /**
   *
   * @type {JettonVerificationType}
   * @memberof JettonPreview
   */
  verification: JettonVerificationType;
}
/**
 *
 * @export
 * @interface JettonQuantity
 */
export interface JettonQuantity {
  /**
   *
   * @type {string}
   * @memberof JettonQuantity
   */
  quantity: string;
  /**
   *
   * @type {AccountAddress}
   * @memberof JettonQuantity
   */
  wallet_address: AccountAddress;
  /**
   *
   * @type {JettonPreview}
   * @memberof JettonQuantity
   */
  jetton: JettonPreview;
}
/**
 *
 * @export
 * @interface JettonTransferAction
 */
export interface JettonTransferAction {
  /**
   *
   * @type {AccountAddress}
   * @memberof JettonTransferAction
   */
  sender?: AccountAddress;
  /**
   *
   * @type {AccountAddress}
   * @memberof JettonTransferAction
   */
  recipient?: AccountAddress;
  /**
   *
   * @type {string}
   * @memberof JettonTransferAction
   */
  senders_wallet: string;
  /**
   *
   * @type {string}
   * @memberof JettonTransferAction
   */
  recipients_wallet: string;
  /**
   * amount in quanta of tokens
   * @type {string}
   * @memberof JettonTransferAction
   */
  amount: string;
  /**
   *
   * @type {string}
   * @memberof JettonTransferAction
   */
  comment?: string;
  /**
   *
   * @type {Refund}
   * @memberof JettonTransferAction
   */
  refund?: Refund;
  /**
   *
   * @type {JettonPreview}
   * @memberof JettonTransferAction
   */
  jetton: JettonPreview;
}
/**
 *
 * @export
 * @enum {string}
 */

export const JettonVerificationType = {
  Whitelist: 'whitelist',
  Blacklist: 'blacklist',
  None: 'none',
} as const;

export type JettonVerificationType =
  typeof JettonVerificationType[keyof typeof JettonVerificationType];

/**
 *
 * @export
 * @interface Jettons
 */
export interface Jettons {
  /**
   *
   * @type {Array<JettonInfo>}
   * @memberof Jettons
   */
  jettons: Array<JettonInfo>;
}
/**
 *
 * @export
 * @interface JettonsBalances
 */
export interface JettonsBalances {
  /**
   *
   * @type {Array<JettonBalance>}
   * @memberof JettonsBalances
   */
  balances: Array<JettonBalance>;
}
/**
 *
 * @export
 * @interface Message
 */
export interface Message {
  /**
   *
   * @type {number}
   * @memberof Message
   */
  created_lt: number;
  /**
   *
   * @type {boolean}
   * @memberof Message
   */
  ihr_disabled: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Message
   */
  bounce: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Message
   */
  bounced: boolean;
  /**
   *
   * @type {number}
   * @memberof Message
   */
  value: number;
  /**
   *
   * @type {number}
   * @memberof Message
   */
  fwd_fee: number;
  /**
   *
   * @type {number}
   * @memberof Message
   */
  ihr_fee: number;
  /**
   *
   * @type {AccountAddress}
   * @memberof Message
   */
  destination?: AccountAddress;
  /**
   *
   * @type {AccountAddress}
   * @memberof Message
   */
  source?: AccountAddress;
  /**
   *
   * @type {number}
   * @memberof Message
   */
  import_fee: number;
  /**
   *
   * @type {number}
   * @memberof Message
   */
  created_at: number;
  /**
   *
   * @type {string}
   * @memberof Message
   */
  op_code?: string;
  /**
   *
   * @type {StateInit}
   * @memberof Message
   */
  init?: StateInit;
  /**
   * hex-encoded BoC with raw message body
   * @type {string}
   * @memberof Message
   */
  raw_body?: string;
  /**
   *
   * @type {string}
   * @memberof Message
   */
  decoded_op_name?: string;
  /**
   *
   * @type {any}
   * @memberof Message
   */
  decoded_body: any;
}
/**
 *
 * @export
 * @interface MessageConsequences
 */
export interface MessageConsequences {
  /**
   *
   * @type {Trace}
   * @memberof MessageConsequences
   */
  trace: Trace;
  /**
   *
   * @type {Risk}
   * @memberof MessageConsequences
   */
  risk: Risk;
  /**
   *
   * @type {AccountEvent}
   * @memberof MessageConsequences
   */
  event: AccountEvent;
}
/**
 *
 * @export
 * @interface MethodExecutionResult
 */
export interface MethodExecutionResult {
  /**
   *
   * @type {boolean}
   * @memberof MethodExecutionResult
   */
  success: boolean;
  /**
   * tvm exit code
   * @type {number}
   * @memberof MethodExecutionResult
   */
  exit_code: number;
  /**
   *
   * @type {Array<TvmStackRecord>}
   * @memberof MethodExecutionResult
   */
  stack: Array<TvmStackRecord>;
  /**
   *
   * @type {any}
   * @memberof MethodExecutionResult
   */
  decoded?: any;
}
/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  error: string;
}
/**
 *
 * @export
 * @interface NftCollection
 */
export interface NftCollection {
  /**
   *
   * @type {string}
   * @memberof NftCollection
   */
  address: string;
  /**
   *
   * @type {number}
   * @memberof NftCollection
   */
  next_item_index: number;
  /**
   *
   * @type {AccountAddress}
   * @memberof NftCollection
   */
  owner?: AccountAddress;
  /**
   *
   * @type {string}
   * @memberof NftCollection
   */
  raw_collection_content: string;
  /**
   *
   * @type {{ [key: string]: object; }}
   * @memberof NftCollection
   */
  metadata?: { [key: string]: object };
}
/**
 *
 * @export
 * @interface NftCollections
 */
export interface NftCollections {
  /**
   *
   * @type {Array<NftCollection>}
   * @memberof NftCollections
   */
  nft_collections: Array<NftCollection>;
}
/**
 *
 * @export
 * @interface NftItem
 */
export interface NftItem {
  /**
   *
   * @type {string}
   * @memberof NftItem
   */
  address: string;
  /**
   *
   * @type {number}
   * @memberof NftItem
   */
  index: number;
  /**
   *
   * @type {AccountAddress}
   * @memberof NftItem
   */
  owner?: AccountAddress;
  /**
   *
   * @type {NftItemCollection}
   * @memberof NftItem
   */
  collection?: NftItemCollection;
  /**
   *
   * @type {boolean}
   * @memberof NftItem
   */
  verified: boolean;
  /**
   *
   * @type {{ [key: string]: object; }}
   * @memberof NftItem
   */
  metadata: { [key: string]: object };
  /**
   *
   * @type {Sale}
   * @memberof NftItem
   */
  sale?: Sale;
  /**
   *
   * @type {Array<ImagePreview>}
   * @memberof NftItem
   */
  previews?: Array<ImagePreview>;
  /**
   *
   * @type {string}
   * @memberof NftItem
   */
  dns?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof NftItem
   */
  approved_by: Array<NftItemApprovedByEnum>;
}

export const NftItemApprovedByEnum = {
  Getgems: 'getgems',
  Tonkeeper: 'tonkeeper',
} as const;

export type NftItemApprovedByEnum =
  typeof NftItemApprovedByEnum[keyof typeof NftItemApprovedByEnum];

/**
 *
 * @export
 * @interface NftItemCollection
 */
export interface NftItemCollection {
  /**
   *
   * @type {string}
   * @memberof NftItemCollection
   */
  address: string;
  /**
   *
   * @type {string}
   * @memberof NftItemCollection
   */
  name: string;
}
/**
 *
 * @export
 * @interface NftItemTransferAction
 */
export interface NftItemTransferAction {
  /**
   *
   * @type {AccountAddress}
   * @memberof NftItemTransferAction
   */
  sender?: AccountAddress;
  /**
   *
   * @type {AccountAddress}
   * @memberof NftItemTransferAction
   */
  recipient?: AccountAddress;
  /**
   *
   * @type {string}
   * @memberof NftItemTransferAction
   */
  nft: string;
  /**
   *
   * @type {string}
   * @memberof NftItemTransferAction
   */
  comment?: string;
  /**
   * raw hex encoded payload
   * @type {string}
   * @memberof NftItemTransferAction
   */
  payload?: string;
  /**
   *
   * @type {Refund}
   * @memberof NftItemTransferAction
   */
  refund?: Refund;
}
/**
 *
 * @export
 * @interface NftItems
 */
export interface NftItems {
  /**
   *
   * @type {Array<NftItem>}
   * @memberof NftItems
   */
  nft_items: Array<NftItem>;
}
/**
 *
 * @export
 * @interface NftPurchaseAction
 */
export interface NftPurchaseAction {
  /**
   *
   * @type {string}
   * @memberof NftPurchaseAction
   */
  auction_type: NftPurchaseActionAuctionTypeEnum;
  /**
   *
   * @type {Price}
   * @memberof NftPurchaseAction
   */
  amount: Price;
  /**
   *
   * @type {NftItem}
   * @memberof NftPurchaseAction
   */
  nft: NftItem;
  /**
   *
   * @type {AccountAddress}
   * @memberof NftPurchaseAction
   */
  seller: AccountAddress;
  /**
   *
   * @type {AccountAddress}
   * @memberof NftPurchaseAction
   */
  buyer: AccountAddress;
}

export const NftPurchaseActionAuctionTypeEnum = {
  DnsTg: 'DNS.tg',
  Getgems: 'getgems',
  Basic: 'basic',
} as const;

export type NftPurchaseActionAuctionTypeEnum =
  typeof NftPurchaseActionAuctionTypeEnum[keyof typeof NftPurchaseActionAuctionTypeEnum];

/**
 *
 * @export
 * @interface PoolImplementation
 */
export interface PoolImplementation {
  /**
   *
   * @type {string}
   * @memberof PoolImplementation
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof PoolImplementation
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof PoolImplementation
   */
  url: string;
}
/**
 *
 * @export
 * @interface PoolInfo
 */
export interface PoolInfo {
  /**
   *
   * @type {string}
   * @memberof PoolInfo
   */
  address: string;
  /**
   *
   * @type {string}
   * @memberof PoolInfo
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof PoolInfo
   */
  total_amount: number;
  /**
   *
   * @type {string}
   * @memberof PoolInfo
   */
  implementation: PoolInfoImplementationEnum;
  /**
   * APY in percent
   * @type {number}
   * @memberof PoolInfo
   */
  apy: number;
  /**
   *
   * @type {number}
   * @memberof PoolInfo
   */
  min_stake: number;
  /**
   * current nomination cycle beginning timestamp
   * @type {number}
   * @memberof PoolInfo
   */
  cycle_start: number;
  /**
   * current nomination cycle ending timestamp
   * @type {number}
   * @memberof PoolInfo
   */
  cycle_end: number;
  /**
   * this pool has verified source code or managed by trusted company
   * @type {boolean}
   * @memberof PoolInfo
   */
  verified: boolean;
  /**
   * current number of nominators
   * @type {number}
   * @memberof PoolInfo
   */
  current_nominators: number;
  /**
   * maximum number of nominators
   * @type {number}
   * @memberof PoolInfo
   */
  max_nominators: number;
  /**
   * for liquid staking master account of jetton
   * @type {string}
   * @memberof PoolInfo
   */
  liquid_jetton_master?: string;
}

export const PoolInfoImplementationEnum = {
  Whales: 'whales',
  Tf: 'tf',
  LiquidTf: 'liquidTF',
} as const;

export type PoolInfoImplementationEnum =
  typeof PoolInfoImplementationEnum[keyof typeof PoolInfoImplementationEnum];

/**
 *
 * @export
 * @interface Price
 */
export interface Price {
  /**
   *
   * @type {string}
   * @memberof Price
   */
  value: string;
  /**
   *
   * @type {string}
   * @memberof Price
   */
  token_name: string;
}
/**
 *
 * @export
 * @interface RawAccount
 */
export interface RawAccount {
  /**
   *
   * @type {string}
   * @memberof RawAccount
   */
  address: string;
  /**
   *
   * @type {number}
   * @memberof RawAccount
   */
  balance: number;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof RawAccount
   */
  extra_balance?: { [key: string]: string };
  /**
   *
   * @type {string}
   * @memberof RawAccount
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof RawAccount
   */
  data?: string;
  /**
   *
   * @type {number}
   * @memberof RawAccount
   */
  last_transaction_lt: number;
  /**
   *
   * @type {string}
   * @memberof RawAccount
   */
  status: string;
  /**
   *
   * @type {AccountStorageInfo}
   * @memberof RawAccount
   */
  storage: AccountStorageInfo;
}
/**
 *
 * @export
 * @interface RecoverStakeAction
 */
export interface RecoverStakeAction {
  /**
   *
   * @type {number}
   * @memberof RecoverStakeAction
   */
  amount: number;
  /**
   *
   * @type {AccountAddress}
   * @memberof RecoverStakeAction
   */
  staker: AccountAddress;
}
/**
 *
 * @export
 * @interface Refund
 */
export interface Refund {
  /**
   *
   * @type {string}
   * @memberof Refund
   */
  type: RefundTypeEnum;
  /**
   *
   * @type {string}
   * @memberof Refund
   */
  origin: string;
}

export const RefundTypeEnum = {
  DnsTon: 'DNS.ton',
  DnsTg: 'DNS.tg',
  GetGems: 'GetGems',
} as const;

export type RefundTypeEnum = typeof RefundTypeEnum[keyof typeof RefundTypeEnum];

/**
 * Risk specifies assets that could be lost if a message would be sent to a malicious smart contract. It makes sense to understand the risk BEFORE sending a message to the blockchain.
 * @export
 * @interface Risk
 */
export interface Risk {
  /**
   * transfer all the remaining balance of the wallet.
   * @type {boolean}
   * @memberof Risk
   */
  transfer_all_remaining_balance: boolean;
  /**
   *
   * @type {number}
   * @memberof Risk
   */
  ton: number;
  /**
   *
   * @type {Array<JettonQuantity>}
   * @memberof Risk
   */
  jettons: Array<JettonQuantity>;
  /**
   *
   * @type {Array<NftItem>}
   * @memberof Risk
   */
  nfts: Array<NftItem>;
}
/**
 *
 * @export
 * @interface STONfiSwapAction
 */
export interface STONfiSwapAction {
  /**
   *
   * @type {string}
   * @memberof STONfiSwapAction
   */
  amount_in: string;
  /**
   *
   * @type {string}
   * @memberof STONfiSwapAction
   */
  amount_out: string;
  /**
   *
   * @type {AccountAddress}
   * @memberof STONfiSwapAction
   */
  user_wallet: AccountAddress;
  /**
   *
   * @type {AccountAddress}
   * @memberof STONfiSwapAction
   */
  stonfi_router: AccountAddress;
  /**
   *
   * @type {string}
   * @memberof STONfiSwapAction
   */
  jetton_wallet_in: string;
  /**
   *
   * @type {JettonPreview}
   * @memberof STONfiSwapAction
   */
  jetton_master_in: JettonPreview;
  /**
   *
   * @type {string}
   * @memberof STONfiSwapAction
   */
  jetton_wallet_out: string;
  /**
   *
   * @type {JettonPreview}
   * @memberof STONfiSwapAction
   */
  jetton_master_out: JettonPreview;
}
/**
 *
 * @export
 * @interface Sale
 */
export interface Sale {
  /**
   *
   * @type {string}
   * @memberof Sale
   */
  address: string;
  /**
   *
   * @type {AccountAddress}
   * @memberof Sale
   */
  market: AccountAddress;
  /**
   *
   * @type {AccountAddress}
   * @memberof Sale
   */
  owner?: AccountAddress;
  /**
   *
   * @type {Price}
   * @memberof Sale
   */
  price: Price;
}
/**
 *
 * @export
 * @interface Seqno
 */
export interface Seqno {
  /**
   *
   * @type {number}
   * @memberof Seqno
   */
  seqno: number;
}
/**
 *
 * @export
 * @interface SmartContractAction
 */
export interface SmartContractAction {
  /**
   *
   * @type {AccountAddress}
   * @memberof SmartContractAction
   */
  executor: AccountAddress;
  /**
   *
   * @type {AccountAddress}
   * @memberof SmartContractAction
   */
  contract: AccountAddress;
  /**
   * amount in nanotons
   * @type {number}
   * @memberof SmartContractAction
   */
  ton_attached: number;
  /**
   *
   * @type {string}
   * @memberof SmartContractAction
   */
  operation: string;
  /**
   *
   * @type {string}
   * @memberof SmartContractAction
   */
  payload?: string;
  /**
   *
   * @type {Refund}
   * @memberof SmartContractAction
   */
  refund?: Refund;
}
/**
 *
 * @export
 * @interface StateInit
 */
export interface StateInit {
  /**
   *
   * @type {string}
   * @memberof StateInit
   */
  boc: string;
}
/**
 *
 * @export
 * @interface StoragePhase
 */
export interface StoragePhase {
  /**
   *
   * @type {number}
   * @memberof StoragePhase
   */
  fees_collected: number;
  /**
   *
   * @type {number}
   * @memberof StoragePhase
   */
  fees_due?: number;
  /**
   *
   * @type {AccStatusChange}
   * @memberof StoragePhase
   */
  status_change: AccStatusChange;
}
/**
 *
 * @export
 * @interface StorageProvider
 */
export interface StorageProvider {
  /**
   *
   * @type {string}
   * @memberof StorageProvider
   */
  address: string;
  /**
   *
   * @type {boolean}
   * @memberof StorageProvider
   */
  accept_new_contracts: boolean;
  /**
   *
   * @type {number}
   * @memberof StorageProvider
   */
  rate_per_mb_day: number;
  /**
   *
   * @type {number}
   * @memberof StorageProvider
   */
  max_span: number;
  /**
   *
   * @type {number}
   * @memberof StorageProvider
   */
  minimal_file_size: number;
  /**
   *
   * @type {number}
   * @memberof StorageProvider
   */
  maximal_file_size: number;
}
/**
 *
 * @export
 * @interface Subscription
 */
export interface Subscription {
  /**
   *
   * @type {string}
   * @memberof Subscription
   */
  address: string;
  /**
   *
   * @type {string}
   * @memberof Subscription
   */
  wallet_address: string;
  /**
   *
   * @type {string}
   * @memberof Subscription
   */
  beneficiary_address: string;
  /**
   *
   * @type {number}
   * @memberof Subscription
   */
  amount: number;
  /**
   *
   * @type {number}
   * @memberof Subscription
   */
  period: number;
  /**
   *
   * @type {number}
   * @memberof Subscription
   */
  start_time: number;
  /**
   *
   * @type {number}
   * @memberof Subscription
   */
  timeout: number;
  /**
   *
   * @type {number}
   * @memberof Subscription
   */
  last_payment_time: number;
  /**
   *
   * @type {number}
   * @memberof Subscription
   */
  last_request_time: number;
  /**
   *
   * @type {number}
   * @memberof Subscription
   */
  subscription_id: number;
  /**
   *
   * @type {number}
   * @memberof Subscription
   */
  failed_attempts: number;
}
/**
 *
 * @export
 * @interface SubscriptionAction
 */
export interface SubscriptionAction {
  /**
   *
   * @type {AccountAddress}
   * @memberof SubscriptionAction
   */
  subscriber: AccountAddress;
  /**
   *
   * @type {string}
   * @memberof SubscriptionAction
   */
  subscription: string;
  /**
   *
   * @type {AccountAddress}
   * @memberof SubscriptionAction
   */
  beneficiary: AccountAddress;
  /**
   *
   * @type {number}
   * @memberof SubscriptionAction
   */
  amount: number;
  /**
   *
   * @type {boolean}
   * @memberof SubscriptionAction
   */
  initial: boolean;
}
/**
 *
 * @export
 * @interface Subscriptions
 */
export interface Subscriptions {
  /**
   *
   * @type {Array<Subscription>}
   * @memberof Subscriptions
   */
  subscriptions: Array<Subscription>;
}
/**
 *
 * @export
 * @interface TonTransferAction
 */
export interface TonTransferAction {
  /**
   *
   * @type {AccountAddress}
   * @memberof TonTransferAction
   */
  sender: AccountAddress;
  /**
   *
   * @type {AccountAddress}
   * @memberof TonTransferAction
   */
  recipient: AccountAddress;
  /**
   * amount in nanotons
   * @type {number}
   * @memberof TonTransferAction
   */
  amount: number;
  /**
   *
   * @type {string}
   * @memberof TonTransferAction
   */
  comment?: string;
  /**
   *
   * @type {Refund}
   * @memberof TonTransferAction
   */
  refund?: Refund;
}
/**
 *
 * @export
 * @interface Trace
 */
export interface Trace {
  /**
   *
   * @type {Transaction}
   * @memberof Trace
   */
  transaction: Transaction;
  /**
   *
   * @type {Array<string>}
   * @memberof Trace
   */
  interfaces: Array<string>;
  /**
   *
   * @type {Array<Trace>}
   * @memberof Trace
   */
  children?: Array<Trace>;
}
/**
 *
 * @export
 * @interface TraceId
 */
export interface TraceId {
  /**
   *
   * @type {string}
   * @memberof TraceId
   */
  id: string;
  /**
   *
   * @type {number}
   * @memberof TraceId
   */
  utime: number;
}
/**
 *
 * @export
 * @interface TraceIds
 */
export interface TraceIds {
  /**
   *
   * @type {Array<TraceId>}
   * @memberof TraceIds
   */
  traces: Array<TraceId>;
}
/**
 *
 * @export
 * @interface Transaction
 */
export interface Transaction {
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  hash: string;
  /**
   *
   * @type {number}
   * @memberof Transaction
   */
  lt: number;
  /**
   *
   * @type {AccountAddress}
   * @memberof Transaction
   */
  account: AccountAddress;
  /**
   *
   * @type {boolean}
   * @memberof Transaction
   */
  success: boolean;
  /**
   *
   * @type {number}
   * @memberof Transaction
   */
  utime: number;
  /**
   *
   * @type {AccountStatus}
   * @memberof Transaction
   */
  orig_status: AccountStatus;
  /**
   *
   * @type {AccountStatus}
   * @memberof Transaction
   */
  end_status: AccountStatus;
  /**
   *
   * @type {number}
   * @memberof Transaction
   */
  total_fees: number;
  /**
   *
   * @type {TransactionType}
   * @memberof Transaction
   */
  transaction_type: TransactionType;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  state_update_old: string;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  state_update_new: string;
  /**
   *
   * @type {Message}
   * @memberof Transaction
   */
  in_msg?: Message;
  /**
   *
   * @type {Array<Message>}
   * @memberof Transaction
   */
  out_msgs: Array<Message>;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  block: string;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  prev_trans_hash?: string;
  /**
   *
   * @type {number}
   * @memberof Transaction
   */
  prev_trans_lt?: number;
  /**
   *
   * @type {ComputePhase}
   * @memberof Transaction
   */
  compute_phase?: ComputePhase;
  /**
   *
   * @type {StoragePhase}
   * @memberof Transaction
   */
  storage_phase?: StoragePhase;
  /**
   *
   * @type {CreditPhase}
   * @memberof Transaction
   */
  credit_phase?: CreditPhase;
  /**
   *
   * @type {ActionPhase}
   * @memberof Transaction
   */
  action_phase?: ActionPhase;
  /**
   *
   * @type {BouncePhaseType}
   * @memberof Transaction
   */
  bounce_phase?: BouncePhaseType;
  /**
   *
   * @type {boolean}
   * @memberof Transaction
   */
  aborted: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Transaction
   */
  destroyed: boolean;
}
/**
 *
 * @export
 * @enum {string}
 */

export const TransactionType = {
  TransOrd: 'TransOrd',
  TransTickTock: 'TransTickTock',
  TransSplitPrepare: 'TransSplitPrepare',
  TransSplitInstall: 'TransSplitInstall',
  TransMergePrepare: 'TransMergePrepare',
  TransMergeInstall: 'TransMergeInstall',
  TransStorage: 'TransStorage',
} as const;

export type TransactionType =
  typeof TransactionType[keyof typeof TransactionType];

/**
 *
 * @export
 * @interface Transactions
 */
export interface Transactions {
  /**
   *
   * @type {Array<Transaction>}
   * @memberof Transactions
   */
  transactions: Array<Transaction>;
}
/**
 *
 * @export
 * @interface TvmStackRecord
 */
export interface TvmStackRecord {
  /**
   *
   * @type {string}
   * @memberof TvmStackRecord
   */
  type: TvmStackRecordTypeEnum;
  /**
   *
   * @type {string}
   * @memberof TvmStackRecord
   */
  cell?: string;
  /**
   *
   * @type {string}
   * @memberof TvmStackRecord
   */
  slice?: string;
  /**
   *
   * @type {string}
   * @memberof TvmStackRecord
   */
  num?: string;
  /**
   *
   * @type {Array<TvmStackRecord>}
   * @memberof TvmStackRecord
   */
  tuple?: Array<TvmStackRecord>;
}

export const TvmStackRecordTypeEnum = {
  Cell: 'cell',
  Num: 'num',
  Nan: 'nan',
  Null: 'null',
  Tuple: 'tuple',
} as const;

export type TvmStackRecordTypeEnum =
  typeof TvmStackRecordTypeEnum[keyof typeof TvmStackRecordTypeEnum];

/**
 *
 * @export
 * @interface UnSubscriptionAction
 */
export interface UnSubscriptionAction {
  /**
   *
   * @type {AccountAddress}
   * @memberof UnSubscriptionAction
   */
  subscriber: AccountAddress;
  /**
   *
   * @type {string}
   * @memberof UnSubscriptionAction
   */
  subscription: string;
  /**
   *
   * @type {AccountAddress}
   * @memberof UnSubscriptionAction
   */
  beneficiary: AccountAddress;
}
/**
 *
 * @export
 * @interface Validator
 */
export interface Validator {
  /**
   *
   * @type {string}
   * @memberof Validator
   */
  address: string;
}
/**
 *
 * @export
 * @interface Validators
 */
export interface Validators {
  /**
   *
   * @type {Array<Validator>}
   * @memberof Validators
   */
  validators: Array<Validator>;
}
/**
 *
 * @export
 * @interface ValidatorsSet
 */
export interface ValidatorsSet {
  /**
   *
   * @type {number}
   * @memberof ValidatorsSet
   */
  utime_since: number;
  /**
   *
   * @type {number}
   * @memberof ValidatorsSet
   */
  utime_until: number;
  /**
   *
   * @type {number}
   * @memberof ValidatorsSet
   */
  total: number;
  /**
   *
   * @type {number}
   * @memberof ValidatorsSet
   */
  main: number;
  /**
   *
   * @type {number}
   * @memberof ValidatorsSet
   */
  total_weight?: number;
  /**
   *
   * @type {Array<ValidatorsSetList>}
   * @memberof ValidatorsSet
   */
  list: Array<ValidatorsSetList>;
}
/**
 *
 * @export
 * @interface ValidatorsSetList
 */
export interface ValidatorsSetList {
  /**
   *
   * @type {string}
   * @memberof ValidatorsSetList
   */
  public_key: string;
}
/**
 *
 * @export
 * @interface ValueFlow
 */
export interface ValueFlow {
  /**
   *
   * @type {AccountAddress}
   * @memberof ValueFlow
   */
  account: AccountAddress;
  /**
   *
   * @type {number}
   * @memberof ValueFlow
   */
  ton: number;
  /**
   *
   * @type {number}
   * @memberof ValueFlow
   */
  fees: number;
  /**
   *
   * @type {Array<ValueFlowJettons>}
   * @memberof ValueFlow
   */
  jettons?: Array<ValueFlowJettons>;
}
/**
 *
 * @export
 * @interface ValueFlowJettons
 */
export interface ValueFlowJettons {
  /**
   *
   * @type {AccountAddress}
   * @memberof ValueFlowJettons
   */
  account: AccountAddress;
  /**
   *
   * @type {number}
   * @memberof ValueFlowJettons
   */
  quantity: number;
}
/**
 *
 * @export
 * @interface WalletDNS
 */
export interface WalletDNS {
  /**
   *
   * @type {string}
   * @memberof WalletDNS
   */
  address: string;
  /**
   *
   * @type {boolean}
   * @memberof WalletDNS
   */
  is_wallet: boolean;
  /**
   *
   * @type {boolean}
   * @memberof WalletDNS
   */
  has_method_pubkey: boolean;
  /**
   *
   * @type {boolean}
   * @memberof WalletDNS
   */
  has_method_seqno: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof WalletDNS
   */
  names: Array<string>;
}

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Get domains for wallet account
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dnsBackResolve: async (
      accountId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('dnsBackResolve', 'accountId', accountId);
      const localVarPath = `/v2/accounts/{account_id}/dns/backresolve`.replace(
        `{${'account_id'}}`,
        encodeURIComponent(String(accountId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get human-friendly information about an account without low-level details.
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccount: async (
      accountId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('getAccount', 'accountId', accountId);
      const localVarPath = `/v2/accounts/{account_id}`.replace(
        `{${'account_id'}}`,
        encodeURIComponent(String(accountId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get human-friendly information about several accounts without low-level details.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] a list of account ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccounts: async (
      uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v2/accounts/_bulk`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        uNKNOWNBASETYPE,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get expiring .ton dns
     * @param {string} accountId account ID
     * @param {number} [period] number of days before expiration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDnsExpiring: async (
      accountId: string,
      period?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('getDnsExpiring', 'accountId', accountId);
      const localVarPath = `/v2/accounts/{account_id}/dns/expiring`.replace(
        `{${'account_id'}}`,
        encodeURIComponent(String(accountId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (period !== undefined) {
        localVarQueryParameter['period'] = period;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get events for an account. Each event is built on top of a trace which is a series of transactions caused by one inbound message. TonAPI looks for known patterns inside the trace and splits the trace into actions, where a single action represents a meaningful high-level operation like a Jetton Transfer or an NFT Purchase. Actions are expected to be shown to users. It is advised not to build any logic on top of actions because actions can be changed at any time.
     * @param {string} accountId account ID
     * @param {number} limit
     * @param {string} [acceptLanguage]
     * @param {boolean} [subjectOnly] filter actions where requested account is not real subject (for example sender or reciver jettons)
     * @param {number} [beforeLt] omit this parameter to get last events
     * @param {number} [startDate]
     * @param {number} [endDate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventsByAccount: async (
      accountId: string,
      limit: number,
      acceptLanguage?: string,
      subjectOnly?: boolean,
      beforeLt?: number,
      startDate?: number,
      endDate?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('getEventsByAccount', 'accountId', accountId);
      // verify required parameter 'limit' is not null or undefined
      assertParamExists('getEventsByAccount', 'limit', limit);
      const localVarPath = `/v2/accounts/{account_id}/events`.replace(
        `{${'account_id'}}`,
        encodeURIComponent(String(accountId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (subjectOnly !== undefined) {
        localVarQueryParameter['subject_only'] = subjectOnly;
      }

      if (beforeLt !== undefined) {
        localVarQueryParameter['before_lt'] = beforeLt;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (startDate !== undefined) {
        localVarQueryParameter['start_date'] = startDate;
      }

      if (endDate !== undefined) {
        localVarQueryParameter['end_date'] = endDate;
      }

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get all Jettons balances by owner address
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJettonsBalances: async (
      accountId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('getJettonsBalances', 'accountId', accountId);
      const localVarPath = `/v2/accounts/{account_id}/jettons`.replace(
        `{${'account_id'}}`,
        encodeURIComponent(String(accountId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the transfer jettons history for account_id
     * @param {string} accountId account ID
     * @param {number} limit
     * @param {string} [acceptLanguage]
     * @param {number} [beforeLt] omit this parameter to get last events
     * @param {number} [startDate]
     * @param {number} [endDate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJettonsHistory: async (
      accountId: string,
      limit: number,
      acceptLanguage?: string,
      beforeLt?: number,
      startDate?: number,
      endDate?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('getJettonsHistory', 'accountId', accountId);
      // verify required parameter 'limit' is not null or undefined
      assertParamExists('getJettonsHistory', 'limit', limit);
      const localVarPath = `/v2/accounts/{account_id}/jettons/history`.replace(
        `{${'account_id'}}`,
        encodeURIComponent(String(accountId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (beforeLt !== undefined) {
        localVarQueryParameter['before_lt'] = beforeLt;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (startDate !== undefined) {
        localVarQueryParameter['start_date'] = startDate;
      }

      if (endDate !== undefined) {
        localVarQueryParameter['end_date'] = endDate;
      }

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the transfer jetton history for account_id and jetton_id
     * @param {string} accountId account ID
     * @param {string} jettonId jetton ID
     * @param {number} limit
     * @param {string} [acceptLanguage]
     * @param {number} [beforeLt] omit this parameter to get last events
     * @param {number} [startDate]
     * @param {number} [endDate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJettonsHistoryByID: async (
      accountId: string,
      jettonId: string,
      limit: number,
      acceptLanguage?: string,
      beforeLt?: number,
      startDate?: number,
      endDate?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('getJettonsHistoryByID', 'accountId', accountId);
      // verify required parameter 'jettonId' is not null or undefined
      assertParamExists('getJettonsHistoryByID', 'jettonId', jettonId);
      // verify required parameter 'limit' is not null or undefined
      assertParamExists('getJettonsHistoryByID', 'limit', limit);
      const localVarPath =
        `/v2/accounts/{account_id}/jettons/{jetton_id}/history`
          .replace(`{${'account_id'}}`, encodeURIComponent(String(accountId)))
          .replace(`{${'jetton_id'}}`, encodeURIComponent(String(jettonId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (beforeLt !== undefined) {
        localVarQueryParameter['before_lt'] = beforeLt;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (startDate !== undefined) {
        localVarQueryParameter['start_date'] = startDate;
      }

      if (endDate !== undefined) {
        localVarQueryParameter['end_date'] = endDate;
      }

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get all NFT items by owner address
     * @param {string} accountId account ID
     * @param {string} [collection] nft collection
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {boolean} [indirectOwnership] Selling nft items in ton implemented usually via transfer items to special selling account. This option enables including items which owned not directly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNftItemsByOwner: async (
      accountId: string,
      collection?: string,
      limit?: number,
      offset?: number,
      indirectOwnership?: boolean,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('getNftItemsByOwner', 'accountId', accountId);
      const localVarPath = `/v2/accounts/{account_id}/nfts`.replace(
        `{${'account_id'}}`,
        encodeURIComponent(String(accountId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (collection !== undefined) {
        localVarQueryParameter['collection'] = collection;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (indirectOwnership !== undefined) {
        localVarQueryParameter['indirect_ownership'] = indirectOwnership;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get public key by account id
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPublicKeyByAccountID: async (
      accountId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('getPublicKeyByAccountID', 'accountId', accountId);
      const localVarPath = `/v2/accounts/{account_id}/publickey`.replace(
        `{${'account_id'}}`,
        encodeURIComponent(String(accountId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Search for accounts by name. You can find the account by the first characters of the domain.
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSearchAccounts: async (
      name: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getSearchAccounts', 'name', name);
      const localVarPath = `/v2/accounts/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (name !== undefined) {
        localVarQueryParameter['name'] = name;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get all subscriptions by wallet address
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSubscriptionsByAccount: async (
      accountId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('getSubscriptionsByAccount', 'accountId', accountId);
      const localVarPath = `/v2/accounts/{account_id}/subscriptions`.replace(
        `{${'account_id'}}`,
        encodeURIComponent(String(accountId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get traces for account
     * @param {string} accountId account ID
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTracesByAccount: async (
      accountId: string,
      limit?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('getTracesByAccount', 'accountId', accountId);
      const localVarPath = `/v2/accounts/{account_id}/traces`.replace(
        `{${'account_id'}}`,
        encodeURIComponent(String(accountId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update internal cache for a particular account
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reindexAccount: async (
      accountId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('reindexAccount', 'accountId', accountId);
      const localVarPath = `/v2/accounts/{account_id}/reindex`.replace(
        `{${'account_id'}}`,
        encodeURIComponent(String(accountId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration);
  return {
    /**
     * Get domains for wallet account
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async dnsBackResolve(
      accountId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainNames>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.dnsBackResolve(
        accountId,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get human-friendly information about an account without low-level details.
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAccount(
      accountId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(
        accountId,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get human-friendly information about several accounts without low-level details.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] a list of account ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAccounts(
      uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Accounts>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAccounts(
        uNKNOWNBASETYPE,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get expiring .ton dns
     * @param {string} accountId account ID
     * @param {number} [period] number of days before expiration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDnsExpiring(
      accountId: string,
      period?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DnsExpiring>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDnsExpiring(
        accountId,
        period,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get events for an account. Each event is built on top of a trace which is a series of transactions caused by one inbound message. TonAPI looks for known patterns inside the trace and splits the trace into actions, where a single action represents a meaningful high-level operation like a Jetton Transfer or an NFT Purchase. Actions are expected to be shown to users. It is advised not to build any logic on top of actions because actions can be changed at any time.
     * @param {string} accountId account ID
     * @param {number} limit
     * @param {string} [acceptLanguage]
     * @param {boolean} [subjectOnly] filter actions where requested account is not real subject (for example sender or reciver jettons)
     * @param {number} [beforeLt] omit this parameter to get last events
     * @param {number} [startDate]
     * @param {number} [endDate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEventsByAccount(
      accountId: string,
      limit: number,
      acceptLanguage?: string,
      subjectOnly?: boolean,
      beforeLt?: number,
      startDate?: number,
      endDate?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountEvents>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getEventsByAccount(
          accountId,
          limit,
          acceptLanguage,
          subjectOnly,
          beforeLt,
          startDate,
          endDate,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get all Jettons balances by owner address
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getJettonsBalances(
      accountId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<JettonsBalances>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getJettonsBalances(accountId, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get the transfer jettons history for account_id
     * @param {string} accountId account ID
     * @param {number} limit
     * @param {string} [acceptLanguage]
     * @param {number} [beforeLt] omit this parameter to get last events
     * @param {number} [startDate]
     * @param {number} [endDate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getJettonsHistory(
      accountId: string,
      limit: number,
      acceptLanguage?: string,
      beforeLt?: number,
      startDate?: number,
      endDate?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountEvents>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getJettonsHistory(
          accountId,
          limit,
          acceptLanguage,
          beforeLt,
          startDate,
          endDate,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get the transfer jetton history for account_id and jetton_id
     * @param {string} accountId account ID
     * @param {string} jettonId jetton ID
     * @param {number} limit
     * @param {string} [acceptLanguage]
     * @param {number} [beforeLt] omit this parameter to get last events
     * @param {number} [startDate]
     * @param {number} [endDate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getJettonsHistoryByID(
      accountId: string,
      jettonId: string,
      limit: number,
      acceptLanguage?: string,
      beforeLt?: number,
      startDate?: number,
      endDate?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountEvents>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getJettonsHistoryByID(
          accountId,
          jettonId,
          limit,
          acceptLanguage,
          beforeLt,
          startDate,
          endDate,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get all NFT items by owner address
     * @param {string} accountId account ID
     * @param {string} [collection] nft collection
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {boolean} [indirectOwnership] Selling nft items in ton implemented usually via transfer items to special selling account. This option enables including items which owned not directly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getNftItemsByOwner(
      accountId: string,
      collection?: string,
      limit?: number,
      offset?: number,
      indirectOwnership?: boolean,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<NftItems>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getNftItemsByOwner(
          accountId,
          collection,
          limit,
          offset,
          indirectOwnership,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get public key by account id
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPublicKeyByAccountID(
      accountId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse200>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPublicKeyByAccountID(
          accountId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Search for accounts by name. You can find the account by the first characters of the domain.
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSearchAccounts(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FoundAccounts>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSearchAccounts(name, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get all subscriptions by wallet address
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSubscriptionsByAccount(
      accountId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriptions>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSubscriptionsByAccount(
          accountId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get traces for account
     * @param {string} accountId account ID
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTracesByAccount(
      accountId: string,
      limit?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TraceIds>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getTracesByAccount(
          accountId,
          limit,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Update internal cache for a particular account
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async reindexAccount(
      accountId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.reindexAccount(
        accountId,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AccountsApiFp(configuration);
  return {
    /**
     * Get domains for wallet account
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dnsBackResolve(
      accountId: string,
      options?: any,
    ): AxiosPromise<DomainNames> {
      return localVarFp
        .dnsBackResolve(accountId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get human-friendly information about an account without low-level details.
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccount(accountId: string, options?: any): AxiosPromise<Account> {
      return localVarFp
        .getAccount(accountId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get human-friendly information about several accounts without low-level details.
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] a list of account ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccounts(
      uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE,
      options?: any,
    ): AxiosPromise<Accounts> {
      return localVarFp
        .getAccounts(uNKNOWNBASETYPE, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get expiring .ton dns
     * @param {string} accountId account ID
     * @param {number} [period] number of days before expiration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDnsExpiring(
      accountId: string,
      period?: number,
      options?: any,
    ): AxiosPromise<DnsExpiring> {
      return localVarFp
        .getDnsExpiring(accountId, period, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get events for an account. Each event is built on top of a trace which is a series of transactions caused by one inbound message. TonAPI looks for known patterns inside the trace and splits the trace into actions, where a single action represents a meaningful high-level operation like a Jetton Transfer or an NFT Purchase. Actions are expected to be shown to users. It is advised not to build any logic on top of actions because actions can be changed at any time.
     * @param {string} accountId account ID
     * @param {number} limit
     * @param {string} [acceptLanguage]
     * @param {boolean} [subjectOnly] filter actions where requested account is not real subject (for example sender or reciver jettons)
     * @param {number} [beforeLt] omit this parameter to get last events
     * @param {number} [startDate]
     * @param {number} [endDate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventsByAccount(
      accountId: string,
      limit: number,
      acceptLanguage?: string,
      subjectOnly?: boolean,
      beforeLt?: number,
      startDate?: number,
      endDate?: number,
      options?: any,
    ): AxiosPromise<AccountEvents> {
      return localVarFp
        .getEventsByAccount(
          accountId,
          limit,
          acceptLanguage,
          subjectOnly,
          beforeLt,
          startDate,
          endDate,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get all Jettons balances by owner address
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJettonsBalances(
      accountId: string,
      options?: any,
    ): AxiosPromise<JettonsBalances> {
      return localVarFp
        .getJettonsBalances(accountId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get the transfer jettons history for account_id
     * @param {string} accountId account ID
     * @param {number} limit
     * @param {string} [acceptLanguage]
     * @param {number} [beforeLt] omit this parameter to get last events
     * @param {number} [startDate]
     * @param {number} [endDate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJettonsHistory(
      accountId: string,
      limit: number,
      acceptLanguage?: string,
      beforeLt?: number,
      startDate?: number,
      endDate?: number,
      options?: any,
    ): AxiosPromise<AccountEvents> {
      return localVarFp
        .getJettonsHistory(
          accountId,
          limit,
          acceptLanguage,
          beforeLt,
          startDate,
          endDate,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get the transfer jetton history for account_id and jetton_id
     * @param {string} accountId account ID
     * @param {string} jettonId jetton ID
     * @param {number} limit
     * @param {string} [acceptLanguage]
     * @param {number} [beforeLt] omit this parameter to get last events
     * @param {number} [startDate]
     * @param {number} [endDate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJettonsHistoryByID(
      accountId: string,
      jettonId: string,
      limit: number,
      acceptLanguage?: string,
      beforeLt?: number,
      startDate?: number,
      endDate?: number,
      options?: any,
    ): AxiosPromise<AccountEvents> {
      return localVarFp
        .getJettonsHistoryByID(
          accountId,
          jettonId,
          limit,
          acceptLanguage,
          beforeLt,
          startDate,
          endDate,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get all NFT items by owner address
     * @param {string} accountId account ID
     * @param {string} [collection] nft collection
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {boolean} [indirectOwnership] Selling nft items in ton implemented usually via transfer items to special selling account. This option enables including items which owned not directly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNftItemsByOwner(
      accountId: string,
      collection?: string,
      limit?: number,
      offset?: number,
      indirectOwnership?: boolean,
      options?: any,
    ): AxiosPromise<NftItems> {
      return localVarFp
        .getNftItemsByOwner(
          accountId,
          collection,
          limit,
          offset,
          indirectOwnership,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get public key by account id
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPublicKeyByAccountID(
      accountId: string,
      options?: any,
    ): AxiosPromise<InlineResponse200> {
      return localVarFp
        .getPublicKeyByAccountID(accountId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Search for accounts by name. You can find the account by the first characters of the domain.
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSearchAccounts(
      name: string,
      options?: any,
    ): AxiosPromise<FoundAccounts> {
      return localVarFp
        .getSearchAccounts(name, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get all subscriptions by wallet address
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSubscriptionsByAccount(
      accountId: string,
      options?: any,
    ): AxiosPromise<Subscriptions> {
      return localVarFp
        .getSubscriptionsByAccount(accountId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get traces for account
     * @param {string} accountId account ID
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTracesByAccount(
      accountId: string,
      limit?: number,
      options?: any,
    ): AxiosPromise<TraceIds> {
      return localVarFp
        .getTracesByAccount(accountId, limit, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update internal cache for a particular account
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reindexAccount(accountId: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .reindexAccount(accountId, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
  /**
   * Get domains for wallet account
   * @param {string} accountId account ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public dnsBackResolve(accountId: string, options?: AxiosRequestConfig) {
    return AccountsApiFp(this.configuration)
      .dnsBackResolve(accountId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get human-friendly information about an account without low-level details.
   * @param {string} accountId account ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public getAccount(accountId: string, options?: AxiosRequestConfig) {
    return AccountsApiFp(this.configuration)
      .getAccount(accountId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get human-friendly information about several accounts without low-level details.
   * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] a list of account ids
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public getAccounts(
    uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE,
    options?: AxiosRequestConfig,
  ) {
    return AccountsApiFp(this.configuration)
      .getAccounts(uNKNOWNBASETYPE, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get expiring .ton dns
   * @param {string} accountId account ID
   * @param {number} [period] number of days before expiration
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public getDnsExpiring(
    accountId: string,
    period?: number,
    options?: AxiosRequestConfig,
  ) {
    return AccountsApiFp(this.configuration)
      .getDnsExpiring(accountId, period, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get events for an account. Each event is built on top of a trace which is a series of transactions caused by one inbound message. TonAPI looks for known patterns inside the trace and splits the trace into actions, where a single action represents a meaningful high-level operation like a Jetton Transfer or an NFT Purchase. Actions are expected to be shown to users. It is advised not to build any logic on top of actions because actions can be changed at any time.
   * @param {string} accountId account ID
   * @param {number} limit
   * @param {string} [acceptLanguage]
   * @param {boolean} [subjectOnly] filter actions where requested account is not real subject (for example sender or reciver jettons)
   * @param {number} [beforeLt] omit this parameter to get last events
   * @param {number} [startDate]
   * @param {number} [endDate]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public getEventsByAccount(
    accountId: string,
    limit: number,
    acceptLanguage?: string,
    subjectOnly?: boolean,
    beforeLt?: number,
    startDate?: number,
    endDate?: number,
    options?: AxiosRequestConfig,
  ) {
    return AccountsApiFp(this.configuration)
      .getEventsByAccount(
        accountId,
        limit,
        acceptLanguage,
        subjectOnly,
        beforeLt,
        startDate,
        endDate,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get all Jettons balances by owner address
   * @param {string} accountId account ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public getJettonsBalances(accountId: string, options?: AxiosRequestConfig) {
    return AccountsApiFp(this.configuration)
      .getJettonsBalances(accountId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get the transfer jettons history for account_id
   * @param {string} accountId account ID
   * @param {number} limit
   * @param {string} [acceptLanguage]
   * @param {number} [beforeLt] omit this parameter to get last events
   * @param {number} [startDate]
   * @param {number} [endDate]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public getJettonsHistory(
    accountId: string,
    limit: number,
    acceptLanguage?: string,
    beforeLt?: number,
    startDate?: number,
    endDate?: number,
    options?: AxiosRequestConfig,
  ) {
    return AccountsApiFp(this.configuration)
      .getJettonsHistory(
        accountId,
        limit,
        acceptLanguage,
        beforeLt,
        startDate,
        endDate,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get the transfer jetton history for account_id and jetton_id
   * @param {string} accountId account ID
   * @param {string} jettonId jetton ID
   * @param {number} limit
   * @param {string} [acceptLanguage]
   * @param {number} [beforeLt] omit this parameter to get last events
   * @param {number} [startDate]
   * @param {number} [endDate]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public getJettonsHistoryByID(
    accountId: string,
    jettonId: string,
    limit: number,
    acceptLanguage?: string,
    beforeLt?: number,
    startDate?: number,
    endDate?: number,
    options?: AxiosRequestConfig,
  ) {
    return AccountsApiFp(this.configuration)
      .getJettonsHistoryByID(
        accountId,
        jettonId,
        limit,
        acceptLanguage,
        beforeLt,
        startDate,
        endDate,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get all NFT items by owner address
   * @param {string} accountId account ID
   * @param {string} [collection] nft collection
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {boolean} [indirectOwnership] Selling nft items in ton implemented usually via transfer items to special selling account. This option enables including items which owned not directly.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public getNftItemsByOwner(
    accountId: string,
    collection?: string,
    limit?: number,
    offset?: number,
    indirectOwnership?: boolean,
    options?: AxiosRequestConfig,
  ) {
    return AccountsApiFp(this.configuration)
      .getNftItemsByOwner(
        accountId,
        collection,
        limit,
        offset,
        indirectOwnership,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get public key by account id
   * @param {string} accountId account ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public getPublicKeyByAccountID(
    accountId: string,
    options?: AxiosRequestConfig,
  ) {
    return AccountsApiFp(this.configuration)
      .getPublicKeyByAccountID(accountId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Search for accounts by name. You can find the account by the first characters of the domain.
   * @param {string} name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public getSearchAccounts(name: string, options?: AxiosRequestConfig) {
    return AccountsApiFp(this.configuration)
      .getSearchAccounts(name, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get all subscriptions by wallet address
   * @param {string} accountId account ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public getSubscriptionsByAccount(
    accountId: string,
    options?: AxiosRequestConfig,
  ) {
    return AccountsApiFp(this.configuration)
      .getSubscriptionsByAccount(accountId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get traces for account
   * @param {string} accountId account ID
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public getTracesByAccount(
    accountId: string,
    limit?: number,
    options?: AxiosRequestConfig,
  ) {
    return AccountsApiFp(this.configuration)
      .getTracesByAccount(accountId, limit, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update internal cache for a particular account
   * @param {string} accountId account ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public reindexAccount(accountId: string, options?: AxiosRequestConfig) {
    return AccountsApiFp(this.configuration)
      .reindexAccount(accountId, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * BlockchainApi - axios parameter creator
 * @export
 */
export const BlockchainApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Execute get method for account
     * @param {string} accountId account ID
     * @param {string} methodName contract get method name
     * @param {Array<string>} [args]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    execGetMethod: async (
      accountId: string,
      methodName: string,
      args?: Array<string>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('execGetMethod', 'accountId', accountId);
      // verify required parameter 'methodName' is not null or undefined
      assertParamExists('execGetMethod', 'methodName', methodName);
      const localVarPath =
        `/v2/blockchain/accounts/{account_id}/methods/{method_name}`
          .replace(`{${'account_id'}}`, encodeURIComponent(String(accountId)))
          .replace(
            `{${'method_name'}}`,
            encodeURIComponent(String(methodName)),
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (args) {
        localVarQueryParameter['args'] = args;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get account transactions
     * @param {string} accountId account ID
     * @param {number} [afterLt] omit this parameter to get last transactions
     * @param {number} [beforeLt] omit this parameter to get last transactions
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccountTransactions: async (
      accountId: string,
      afterLt?: number,
      beforeLt?: number,
      limit?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('getAccountTransactions', 'accountId', accountId);
      const localVarPath =
        `/v2/blockchain/accounts/{account_id}/transactions`.replace(
          `{${'account_id'}}`,
          encodeURIComponent(String(accountId)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (afterLt !== undefined) {
        localVarQueryParameter['after_lt'] = afterLt;
      }

      if (beforeLt !== undefined) {
        localVarQueryParameter['before_lt'] = beforeLt;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get block data
     * @param {string} blockId block ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBlock: async (
      blockId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'blockId' is not null or undefined
      assertParamExists('getBlock', 'blockId', blockId);
      const localVarPath = `/v2/blockchain/blocks/{block_id}`.replace(
        `{${'block_id'}}`,
        encodeURIComponent(String(blockId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get transactions from block
     * @param {string} blockId block ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBlockTransactions: async (
      blockId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'blockId' is not null or undefined
      assertParamExists('getBlockTransactions', 'blockId', blockId);
      const localVarPath =
        `/v2/blockchain/blocks/{block_id}/transactions`.replace(
          `{${'block_id'}}`,
          encodeURIComponent(String(blockId)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get blockchain config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConfig: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v2/blockchain/config`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get last known masterchain block
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMasterchainHead: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v2/blockchain/masterchain-head`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get low-level information about an account taken directly from the blockchain.
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRawAccount: async (
      accountId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('getRawAccount', 'accountId', accountId);
      const localVarPath = `/v2/blockchain/accounts/{account_id}`.replace(
        `{${'account_id'}}`,
        encodeURIComponent(String(accountId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get transaction data
     * @param {string} transactionId transaction ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransaction: async (
      transactionId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'transactionId' is not null or undefined
      assertParamExists('getTransaction', 'transactionId', transactionId);
      const localVarPath =
        `/v2/blockchain/transactions/{transaction_id}`.replace(
          `{${'transaction_id'}}`,
          encodeURIComponent(String(transactionId)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get transaction data by message hash
     * @param {string} msgId message ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransactionByMessageHash: async (
      msgId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'msgId' is not null or undefined
      assertParamExists('getTransactionByMessageHash', 'msgId', msgId);
      const localVarPath =
        `/v2/blockchain/messages/{msg_id}/transaction`.replace(
          `{${'msg_id'}}`,
          encodeURIComponent(String(msgId)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get validators
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getValidators: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v2/blockchain/validators`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Send message to blockchain
     * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE bag-of-cells serialized to base64
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendMessage: async (
      uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uNKNOWNBASETYPE' is not null or undefined
      assertParamExists('sendMessage', 'uNKNOWNBASETYPE', uNKNOWNBASETYPE);
      const localVarPath = `/v2/blockchain/message`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        uNKNOWNBASETYPE,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * BlockchainApi - functional programming interface
 * @export
 */
export const BlockchainApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    BlockchainApiAxiosParamCreator(configuration);
  return {
    /**
     * Execute get method for account
     * @param {string} accountId account ID
     * @param {string} methodName contract get method name
     * @param {Array<string>} [args]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async execGetMethod(
      accountId: string,
      methodName: string,
      args?: Array<string>,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<MethodExecutionResult>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.execGetMethod(
        accountId,
        methodName,
        args,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get account transactions
     * @param {string} accountId account ID
     * @param {number} [afterLt] omit this parameter to get last transactions
     * @param {number} [beforeLt] omit this parameter to get last transactions
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAccountTransactions(
      accountId: string,
      afterLt?: number,
      beforeLt?: number,
      limit?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transactions>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAccountTransactions(
          accountId,
          afterLt,
          beforeLt,
          limit,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get block data
     * @param {string} blockId block ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBlock(
      blockId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Block>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBlock(
        blockId,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get transactions from block
     * @param {string} blockId block ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBlockTransactions(
      blockId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transactions>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getBlockTransactions(blockId, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get blockchain config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getConfig(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Config>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getConfig(
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get last known masterchain block
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMasterchainHead(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Block>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getMasterchainHead(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get low-level information about an account taken directly from the blockchain.
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRawAccount(
      accountId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RawAccount>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRawAccount(
        accountId,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get transaction data
     * @param {string} transactionId transaction ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTransaction(
      transactionId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transaction>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTransaction(
        transactionId,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get transaction data by message hash
     * @param {string} msgId message ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTransactionByMessageHash(
      msgId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transaction>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getTransactionByMessageHash(
          msgId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get validators
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getValidators(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Validators>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getValidators(
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Send message to blockchain
     * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE bag-of-cells serialized to base64
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sendMessage(
      uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.sendMessage(
        uNKNOWNBASETYPE,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * BlockchainApi - factory interface
 * @export
 */
export const BlockchainApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = BlockchainApiFp(configuration);
  return {
    /**
     * Execute get method for account
     * @param {string} accountId account ID
     * @param {string} methodName contract get method name
     * @param {Array<string>} [args]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    execGetMethod(
      accountId: string,
      methodName: string,
      args?: Array<string>,
      options?: any,
    ): AxiosPromise<MethodExecutionResult> {
      return localVarFp
        .execGetMethod(accountId, methodName, args, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get account transactions
     * @param {string} accountId account ID
     * @param {number} [afterLt] omit this parameter to get last transactions
     * @param {number} [beforeLt] omit this parameter to get last transactions
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccountTransactions(
      accountId: string,
      afterLt?: number,
      beforeLt?: number,
      limit?: number,
      options?: any,
    ): AxiosPromise<Transactions> {
      return localVarFp
        .getAccountTransactions(accountId, afterLt, beforeLt, limit, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get block data
     * @param {string} blockId block ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBlock(blockId: string, options?: any): AxiosPromise<Block> {
      return localVarFp
        .getBlock(blockId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get transactions from block
     * @param {string} blockId block ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBlockTransactions(
      blockId: string,
      options?: any,
    ): AxiosPromise<Transactions> {
      return localVarFp
        .getBlockTransactions(blockId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get blockchain config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConfig(options?: any): AxiosPromise<Config> {
      return localVarFp
        .getConfig(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get last known masterchain block
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMasterchainHead(options?: any): AxiosPromise<Block> {
      return localVarFp
        .getMasterchainHead(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get low-level information about an account taken directly from the blockchain.
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRawAccount(accountId: string, options?: any): AxiosPromise<RawAccount> {
      return localVarFp
        .getRawAccount(accountId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get transaction data
     * @param {string} transactionId transaction ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransaction(
      transactionId: string,
      options?: any,
    ): AxiosPromise<Transaction> {
      return localVarFp
        .getTransaction(transactionId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get transaction data by message hash
     * @param {string} msgId message ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransactionByMessageHash(
      msgId: string,
      options?: any,
    ): AxiosPromise<Transaction> {
      return localVarFp
        .getTransactionByMessageHash(msgId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get validators
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getValidators(options?: any): AxiosPromise<Validators> {
      return localVarFp
        .getValidators(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Send message to blockchain
     * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE bag-of-cells serialized to base64
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendMessage(
      uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .sendMessage(uNKNOWNBASETYPE, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * BlockchainApi - object-oriented interface
 * @export
 * @class BlockchainApi
 * @extends {BaseAPI}
 */
export class BlockchainApi extends BaseAPI {
  /**
   * Execute get method for account
   * @param {string} accountId account ID
   * @param {string} methodName contract get method name
   * @param {Array<string>} [args]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BlockchainApi
   */
  public execGetMethod(
    accountId: string,
    methodName: string,
    args?: Array<string>,
    options?: AxiosRequestConfig,
  ) {
    return BlockchainApiFp(this.configuration)
      .execGetMethod(accountId, methodName, args, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get account transactions
   * @param {string} accountId account ID
   * @param {number} [afterLt] omit this parameter to get last transactions
   * @param {number} [beforeLt] omit this parameter to get last transactions
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BlockchainApi
   */
  public getAccountTransactions(
    accountId: string,
    afterLt?: number,
    beforeLt?: number,
    limit?: number,
    options?: AxiosRequestConfig,
  ) {
    return BlockchainApiFp(this.configuration)
      .getAccountTransactions(accountId, afterLt, beforeLt, limit, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get block data
   * @param {string} blockId block ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BlockchainApi
   */
  public getBlock(blockId: string, options?: AxiosRequestConfig) {
    return BlockchainApiFp(this.configuration)
      .getBlock(blockId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get transactions from block
   * @param {string} blockId block ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BlockchainApi
   */
  public getBlockTransactions(blockId: string, options?: AxiosRequestConfig) {
    return BlockchainApiFp(this.configuration)
      .getBlockTransactions(blockId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get blockchain config
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BlockchainApi
   */
  public getConfig(options?: AxiosRequestConfig) {
    return BlockchainApiFp(this.configuration)
      .getConfig(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get last known masterchain block
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BlockchainApi
   */
  public getMasterchainHead(options?: AxiosRequestConfig) {
    return BlockchainApiFp(this.configuration)
      .getMasterchainHead(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get low-level information about an account taken directly from the blockchain.
   * @param {string} accountId account ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BlockchainApi
   */
  public getRawAccount(accountId: string, options?: AxiosRequestConfig) {
    return BlockchainApiFp(this.configuration)
      .getRawAccount(accountId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get transaction data
   * @param {string} transactionId transaction ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BlockchainApi
   */
  public getTransaction(transactionId: string, options?: AxiosRequestConfig) {
    return BlockchainApiFp(this.configuration)
      .getTransaction(transactionId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get transaction data by message hash
   * @param {string} msgId message ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BlockchainApi
   */
  public getTransactionByMessageHash(
    msgId: string,
    options?: AxiosRequestConfig,
  ) {
    return BlockchainApiFp(this.configuration)
      .getTransactionByMessageHash(msgId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get validators
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BlockchainApi
   */
  public getValidators(options?: AxiosRequestConfig) {
    return BlockchainApiFp(this.configuration)
      .getValidators(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Send message to blockchain
   * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE bag-of-cells serialized to base64
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BlockchainApi
   */
  public sendMessage(
    uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE,
    options?: AxiosRequestConfig,
  ) {
    return BlockchainApiFp(this.configuration)
      .sendMessage(uNKNOWNBASETYPE, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ConnectApi - axios parameter creator
 * @export
 */
export const ConnectApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Get account info by state init
     * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE Data that is expected
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccountInfoByStateInit: async (
      uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uNKNOWNBASETYPE' is not null or undefined
      assertParamExists(
        'getAccountInfoByStateInit',
        'uNKNOWNBASETYPE',
        uNKNOWNBASETYPE,
      );
      const localVarPath = `/v2/tonconnect/stateinit`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        uNKNOWNBASETYPE,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a payload for further token receipt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTonConnectPayload: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v2/tonconnect/payload`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ConnectApi - functional programming interface
 * @export
 */
export const ConnectApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ConnectApiAxiosParamCreator(configuration);
  return {
    /**
     * Get account info by state init
     * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE Data that is expected
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAccountInfoByStateInit(
      uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<AccountInfoByStateInit>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAccountInfoByStateInit(
          uNKNOWNBASETYPE,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get a payload for further token receipt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTonConnectPayload(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse2006>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getTonConnectPayload(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * ConnectApi - factory interface
 * @export
 */
export const ConnectApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ConnectApiFp(configuration);
  return {
    /**
     * Get account info by state init
     * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE Data that is expected
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccountInfoByStateInit(
      uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE,
      options?: any,
    ): AxiosPromise<AccountInfoByStateInit> {
      return localVarFp
        .getAccountInfoByStateInit(uNKNOWNBASETYPE, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a payload for further token receipt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTonConnectPayload(options?: any): AxiosPromise<InlineResponse2006> {
      return localVarFp
        .getTonConnectPayload(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ConnectApi - object-oriented interface
 * @export
 * @class ConnectApi
 * @extends {BaseAPI}
 */
export class ConnectApi extends BaseAPI {
  /**
   * Get account info by state init
   * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE Data that is expected
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConnectApi
   */
  public getAccountInfoByStateInit(
    uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE,
    options?: AxiosRequestConfig,
  ) {
    return ConnectApiFp(this.configuration)
      .getAccountInfoByStateInit(uNKNOWNBASETYPE, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a payload for further token receipt
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConnectApi
   */
  public getTonConnectPayload(options?: AxiosRequestConfig) {
    return ConnectApiFp(this.configuration)
      .getTonConnectPayload(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * DNSApi - axios parameter creator
 * @export
 */
export const DNSApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * get full information about domain name
     * @param {string} domainName domain name with .ton or .t.me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dnsInfo: async (
      domainName: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'domainName' is not null or undefined
      assertParamExists('dnsInfo', 'domainName', domainName);
      const localVarPath = `/v2/dns/{domain_name}`.replace(
        `{${'domain_name'}}`,
        encodeURIComponent(String(domainName)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * DNS resolve for domain name
     * @param {string} domainName domain name with .ton or .t.me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dnsResolve: async (
      domainName: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'domainName' is not null or undefined
      assertParamExists('dnsResolve', 'domainName', domainName);
      const localVarPath = `/v2/dns/{domain_name}/resolve`.replace(
        `{${'domain_name'}}`,
        encodeURIComponent(String(domainName)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get all auctions
     * @param {string} [tld] domain filter for current auctions \&quot;ton\&quot; or \&quot;t.me\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllAuctions: async (
      tld?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v2/dns/auctions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (tld !== undefined) {
        localVarQueryParameter['tld'] = tld;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get domain bids
     * @param {string} domainName domain name with .ton or .t.me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDomainBids: async (
      domainName: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'domainName' is not null or undefined
      assertParamExists('getDomainBids', 'domainName', domainName);
      const localVarPath = `/v2/dns/{domain_name}/bids`.replace(
        `{${'domain_name'}}`,
        encodeURIComponent(String(domainName)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DNSApi - functional programming interface
 * @export
 */
export const DNSApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DNSApiAxiosParamCreator(configuration);
  return {
    /**
     * get full information about domain name
     * @param {string} domainName domain name with .ton or .t.me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async dnsInfo(
      domainName: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainInfo>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.dnsInfo(
        domainName,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * DNS resolve for domain name
     * @param {string} domainName domain name with .ton or .t.me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async dnsResolve(
      domainName: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DnsRecord>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.dnsResolve(
        domainName,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get all auctions
     * @param {string} [tld] domain filter for current auctions \&quot;ton\&quot; or \&quot;t.me\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllAuctions(
      tld?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Auctions>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllAuctions(
        tld,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get domain bids
     * @param {string} domainName domain name with .ton or .t.me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDomainBids(
      domainName: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainBids>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDomainBids(
        domainName,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * DNSApi - factory interface
 * @export
 */
export const DNSApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DNSApiFp(configuration);
  return {
    /**
     * get full information about domain name
     * @param {string} domainName domain name with .ton or .t.me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dnsInfo(domainName: string, options?: any): AxiosPromise<DomainInfo> {
      return localVarFp
        .dnsInfo(domainName, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * DNS resolve for domain name
     * @param {string} domainName domain name with .ton or .t.me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dnsResolve(domainName: string, options?: any): AxiosPromise<DnsRecord> {
      return localVarFp
        .dnsResolve(domainName, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get all auctions
     * @param {string} [tld] domain filter for current auctions \&quot;ton\&quot; or \&quot;t.me\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllAuctions(tld?: string, options?: any): AxiosPromise<Auctions> {
      return localVarFp
        .getAllAuctions(tld, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get domain bids
     * @param {string} domainName domain name with .ton or .t.me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDomainBids(domainName: string, options?: any): AxiosPromise<DomainBids> {
      return localVarFp
        .getDomainBids(domainName, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * DNSApi - object-oriented interface
 * @export
 * @class DNSApi
 * @extends {BaseAPI}
 */
export class DNSApi extends BaseAPI {
  /**
   * get full information about domain name
   * @param {string} domainName domain name with .ton or .t.me
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DNSApi
   */
  public dnsInfo(domainName: string, options?: AxiosRequestConfig) {
    return DNSApiFp(this.configuration)
      .dnsInfo(domainName, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * DNS resolve for domain name
   * @param {string} domainName domain name with .ton or .t.me
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DNSApi
   */
  public dnsResolve(domainName: string, options?: AxiosRequestConfig) {
    return DNSApiFp(this.configuration)
      .dnsResolve(domainName, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get all auctions
   * @param {string} [tld] domain filter for current auctions \&quot;ton\&quot; or \&quot;t.me\&quot;
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DNSApi
   */
  public getAllAuctions(tld?: string, options?: AxiosRequestConfig) {
    return DNSApiFp(this.configuration)
      .getAllAuctions(tld, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get domain bids
   * @param {string} domainName domain name with .ton or .t.me
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DNSApi
   */
  public getDomainBids(domainName: string, options?: AxiosRequestConfig) {
    return DNSApiFp(this.configuration)
      .getDomainBids(domainName, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * EmulationApi - axios parameter creator
 * @export
 */
export const EmulationApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Emulate sending message to blockchain
     * @param {string} accountId account ID
     * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE bag-of-cells serialized to base64
     * @param {string} [acceptLanguage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    emulateMessageToAccountEvent: async (
      accountId: string,
      uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE,
      acceptLanguage?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('emulateMessageToAccountEvent', 'accountId', accountId);
      // verify required parameter 'uNKNOWNBASETYPE' is not null or undefined
      assertParamExists(
        'emulateMessageToAccountEvent',
        'uNKNOWNBASETYPE',
        uNKNOWNBASETYPE,
      );
      const localVarPath = `/v2/accounts/{account_id}/events/emulate`.replace(
        `{${'account_id'}}`,
        encodeURIComponent(String(accountId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        uNKNOWNBASETYPE,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Emulate sending message to blockchain
     * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE bag-of-cells serialized to base64
     * @param {string} [acceptLanguage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    emulateMessageToEvent: async (
      uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE,
      acceptLanguage?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uNKNOWNBASETYPE' is not null or undefined
      assertParamExists(
        'emulateMessageToEvent',
        'uNKNOWNBASETYPE',
        uNKNOWNBASETYPE,
      );
      const localVarPath = `/v2/events/emulate`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        uNKNOWNBASETYPE,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Emulate sending message to blockchain
     * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE bag-of-cells serialized to base64
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    emulateMessageToTrace: async (
      uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uNKNOWNBASETYPE' is not null or undefined
      assertParamExists(
        'emulateMessageToTrace',
        'uNKNOWNBASETYPE',
        uNKNOWNBASETYPE,
      );
      const localVarPath = `/v2/traces/emulate`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        uNKNOWNBASETYPE,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Emulate sending message to blockchain
     * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE bag-of-cells serialized to base64
     * @param {string} [acceptLanguage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    emulateWalletMessage: async (
      uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE,
      acceptLanguage?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uNKNOWNBASETYPE' is not null or undefined
      assertParamExists(
        'emulateWalletMessage',
        'uNKNOWNBASETYPE',
        uNKNOWNBASETYPE,
      );
      const localVarPath = `/v2/wallet/emulate`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        uNKNOWNBASETYPE,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * EmulationApi - functional programming interface
 * @export
 */
export const EmulationApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    EmulationApiAxiosParamCreator(configuration);
  return {
    /**
     * Emulate sending message to blockchain
     * @param {string} accountId account ID
     * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE bag-of-cells serialized to base64
     * @param {string} [acceptLanguage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async emulateMessageToAccountEvent(
      accountId: string,
      uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE,
      acceptLanguage?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountEvent>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.emulateMessageToAccountEvent(
          accountId,
          uNKNOWNBASETYPE,
          acceptLanguage,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Emulate sending message to blockchain
     * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE bag-of-cells serialized to base64
     * @param {string} [acceptLanguage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async emulateMessageToEvent(
      uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE,
      acceptLanguage?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.emulateMessageToEvent(
          uNKNOWNBASETYPE,
          acceptLanguage,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Emulate sending message to blockchain
     * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE bag-of-cells serialized to base64
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async emulateMessageToTrace(
      uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Trace>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.emulateMessageToTrace(
          uNKNOWNBASETYPE,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Emulate sending message to blockchain
     * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE bag-of-cells serialized to base64
     * @param {string} [acceptLanguage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async emulateWalletMessage(
      uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE,
      acceptLanguage?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<MessageConsequences>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.emulateWalletMessage(
          uNKNOWNBASETYPE,
          acceptLanguage,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * EmulationApi - factory interface
 * @export
 */
export const EmulationApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = EmulationApiFp(configuration);
  return {
    /**
     * Emulate sending message to blockchain
     * @param {string} accountId account ID
     * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE bag-of-cells serialized to base64
     * @param {string} [acceptLanguage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    emulateMessageToAccountEvent(
      accountId: string,
      uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE,
      acceptLanguage?: string,
      options?: any,
    ): AxiosPromise<AccountEvent> {
      return localVarFp
        .emulateMessageToAccountEvent(
          accountId,
          uNKNOWNBASETYPE,
          acceptLanguage,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Emulate sending message to blockchain
     * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE bag-of-cells serialized to base64
     * @param {string} [acceptLanguage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    emulateMessageToEvent(
      uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE,
      acceptLanguage?: string,
      options?: any,
    ): AxiosPromise<Event> {
      return localVarFp
        .emulateMessageToEvent(uNKNOWNBASETYPE, acceptLanguage, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Emulate sending message to blockchain
     * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE bag-of-cells serialized to base64
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    emulateMessageToTrace(
      uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE,
      options?: any,
    ): AxiosPromise<Trace> {
      return localVarFp
        .emulateMessageToTrace(uNKNOWNBASETYPE, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Emulate sending message to blockchain
     * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE bag-of-cells serialized to base64
     * @param {string} [acceptLanguage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    emulateWalletMessage(
      uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE,
      acceptLanguage?: string,
      options?: any,
    ): AxiosPromise<MessageConsequences> {
      return localVarFp
        .emulateWalletMessage(uNKNOWNBASETYPE, acceptLanguage, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * EmulationApi - object-oriented interface
 * @export
 * @class EmulationApi
 * @extends {BaseAPI}
 */
export class EmulationApi extends BaseAPI {
  /**
   * Emulate sending message to blockchain
   * @param {string} accountId account ID
   * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE bag-of-cells serialized to base64
   * @param {string} [acceptLanguage]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EmulationApi
   */
  public emulateMessageToAccountEvent(
    accountId: string,
    uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE,
    acceptLanguage?: string,
    options?: AxiosRequestConfig,
  ) {
    return EmulationApiFp(this.configuration)
      .emulateMessageToAccountEvent(
        accountId,
        uNKNOWNBASETYPE,
        acceptLanguage,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Emulate sending message to blockchain
   * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE bag-of-cells serialized to base64
   * @param {string} [acceptLanguage]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EmulationApi
   */
  public emulateMessageToEvent(
    uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE,
    acceptLanguage?: string,
    options?: AxiosRequestConfig,
  ) {
    return EmulationApiFp(this.configuration)
      .emulateMessageToEvent(uNKNOWNBASETYPE, acceptLanguage, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Emulate sending message to blockchain
   * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE bag-of-cells serialized to base64
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EmulationApi
   */
  public emulateMessageToTrace(
    uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE,
    options?: AxiosRequestConfig,
  ) {
    return EmulationApiFp(this.configuration)
      .emulateMessageToTrace(uNKNOWNBASETYPE, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Emulate sending message to blockchain
   * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE bag-of-cells serialized to base64
   * @param {string} [acceptLanguage]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EmulationApi
   */
  public emulateWalletMessage(
    uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE,
    acceptLanguage?: string,
    options?: AxiosRequestConfig,
  ) {
    return EmulationApiFp(this.configuration)
      .emulateWalletMessage(uNKNOWNBASETYPE, acceptLanguage, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Get an event either by event ID or a hash of any transaction in a trace. An event is built on top of a trace which is a series of transactions caused by one inbound message. TonAPI looks for known patterns inside the trace and splits the trace into actions, where a single action represents a meaningful high-level operation like a Jetton Transfer or an NFT Purchase. Actions are expected to be shown to users. It is advised not to build any logic on top of actions because actions can be changed at any time.
     * @param {string} eventId event ID or transaction hash in hex (without 0x) or base64url format
     * @param {string} [acceptLanguage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEvent: async (
      eventId: string,
      acceptLanguage?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'eventId' is not null or undefined
      assertParamExists('getEvent', 'eventId', eventId);
      const localVarPath = `/v2/events/{event_id}`.replace(
        `{${'event_id'}}`,
        encodeURIComponent(String(eventId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration);
  return {
    /**
     * Get an event either by event ID or a hash of any transaction in a trace. An event is built on top of a trace which is a series of transactions caused by one inbound message. TonAPI looks for known patterns inside the trace and splits the trace into actions, where a single action represents a meaningful high-level operation like a Jetton Transfer or an NFT Purchase. Actions are expected to be shown to users. It is advised not to build any logic on top of actions because actions can be changed at any time.
     * @param {string} eventId event ID or transaction hash in hex (without 0x) or base64url format
     * @param {string} [acceptLanguage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEvent(
      eventId: string,
      acceptLanguage?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEvent(
        eventId,
        acceptLanguage,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = EventsApiFp(configuration);
  return {
    /**
     * Get an event either by event ID or a hash of any transaction in a trace. An event is built on top of a trace which is a series of transactions caused by one inbound message. TonAPI looks for known patterns inside the trace and splits the trace into actions, where a single action represents a meaningful high-level operation like a Jetton Transfer or an NFT Purchase. Actions are expected to be shown to users. It is advised not to build any logic on top of actions because actions can be changed at any time.
     * @param {string} eventId event ID or transaction hash in hex (without 0x) or base64url format
     * @param {string} [acceptLanguage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEvent(
      eventId: string,
      acceptLanguage?: string,
      options?: any,
    ): AxiosPromise<Event> {
      return localVarFp
        .getEvent(eventId, acceptLanguage, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
  /**
   * Get an event either by event ID or a hash of any transaction in a trace. An event is built on top of a trace which is a series of transactions caused by one inbound message. TonAPI looks for known patterns inside the trace and splits the trace into actions, where a single action represents a meaningful high-level operation like a Jetton Transfer or an NFT Purchase. Actions are expected to be shown to users. It is advised not to build any logic on top of actions because actions can be changed at any time.
   * @param {string} eventId event ID or transaction hash in hex (without 0x) or base64url format
   * @param {string} [acceptLanguage]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventsApi
   */
  public getEvent(
    eventId: string,
    acceptLanguage?: string,
    options?: AxiosRequestConfig,
  ) {
    return EventsApiFp(this.configuration)
      .getEvent(eventId, acceptLanguage, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * JettonsApi - axios parameter creator
 * @export
 */
export const JettonsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Get jetton metadata by jetton master address
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJettonInfo: async (
      accountId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('getJettonInfo', 'accountId', accountId);
      const localVarPath = `/v2/jettons/{account_id}`.replace(
        `{${'account_id'}}`,
        encodeURIComponent(String(accountId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of all indexed jetton masters in the blockchain.
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJettons: async (
      limit?: number,
      offset?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v2/jettons`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * JettonsApi - functional programming interface
 * @export
 */
export const JettonsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = JettonsApiAxiosParamCreator(configuration);
  return {
    /**
     * Get jetton metadata by jetton master address
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getJettonInfo(
      accountId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JettonInfo>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getJettonInfo(
        accountId,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get a list of all indexed jetton masters in the blockchain.
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getJettons(
      limit?: number,
      offset?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Jettons>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getJettons(
        limit,
        offset,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * JettonsApi - factory interface
 * @export
 */
export const JettonsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = JettonsApiFp(configuration);
  return {
    /**
     * Get jetton metadata by jetton master address
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJettonInfo(accountId: string, options?: any): AxiosPromise<JettonInfo> {
      return localVarFp
        .getJettonInfo(accountId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a list of all indexed jetton masters in the blockchain.
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJettons(
      limit?: number,
      offset?: number,
      options?: any,
    ): AxiosPromise<Jettons> {
      return localVarFp
        .getJettons(limit, offset, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * JettonsApi - object-oriented interface
 * @export
 * @class JettonsApi
 * @extends {BaseAPI}
 */
export class JettonsApi extends BaseAPI {
  /**
   * Get jetton metadata by jetton master address
   * @param {string} accountId account ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof JettonsApi
   */
  public getJettonInfo(accountId: string, options?: AxiosRequestConfig) {
    return JettonsApiFp(this.configuration)
      .getJettonInfo(accountId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of all indexed jetton masters in the blockchain.
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof JettonsApi
   */
  public getJettons(
    limit?: number,
    offset?: number,
    options?: AxiosRequestConfig,
  ) {
    return JettonsApiFp(this.configuration)
      .getJettons(limit, offset, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * LiteServerApi - axios parameter creator
 * @export
 */
export const LiteServerApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Get account state
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccountStateLiteServer: async (
      accountId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('getAccountStateLiteServer', 'accountId', accountId);
      const localVarPath =
        `/v2/liteserver/get_account_state/{account_id}`.replace(
          `{${'account_id'}}`,
          encodeURIComponent(String(accountId)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get all shards info
     * @param {string} blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllShardsInfoLiteServer: async (
      blockId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'blockId' is not null or undefined
      assertParamExists('getAllShardsInfoLiteServer', 'blockId', blockId);
      const localVarPath =
        `/v2/liteserver/get_all_shards_info/{block_id}`.replace(
          `{${'block_id'}}`,
          encodeURIComponent(String(blockId)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get block header
     * @param {string} blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @param {number} mode mode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBlockHeaderLiteServer: async (
      blockId: string,
      mode: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'blockId' is not null or undefined
      assertParamExists('getBlockHeaderLiteServer', 'blockId', blockId);
      // verify required parameter 'mode' is not null or undefined
      assertParamExists('getBlockHeaderLiteServer', 'mode', mode);
      const localVarPath = `/v2/liteserver/get_block_header/{block_id}`.replace(
        `{${'block_id'}}`,
        encodeURIComponent(String(blockId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (mode !== undefined) {
        localVarQueryParameter['mode'] = mode;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get block
     * @param {string} blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBlockLiteServer: async (
      blockId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'blockId' is not null or undefined
      assertParamExists('getBlockLiteServer', 'blockId', blockId);
      const localVarPath = `/v2/liteserver/get_block/{block_id}`.replace(
        `{${'block_id'}}`,
        encodeURIComponent(String(blockId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get block proof
     * @param {string} knownBlock known block: (workchain,shard,seqno,root_hash,file_hash)
     * @param {number} mode mode
     * @param {string} [targetBlock] target block: (workchain,shard,seqno,root_hash,file_hash)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBlockProofLiteServer: async (
      knownBlock: string,
      mode: number,
      targetBlock?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'knownBlock' is not null or undefined
      assertParamExists('getBlockProofLiteServer', 'knownBlock', knownBlock);
      // verify required parameter 'mode' is not null or undefined
      assertParamExists('getBlockProofLiteServer', 'mode', mode);
      const localVarPath = `/v2/liteserver/get_block_proof`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (knownBlock !== undefined) {
        localVarQueryParameter['known_block'] = knownBlock;
      }

      if (targetBlock !== undefined) {
        localVarQueryParameter['target_block'] = targetBlock;
      }

      if (mode !== undefined) {
        localVarQueryParameter['mode'] = mode;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get config all
     * @param {string} blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @param {number} mode mode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConfigAllLiteServer: async (
      blockId: string,
      mode: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'blockId' is not null or undefined
      assertParamExists('getConfigAllLiteServer', 'blockId', blockId);
      // verify required parameter 'mode' is not null or undefined
      assertParamExists('getConfigAllLiteServer', 'mode', mode);
      const localVarPath = `/v2/liteserver/get_config_all/{block_id}`.replace(
        `{${'block_id'}}`,
        encodeURIComponent(String(blockId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (mode !== undefined) {
        localVarQueryParameter['mode'] = mode;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get list block transactions
     * @param {string} blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @param {number} mode mode
     * @param {number} count count
     * @param {string} [accountId] account ID
     * @param {number} [lt] lt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getListBlockTransactionsLiteServer: async (
      blockId: string,
      mode: number,
      count: number,
      accountId?: string,
      lt?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'blockId' is not null or undefined
      assertParamExists(
        'getListBlockTransactionsLiteServer',
        'blockId',
        blockId,
      );
      // verify required parameter 'mode' is not null or undefined
      assertParamExists('getListBlockTransactionsLiteServer', 'mode', mode);
      // verify required parameter 'count' is not null or undefined
      assertParamExists('getListBlockTransactionsLiteServer', 'count', count);
      const localVarPath =
        `/v2/liteserver/list_block_transactions/{block_id}`.replace(
          `{${'block_id'}}`,
          encodeURIComponent(String(blockId)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (mode !== undefined) {
        localVarQueryParameter['mode'] = mode;
      }

      if (count !== undefined) {
        localVarQueryParameter['count'] = count;
      }

      if (accountId !== undefined) {
        localVarQueryParameter['account_id'] = accountId;
      }

      if (lt !== undefined) {
        localVarQueryParameter['lt'] = lt;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get masterchain info ext
     * @param {number} mode mode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMasterchainInfoExtLiteServer: async (
      mode: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'mode' is not null or undefined
      assertParamExists('getMasterchainInfoExtLiteServer', 'mode', mode);
      const localVarPath = `/v2/liteserver/get_masterchain_info_ext`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (mode !== undefined) {
        localVarQueryParameter['mode'] = mode;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get masterchain info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMasterchainInfoLiteServer: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v2/liteserver/get_masterchain_info`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get shard block proof
     * @param {string} blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getShardBlockProofLiteServer: async (
      blockId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'blockId' is not null or undefined
      assertParamExists('getShardBlockProofLiteServer', 'blockId', blockId);
      const localVarPath =
        `/v2/liteserver/get_shard_block_proof/{block_id}`.replace(
          `{${'block_id'}}`,
          encodeURIComponent(String(blockId)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get shard info
     * @param {string} blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @param {number} workchain workchain
     * @param {number} shard shard
     * @param {boolean} exact exact
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getShardInfoLiteServer: async (
      blockId: string,
      workchain: number,
      shard: number,
      exact: boolean,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'blockId' is not null or undefined
      assertParamExists('getShardInfoLiteServer', 'blockId', blockId);
      // verify required parameter 'workchain' is not null or undefined
      assertParamExists('getShardInfoLiteServer', 'workchain', workchain);
      // verify required parameter 'shard' is not null or undefined
      assertParamExists('getShardInfoLiteServer', 'shard', shard);
      // verify required parameter 'exact' is not null or undefined
      assertParamExists('getShardInfoLiteServer', 'exact', exact);
      const localVarPath = `/v2/liteserver/get_shard_info/{block_id}`.replace(
        `{${'block_id'}}`,
        encodeURIComponent(String(blockId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (workchain !== undefined) {
        localVarQueryParameter['workchain'] = workchain;
      }

      if (shard !== undefined) {
        localVarQueryParameter['shard'] = shard;
      }

      if (exact !== undefined) {
        localVarQueryParameter['exact'] = exact;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get block state
     * @param {string} blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStateLiteServer: async (
      blockId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'blockId' is not null or undefined
      assertParamExists('getStateLiteServer', 'blockId', blockId);
      const localVarPath = `/v2/liteserver/get_state/{block_id}`.replace(
        `{${'block_id'}}`,
        encodeURIComponent(String(blockId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTimeLiteServer: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v2/liteserver/get_time`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get transactions
     * @param {string} accountId account ID
     * @param {number} count count
     * @param {number} lt lt
     * @param {string} hash hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransactionsLiteServer: async (
      accountId: string,
      count: number,
      lt: number,
      hash: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('getTransactionsLiteServer', 'accountId', accountId);
      // verify required parameter 'count' is not null or undefined
      assertParamExists('getTransactionsLiteServer', 'count', count);
      // verify required parameter 'lt' is not null or undefined
      assertParamExists('getTransactionsLiteServer', 'lt', lt);
      // verify required parameter 'hash' is not null or undefined
      assertParamExists('getTransactionsLiteServer', 'hash', hash);
      const localVarPath =
        `/v2/liteserver/get_transactions/{account_id}`.replace(
          `{${'account_id'}}`,
          encodeURIComponent(String(accountId)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (count !== undefined) {
        localVarQueryParameter['count'] = count;
      }

      if (lt !== undefined) {
        localVarQueryParameter['lt'] = lt;
      }

      if (hash !== undefined) {
        localVarQueryParameter['hash'] = hash;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Send message
     * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE Data that is expected
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendMessageLiteServer: async (
      uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uNKNOWNBASETYPE' is not null or undefined
      assertParamExists(
        'sendMessageLiteServer',
        'uNKNOWNBASETYPE',
        uNKNOWNBASETYPE,
      );
      const localVarPath = `/v2/liteserver/send_message`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        uNKNOWNBASETYPE,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LiteServerApi - functional programming interface
 * @export
 */
export const LiteServerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    LiteServerApiAxiosParamCreator(configuration);
  return {
    /**
     * Get account state
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAccountStateLiteServer(
      accountId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse20016>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAccountStateLiteServer(
          accountId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get all shards info
     * @param {string} blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllShardsInfoLiteServer(
      blockId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse20018>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAllShardsInfoLiteServer(
          blockId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get block header
     * @param {string} blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @param {number} mode mode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBlockHeaderLiteServer(
      blockId: string,
      mode: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse20014>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getBlockHeaderLiteServer(
          blockId,
          mode,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get block
     * @param {string} blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBlockLiteServer(
      blockId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse20012>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getBlockLiteServer(blockId, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get block proof
     * @param {string} knownBlock known block: (workchain,shard,seqno,root_hash,file_hash)
     * @param {number} mode mode
     * @param {string} [targetBlock] target block: (workchain,shard,seqno,root_hash,file_hash)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBlockProofLiteServer(
      knownBlock: string,
      mode: number,
      targetBlock?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse20021>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getBlockProofLiteServer(
          knownBlock,
          mode,
          targetBlock,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get config all
     * @param {string} blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @param {number} mode mode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getConfigAllLiteServer(
      blockId: string,
      mode: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse20022>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getConfigAllLiteServer(
          blockId,
          mode,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get list block transactions
     * @param {string} blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @param {number} mode mode
     * @param {number} count count
     * @param {string} [accountId] account ID
     * @param {number} [lt] lt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getListBlockTransactionsLiteServer(
      blockId: string,
      mode: number,
      count: number,
      accountId?: string,
      lt?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse20020>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getListBlockTransactionsLiteServer(
          blockId,
          mode,
          count,
          accountId,
          lt,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get masterchain info ext
     * @param {number} mode mode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMasterchainInfoExtLiteServer(
      mode: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse20010>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getMasterchainInfoExtLiteServer(
          mode,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get masterchain info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMasterchainInfoLiteServer(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse2009>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getMasterchainInfoLiteServer(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get shard block proof
     * @param {string} blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getShardBlockProofLiteServer(
      blockId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse20023>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getShardBlockProofLiteServer(
          blockId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get shard info
     * @param {string} blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @param {number} workchain workchain
     * @param {number} shard shard
     * @param {boolean} exact exact
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getShardInfoLiteServer(
      blockId: string,
      workchain: number,
      shard: number,
      exact: boolean,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse20017>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getShardInfoLiteServer(
          blockId,
          workchain,
          shard,
          exact,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get block state
     * @param {string} blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStateLiteServer(
      blockId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse20013>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getStateLiteServer(blockId, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTimeLiteServer(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse20011>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getTimeLiteServer(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get transactions
     * @param {string} accountId account ID
     * @param {number} count count
     * @param {number} lt lt
     * @param {string} hash hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTransactionsLiteServer(
      accountId: string,
      count: number,
      lt: number,
      hash: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse20019>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getTransactionsLiteServer(
          accountId,
          count,
          lt,
          hash,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Send message
     * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE Data that is expected
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sendMessageLiteServer(
      uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse20015>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.sendMessageLiteServer(
          uNKNOWNBASETYPE,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * LiteServerApi - factory interface
 * @export
 */
export const LiteServerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = LiteServerApiFp(configuration);
  return {
    /**
     * Get account state
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccountStateLiteServer(
      accountId: string,
      options?: any,
    ): AxiosPromise<InlineResponse20016> {
      return localVarFp
        .getAccountStateLiteServer(accountId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get all shards info
     * @param {string} blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllShardsInfoLiteServer(
      blockId: string,
      options?: any,
    ): AxiosPromise<InlineResponse20018> {
      return localVarFp
        .getAllShardsInfoLiteServer(blockId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get block header
     * @param {string} blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @param {number} mode mode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBlockHeaderLiteServer(
      blockId: string,
      mode: number,
      options?: any,
    ): AxiosPromise<InlineResponse20014> {
      return localVarFp
        .getBlockHeaderLiteServer(blockId, mode, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get block
     * @param {string} blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBlockLiteServer(
      blockId: string,
      options?: any,
    ): AxiosPromise<InlineResponse20012> {
      return localVarFp
        .getBlockLiteServer(blockId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get block proof
     * @param {string} knownBlock known block: (workchain,shard,seqno,root_hash,file_hash)
     * @param {number} mode mode
     * @param {string} [targetBlock] target block: (workchain,shard,seqno,root_hash,file_hash)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBlockProofLiteServer(
      knownBlock: string,
      mode: number,
      targetBlock?: string,
      options?: any,
    ): AxiosPromise<InlineResponse20021> {
      return localVarFp
        .getBlockProofLiteServer(knownBlock, mode, targetBlock, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get config all
     * @param {string} blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @param {number} mode mode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConfigAllLiteServer(
      blockId: string,
      mode: number,
      options?: any,
    ): AxiosPromise<InlineResponse20022> {
      return localVarFp
        .getConfigAllLiteServer(blockId, mode, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get list block transactions
     * @param {string} blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @param {number} mode mode
     * @param {number} count count
     * @param {string} [accountId] account ID
     * @param {number} [lt] lt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getListBlockTransactionsLiteServer(
      blockId: string,
      mode: number,
      count: number,
      accountId?: string,
      lt?: number,
      options?: any,
    ): AxiosPromise<InlineResponse20020> {
      return localVarFp
        .getListBlockTransactionsLiteServer(
          blockId,
          mode,
          count,
          accountId,
          lt,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get masterchain info ext
     * @param {number} mode mode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMasterchainInfoExtLiteServer(
      mode: number,
      options?: any,
    ): AxiosPromise<InlineResponse20010> {
      return localVarFp
        .getMasterchainInfoExtLiteServer(mode, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get masterchain info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMasterchainInfoLiteServer(
      options?: any,
    ): AxiosPromise<InlineResponse2009> {
      return localVarFp
        .getMasterchainInfoLiteServer(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get shard block proof
     * @param {string} blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getShardBlockProofLiteServer(
      blockId: string,
      options?: any,
    ): AxiosPromise<InlineResponse20023> {
      return localVarFp
        .getShardBlockProofLiteServer(blockId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get shard info
     * @param {string} blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @param {number} workchain workchain
     * @param {number} shard shard
     * @param {boolean} exact exact
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getShardInfoLiteServer(
      blockId: string,
      workchain: number,
      shard: number,
      exact: boolean,
      options?: any,
    ): AxiosPromise<InlineResponse20017> {
      return localVarFp
        .getShardInfoLiteServer(blockId, workchain, shard, exact, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get block state
     * @param {string} blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStateLiteServer(
      blockId: string,
      options?: any,
    ): AxiosPromise<InlineResponse20013> {
      return localVarFp
        .getStateLiteServer(blockId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTimeLiteServer(options?: any): AxiosPromise<InlineResponse20011> {
      return localVarFp
        .getTimeLiteServer(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get transactions
     * @param {string} accountId account ID
     * @param {number} count count
     * @param {number} lt lt
     * @param {string} hash hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransactionsLiteServer(
      accountId: string,
      count: number,
      lt: number,
      hash: string,
      options?: any,
    ): AxiosPromise<InlineResponse20019> {
      return localVarFp
        .getTransactionsLiteServer(accountId, count, lt, hash, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Send message
     * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE Data that is expected
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendMessageLiteServer(
      uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE,
      options?: any,
    ): AxiosPromise<InlineResponse20015> {
      return localVarFp
        .sendMessageLiteServer(uNKNOWNBASETYPE, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * LiteServerApi - object-oriented interface
 * @export
 * @class LiteServerApi
 * @extends {BaseAPI}
 */
export class LiteServerApi extends BaseAPI {
  /**
   * Get account state
   * @param {string} accountId account ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LiteServerApi
   */
  public getAccountStateLiteServer(
    accountId: string,
    options?: AxiosRequestConfig,
  ) {
    return LiteServerApiFp(this.configuration)
      .getAccountStateLiteServer(accountId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get all shards info
   * @param {string} blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LiteServerApi
   */
  public getAllShardsInfoLiteServer(
    blockId: string,
    options?: AxiosRequestConfig,
  ) {
    return LiteServerApiFp(this.configuration)
      .getAllShardsInfoLiteServer(blockId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get block header
   * @param {string} blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
   * @param {number} mode mode
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LiteServerApi
   */
  public getBlockHeaderLiteServer(
    blockId: string,
    mode: number,
    options?: AxiosRequestConfig,
  ) {
    return LiteServerApiFp(this.configuration)
      .getBlockHeaderLiteServer(blockId, mode, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get block
   * @param {string} blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LiteServerApi
   */
  public getBlockLiteServer(blockId: string, options?: AxiosRequestConfig) {
    return LiteServerApiFp(this.configuration)
      .getBlockLiteServer(blockId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get block proof
   * @param {string} knownBlock known block: (workchain,shard,seqno,root_hash,file_hash)
   * @param {number} mode mode
   * @param {string} [targetBlock] target block: (workchain,shard,seqno,root_hash,file_hash)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LiteServerApi
   */
  public getBlockProofLiteServer(
    knownBlock: string,
    mode: number,
    targetBlock?: string,
    options?: AxiosRequestConfig,
  ) {
    return LiteServerApiFp(this.configuration)
      .getBlockProofLiteServer(knownBlock, mode, targetBlock, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get config all
   * @param {string} blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
   * @param {number} mode mode
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LiteServerApi
   */
  public getConfigAllLiteServer(
    blockId: string,
    mode: number,
    options?: AxiosRequestConfig,
  ) {
    return LiteServerApiFp(this.configuration)
      .getConfigAllLiteServer(blockId, mode, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get list block transactions
   * @param {string} blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
   * @param {number} mode mode
   * @param {number} count count
   * @param {string} [accountId] account ID
   * @param {number} [lt] lt
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LiteServerApi
   */
  public getListBlockTransactionsLiteServer(
    blockId: string,
    mode: number,
    count: number,
    accountId?: string,
    lt?: number,
    options?: AxiosRequestConfig,
  ) {
    return LiteServerApiFp(this.configuration)
      .getListBlockTransactionsLiteServer(
        blockId,
        mode,
        count,
        accountId,
        lt,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get masterchain info ext
   * @param {number} mode mode
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LiteServerApi
   */
  public getMasterchainInfoExtLiteServer(
    mode: number,
    options?: AxiosRequestConfig,
  ) {
    return LiteServerApiFp(this.configuration)
      .getMasterchainInfoExtLiteServer(mode, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get masterchain info
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LiteServerApi
   */
  public getMasterchainInfoLiteServer(options?: AxiosRequestConfig) {
    return LiteServerApiFp(this.configuration)
      .getMasterchainInfoLiteServer(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get shard block proof
   * @param {string} blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LiteServerApi
   */
  public getShardBlockProofLiteServer(
    blockId: string,
    options?: AxiosRequestConfig,
  ) {
    return LiteServerApiFp(this.configuration)
      .getShardBlockProofLiteServer(blockId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get shard info
   * @param {string} blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
   * @param {number} workchain workchain
   * @param {number} shard shard
   * @param {boolean} exact exact
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LiteServerApi
   */
  public getShardInfoLiteServer(
    blockId: string,
    workchain: number,
    shard: number,
    exact: boolean,
    options?: AxiosRequestConfig,
  ) {
    return LiteServerApiFp(this.configuration)
      .getShardInfoLiteServer(blockId, workchain, shard, exact, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get block state
   * @param {string} blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LiteServerApi
   */
  public getStateLiteServer(blockId: string, options?: AxiosRequestConfig) {
    return LiteServerApiFp(this.configuration)
      .getStateLiteServer(blockId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get time
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LiteServerApi
   */
  public getTimeLiteServer(options?: AxiosRequestConfig) {
    return LiteServerApiFp(this.configuration)
      .getTimeLiteServer(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get transactions
   * @param {string} accountId account ID
   * @param {number} count count
   * @param {number} lt lt
   * @param {string} hash hash
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LiteServerApi
   */
  public getTransactionsLiteServer(
    accountId: string,
    count: number,
    lt: number,
    hash: string,
    options?: AxiosRequestConfig,
  ) {
    return LiteServerApiFp(this.configuration)
      .getTransactionsLiteServer(accountId, count, lt, hash, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Send message
   * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE Data that is expected
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LiteServerApi
   */
  public sendMessageLiteServer(
    uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE,
    options?: AxiosRequestConfig,
  ) {
    return LiteServerApiFp(this.configuration)
      .sendMessageLiteServer(uNKNOWNBASETYPE, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * NFTApi - axios parameter creator
 * @export
 */
export const NFTApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Get NFT items from collection by collection address
     * @param {string} accountId account ID
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getItemsFromCollection: async (
      accountId: string,
      limit?: number,
      offset?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('getItemsFromCollection', 'accountId', accountId);
      const localVarPath = `/v2/nfts/collections/{account_id}/items`.replace(
        `{${'account_id'}}`,
        encodeURIComponent(String(accountId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get NFT collection by collection address
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNftCollection: async (
      accountId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('getNftCollection', 'accountId', accountId);
      const localVarPath = `/v2/nfts/collections/{account_id}`.replace(
        `{${'account_id'}}`,
        encodeURIComponent(String(accountId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get NFT collections
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNftCollections: async (
      limit?: number,
      offset?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v2/nfts/collections`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get NFT item by its address
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNftItemByAddress: async (
      accountId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('getNftItemByAddress', 'accountId', accountId);
      const localVarPath = `/v2/nfts/{account_id}`.replace(
        `{${'account_id'}}`,
        encodeURIComponent(String(accountId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get NFT items by their addresses
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] a list of account ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNftItemsByAddresses: async (
      uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v2/nfts/_bulk`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        uNKNOWNBASETYPE,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * NFTApi - functional programming interface
 * @export
 */
export const NFTApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = NFTApiAxiosParamCreator(configuration);
  return {
    /**
     * Get NFT items from collection by collection address
     * @param {string} accountId account ID
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getItemsFromCollection(
      accountId: string,
      limit?: number,
      offset?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<NftItems>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getItemsFromCollection(
          accountId,
          limit,
          offset,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get NFT collection by collection address
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getNftCollection(
      accountId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<NftCollection>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getNftCollection(accountId, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get NFT collections
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getNftCollections(
      limit?: number,
      offset?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<NftCollections>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getNftCollections(
          limit,
          offset,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get NFT item by its address
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getNftItemByAddress(
      accountId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<NftItem>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getNftItemByAddress(accountId, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get NFT items by their addresses
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] a list of account ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getNftItemsByAddresses(
      uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<NftItems>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getNftItemsByAddresses(
          uNKNOWNBASETYPE,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * NFTApi - factory interface
 * @export
 */
export const NFTApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = NFTApiFp(configuration);
  return {
    /**
     * Get NFT items from collection by collection address
     * @param {string} accountId account ID
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getItemsFromCollection(
      accountId: string,
      limit?: number,
      offset?: number,
      options?: any,
    ): AxiosPromise<NftItems> {
      return localVarFp
        .getItemsFromCollection(accountId, limit, offset, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get NFT collection by collection address
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNftCollection(
      accountId: string,
      options?: any,
    ): AxiosPromise<NftCollection> {
      return localVarFp
        .getNftCollection(accountId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get NFT collections
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNftCollections(
      limit?: number,
      offset?: number,
      options?: any,
    ): AxiosPromise<NftCollections> {
      return localVarFp
        .getNftCollections(limit, offset, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get NFT item by its address
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNftItemByAddress(
      accountId: string,
      options?: any,
    ): AxiosPromise<NftItem> {
      return localVarFp
        .getNftItemByAddress(accountId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get NFT items by their addresses
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] a list of account ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNftItemsByAddresses(
      uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE,
      options?: any,
    ): AxiosPromise<NftItems> {
      return localVarFp
        .getNftItemsByAddresses(uNKNOWNBASETYPE, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * NFTApi - object-oriented interface
 * @export
 * @class NFTApi
 * @extends {BaseAPI}
 */
export class NFTApi extends BaseAPI {
  /**
   * Get NFT items from collection by collection address
   * @param {string} accountId account ID
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NFTApi
   */
  public getItemsFromCollection(
    accountId: string,
    limit?: number,
    offset?: number,
    options?: AxiosRequestConfig,
  ) {
    return NFTApiFp(this.configuration)
      .getItemsFromCollection(accountId, limit, offset, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get NFT collection by collection address
   * @param {string} accountId account ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NFTApi
   */
  public getNftCollection(accountId: string, options?: AxiosRequestConfig) {
    return NFTApiFp(this.configuration)
      .getNftCollection(accountId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get NFT collections
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NFTApi
   */
  public getNftCollections(
    limit?: number,
    offset?: number,
    options?: AxiosRequestConfig,
  ) {
    return NFTApiFp(this.configuration)
      .getNftCollections(limit, offset, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get NFT item by its address
   * @param {string} accountId account ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NFTApi
   */
  public getNftItemByAddress(accountId: string, options?: AxiosRequestConfig) {
    return NFTApiFp(this.configuration)
      .getNftItemByAddress(accountId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get NFT items by their addresses
   * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] a list of account ids
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NFTApi
   */
  public getNftItemsByAddresses(
    uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE,
    options?: AxiosRequestConfig,
  ) {
    return NFTApiFp(this.configuration)
      .getNftItemsByAddresses(uNKNOWNBASETYPE, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * RatesApi - axios parameter creator
 * @export
 */
export const RatesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Get the token price to the currency
     * @param {string} tokens accept ton and jetton master addresses, separated by commas
     * @param {string} currencies accept ton and all possible fiat currencies, separated by commas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRates: async (
      tokens: string,
      currencies: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'tokens' is not null or undefined
      assertParamExists('getRates', 'tokens', tokens);
      // verify required parameter 'currencies' is not null or undefined
      assertParamExists('getRates', 'currencies', currencies);
      const localVarPath = `/v2/rates`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (tokens !== undefined) {
        localVarQueryParameter['tokens'] = tokens;
      }

      if (currencies !== undefined) {
        localVarQueryParameter['currencies'] = currencies;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RatesApi - functional programming interface
 * @export
 */
export const RatesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = RatesApiAxiosParamCreator(configuration);
  return {
    /**
     * Get the token price to the currency
     * @param {string} tokens accept ton and jetton master addresses, separated by commas
     * @param {string} currencies accept ton and all possible fiat currencies, separated by commas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRates(
      tokens: string,
      currencies: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse2005>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRates(
        tokens,
        currencies,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * RatesApi - factory interface
 * @export
 */
export const RatesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = RatesApiFp(configuration);
  return {
    /**
     * Get the token price to the currency
     * @param {string} tokens accept ton and jetton master addresses, separated by commas
     * @param {string} currencies accept ton and all possible fiat currencies, separated by commas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRates(
      tokens: string,
      currencies: string,
      options?: any,
    ): AxiosPromise<InlineResponse2005> {
      return localVarFp
        .getRates(tokens, currencies, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * RatesApi - object-oriented interface
 * @export
 * @class RatesApi
 * @extends {BaseAPI}
 */
export class RatesApi extends BaseAPI {
  /**
   * Get the token price to the currency
   * @param {string} tokens accept ton and jetton master addresses, separated by commas
   * @param {string} currencies accept ton and all possible fiat currencies, separated by commas
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RatesApi
   */
  public getRates(
    tokens: string,
    currencies: string,
    options?: AxiosRequestConfig,
  ) {
    return RatesApiFp(this.configuration)
      .getRates(tokens, currencies, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * StakingApi - axios parameter creator
 * @export
 */
export const StakingApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * All pools where account participates
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    poolsByNominators: async (
      accountId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('poolsByNominators', 'accountId', accountId);
      const localVarPath = `/v2/staking/nominator/{account_id}/pools`.replace(
        `{${'account_id'}}`,
        encodeURIComponent(String(accountId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Pool info
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingPoolHistory: async (
      accountId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('stakingPoolHistory', 'accountId', accountId);
      const localVarPath = `/v2/staking/pool/{account_id}/history`.replace(
        `{${'account_id'}}`,
        encodeURIComponent(String(accountId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Pool info
     * @param {string} accountId account ID
     * @param {string} [acceptLanguage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingPoolInfo: async (
      accountId: string,
      acceptLanguage?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('stakingPoolInfo', 'accountId', accountId);
      const localVarPath = `/v2/staking/pool/{account_id}`.replace(
        `{${'account_id'}}`,
        encodeURIComponent(String(accountId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * All pools available in network
     * @param {string} [availableFor] account ID
     * @param {boolean} [includeUnverified] return also pools not from white list - just compatible by interfaces (maybe dangerous!)
     * @param {string} [acceptLanguage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingPools: async (
      availableFor?: string,
      includeUnverified?: boolean,
      acceptLanguage?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v2/staking/pools`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (availableFor !== undefined) {
        localVarQueryParameter['available_for'] = availableFor;
      }

      if (includeUnverified !== undefined) {
        localVarQueryParameter['include_unverified'] = includeUnverified;
      }

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * StakingApi - functional programming interface
 * @export
 */
export const StakingApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = StakingApiAxiosParamCreator(configuration);
  return {
    /**
     * All pools where account participates
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async poolsByNominators(
      accountId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountStaking>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.poolsByNominators(accountId, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Pool info
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async stakingPoolHistory(
      accountId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse2002>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.stakingPoolHistory(accountId, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Pool info
     * @param {string} accountId account ID
     * @param {string} [acceptLanguage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async stakingPoolInfo(
      accountId: string,
      acceptLanguage?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse2001>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.stakingPoolInfo(
        accountId,
        acceptLanguage,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * All pools available in network
     * @param {string} [availableFor] account ID
     * @param {boolean} [includeUnverified] return also pools not from white list - just compatible by interfaces (maybe dangerous!)
     * @param {string} [acceptLanguage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async stakingPools(
      availableFor?: string,
      includeUnverified?: boolean,
      acceptLanguage?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse2003>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.stakingPools(
        availableFor,
        includeUnverified,
        acceptLanguage,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * StakingApi - factory interface
 * @export
 */
export const StakingApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = StakingApiFp(configuration);
  return {
    /**
     * All pools where account participates
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    poolsByNominators(
      accountId: string,
      options?: any,
    ): AxiosPromise<AccountStaking> {
      return localVarFp
        .poolsByNominators(accountId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Pool info
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingPoolHistory(
      accountId: string,
      options?: any,
    ): AxiosPromise<InlineResponse2002> {
      return localVarFp
        .stakingPoolHistory(accountId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Pool info
     * @param {string} accountId account ID
     * @param {string} [acceptLanguage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingPoolInfo(
      accountId: string,
      acceptLanguage?: string,
      options?: any,
    ): AxiosPromise<InlineResponse2001> {
      return localVarFp
        .stakingPoolInfo(accountId, acceptLanguage, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * All pools available in network
     * @param {string} [availableFor] account ID
     * @param {boolean} [includeUnverified] return also pools not from white list - just compatible by interfaces (maybe dangerous!)
     * @param {string} [acceptLanguage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stakingPools(
      availableFor?: string,
      includeUnverified?: boolean,
      acceptLanguage?: string,
      options?: any,
    ): AxiosPromise<InlineResponse2003> {
      return localVarFp
        .stakingPools(availableFor, includeUnverified, acceptLanguage, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * StakingApi - object-oriented interface
 * @export
 * @class StakingApi
 * @extends {BaseAPI}
 */
export class StakingApi extends BaseAPI {
  /**
   * All pools where account participates
   * @param {string} accountId account ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StakingApi
   */
  public poolsByNominators(accountId: string, options?: AxiosRequestConfig) {
    return StakingApiFp(this.configuration)
      .poolsByNominators(accountId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Pool info
   * @param {string} accountId account ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StakingApi
   */
  public stakingPoolHistory(accountId: string, options?: AxiosRequestConfig) {
    return StakingApiFp(this.configuration)
      .stakingPoolHistory(accountId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Pool info
   * @param {string} accountId account ID
   * @param {string} [acceptLanguage]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StakingApi
   */
  public stakingPoolInfo(
    accountId: string,
    acceptLanguage?: string,
    options?: AxiosRequestConfig,
  ) {
    return StakingApiFp(this.configuration)
      .stakingPoolInfo(accountId, acceptLanguage, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * All pools available in network
   * @param {string} [availableFor] account ID
   * @param {boolean} [includeUnverified] return also pools not from white list - just compatible by interfaces (maybe dangerous!)
   * @param {string} [acceptLanguage]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StakingApi
   */
  public stakingPools(
    availableFor?: string,
    includeUnverified?: boolean,
    acceptLanguage?: string,
    options?: AxiosRequestConfig,
  ) {
    return StakingApiFp(this.configuration)
      .stakingPools(availableFor, includeUnverified, acceptLanguage, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * StorageApi - axios parameter creator
 * @export
 */
export const StorageApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Get TON storage providers deployed to the blockchain.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStorageProviders: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v2/storage/providers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * StorageApi - functional programming interface
 * @export
 */
export const StorageApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = StorageApiAxiosParamCreator(configuration);
  return {
    /**
     * Get TON storage providers deployed to the blockchain.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStorageProviders(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse2004>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getStorageProviders(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * StorageApi - factory interface
 * @export
 */
export const StorageApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = StorageApiFp(configuration);
  return {
    /**
     * Get TON storage providers deployed to the blockchain.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStorageProviders(options?: any): AxiosPromise<InlineResponse2004> {
      return localVarFp
        .getStorageProviders(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * StorageApi - object-oriented interface
 * @export
 * @class StorageApi
 * @extends {BaseAPI}
 */
export class StorageApi extends BaseAPI {
  /**
   * Get TON storage providers deployed to the blockchain.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StorageApi
   */
  public getStorageProviders(options?: AxiosRequestConfig) {
    return StorageApiFp(this.configuration)
      .getStorageProviders(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TracesApi - axios parameter creator
 * @export
 */
export const TracesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Get the trace by trace ID or hash of any transaction in trace
     * @param {string} traceId trace ID or transaction hash in hex (without 0x) or base64url format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTrace: async (
      traceId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'traceId' is not null or undefined
      assertParamExists('getTrace', 'traceId', traceId);
      const localVarPath = `/v2/traces/{trace_id}`.replace(
        `{${'trace_id'}}`,
        encodeURIComponent(String(traceId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TracesApi - functional programming interface
 * @export
 */
export const TracesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TracesApiAxiosParamCreator(configuration);
  return {
    /**
     * Get the trace by trace ID or hash of any transaction in trace
     * @param {string} traceId trace ID or transaction hash in hex (without 0x) or base64url format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTrace(
      traceId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Trace>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTrace(
        traceId,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * TracesApi - factory interface
 * @export
 */
export const TracesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = TracesApiFp(configuration);
  return {
    /**
     * Get the trace by trace ID or hash of any transaction in trace
     * @param {string} traceId trace ID or transaction hash in hex (without 0x) or base64url format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTrace(traceId: string, options?: any): AxiosPromise<Trace> {
      return localVarFp
        .getTrace(traceId, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * TracesApi - object-oriented interface
 * @export
 * @class TracesApi
 * @extends {BaseAPI}
 */
export class TracesApi extends BaseAPI {
  /**
   * Get the trace by trace ID or hash of any transaction in trace
   * @param {string} traceId trace ID or transaction hash in hex (without 0x) or base64url format
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TracesApi
   */
  public getTrace(traceId: string, options?: AxiosRequestConfig) {
    return TracesApiFp(this.configuration)
      .getTrace(traceId, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * WalletApi - axios parameter creator
 * @export
 */
export const WalletApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Get backup info
     * @param {string} xTonConnectAuth
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWalletBackup: async (
      xTonConnectAuth: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTonConnectAuth' is not null or undefined
      assertParamExists('getWalletBackup', 'xTonConnectAuth', xTonConnectAuth);
      const localVarPath = `/v2/wallet/backup`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xTonConnectAuth !== undefined && xTonConnectAuth !== null) {
        localVarHeaderParameter['X-TonConnect-Auth'] = String(xTonConnectAuth);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Set backup info
     * @param {string} xTonConnectAuth
     * @param {any} body Information for saving backup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setWalletBackup: async (
      xTonConnectAuth: string,
      body: any,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'xTonConnectAuth' is not null or undefined
      assertParamExists('setWalletBackup', 'xTonConnectAuth', xTonConnectAuth);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('setWalletBackup', 'body', body);
      const localVarPath = `/v2/wallet/backup`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xTonConnectAuth !== undefined && xTonConnectAuth !== null) {
        localVarHeaderParameter['X-TonConnect-Auth'] = String(xTonConnectAuth);
      }

      localVarHeaderParameter['Content-Type'] = 'application/octet-stream';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Account verification and token issuance
     * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE Data that is expected from TON Connect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tonConnectProof: async (
      uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uNKNOWNBASETYPE' is not null or undefined
      assertParamExists('tonConnectProof', 'uNKNOWNBASETYPE', uNKNOWNBASETYPE);
      const localVarPath = `/v2/wallet/auth/proof`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        uNKNOWNBASETYPE,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * WalletApi - functional programming interface
 * @export
 */
export const WalletApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = WalletApiAxiosParamCreator(configuration);
  return {
    /**
     * Get backup info
     * @param {string} xTonConnectAuth
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getWalletBackup(
      xTonConnectAuth: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse2007>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getWalletBackup(
        xTonConnectAuth,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Set backup info
     * @param {string} xTonConnectAuth
     * @param {any} body Information for saving backup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setWalletBackup(
      xTonConnectAuth: string,
      body: any,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setWalletBackup(
        xTonConnectAuth,
        body,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Account verification and token issuance
     * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE Data that is expected from TON Connect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tonConnectProof(
      uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse2008>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.tonConnectProof(
        uNKNOWNBASETYPE,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * WalletApi - factory interface
 * @export
 */
export const WalletApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = WalletApiFp(configuration);
  return {
    /**
     * Get backup info
     * @param {string} xTonConnectAuth
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWalletBackup(
      xTonConnectAuth: string,
      options?: any,
    ): AxiosPromise<InlineResponse2007> {
      return localVarFp
        .getWalletBackup(xTonConnectAuth, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Set backup info
     * @param {string} xTonConnectAuth
     * @param {any} body Information for saving backup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setWalletBackup(
      xTonConnectAuth: string,
      body: any,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .setWalletBackup(xTonConnectAuth, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Account verification and token issuance
     * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE Data that is expected from TON Connect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tonConnectProof(
      uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE,
      options?: any,
    ): AxiosPromise<InlineResponse2008> {
      return localVarFp
        .tonConnectProof(uNKNOWNBASETYPE, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * WalletApi - object-oriented interface
 * @export
 * @class WalletApi
 * @extends {BaseAPI}
 */
export class WalletApi extends BaseAPI {
  /**
   * Get backup info
   * @param {string} xTonConnectAuth
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public getWalletBackup(
    xTonConnectAuth: string,
    options?: AxiosRequestConfig,
  ) {
    return WalletApiFp(this.configuration)
      .getWalletBackup(xTonConnectAuth, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Set backup info
   * @param {string} xTonConnectAuth
   * @param {any} body Information for saving backup
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public setWalletBackup(
    xTonConnectAuth: string,
    body: any,
    options?: AxiosRequestConfig,
  ) {
    return WalletApiFp(this.configuration)
      .setWalletBackup(xTonConnectAuth, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Account verification and token issuance
   * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE Data that is expected from TON Connect
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public tonConnectProof(
    uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE,
    options?: AxiosRequestConfig,
  ) {
    return WalletApiFp(this.configuration)
      .tonConnectProof(uNKNOWNBASETYPE, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * WalletsApi - axios parameter creator
 * @export
 */
export const WalletsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Get account seqno
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccountSeqno: async (
      accountId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('getAccountSeqno', 'accountId', accountId);
      const localVarPath = `/v2/wallet/{account_id}/seqno`.replace(
        `{${'account_id'}}`,
        encodeURIComponent(String(accountId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get wallets by public key
     * @param {string} publicKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWalletsByPublicKey: async (
      publicKey: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'publicKey' is not null or undefined
      assertParamExists('getWalletsByPublicKey', 'publicKey', publicKey);
      const localVarPath = `/v2/pubkeys/{public_key}/wallets`.replace(
        `{${'public_key'}}`,
        encodeURIComponent(String(publicKey)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * WalletsApi - functional programming interface
 * @export
 */
export const WalletsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = WalletsApiAxiosParamCreator(configuration);
  return {
    /**
     * Get account seqno
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAccountSeqno(
      accountId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Seqno>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountSeqno(
        accountId,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get wallets by public key
     * @param {string} publicKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getWalletsByPublicKey(
      publicKey: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Accounts>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getWalletsByPublicKey(
          publicKey,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * WalletsApi - factory interface
 * @export
 */
export const WalletsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = WalletsApiFp(configuration);
  return {
    /**
     * Get account seqno
     * @param {string} accountId account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccountSeqno(accountId: string, options?: any): AxiosPromise<Seqno> {
      return localVarFp
        .getAccountSeqno(accountId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get wallets by public key
     * @param {string} publicKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWalletsByPublicKey(
      publicKey: string,
      options?: any,
    ): AxiosPromise<Accounts> {
      return localVarFp
        .getWalletsByPublicKey(publicKey, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * WalletsApi - object-oriented interface
 * @export
 * @class WalletsApi
 * @extends {BaseAPI}
 */
export class WalletsApi extends BaseAPI {
  /**
   * Get account seqno
   * @param {string} accountId account ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletsApi
   */
  public getAccountSeqno(accountId: string, options?: AxiosRequestConfig) {
    return WalletsApiFp(this.configuration)
      .getAccountSeqno(accountId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get wallets by public key
   * @param {string} publicKey
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletsApi
   */
  public getWalletsByPublicKey(
    publicKey: string,
    options?: AxiosRequestConfig,
  ) {
    return WalletsApiFp(this.configuration)
      .getWalletsByPublicKey(publicKey, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
