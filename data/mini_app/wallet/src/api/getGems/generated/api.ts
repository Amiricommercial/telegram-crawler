/* tslint:disable */

/* eslint-disable */

/**
 * GetGems
 * GetGems API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@getgems.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import globalAxios, {
  AxiosInstance,
  AxiosPromise,
  AxiosRequestConfig,
} from 'axios';

// @ts-ignore
import {
  BASE_PATH,
  BaseAPI,
  COLLECTION_FORMATS,
  RequestArgs,
  RequiredError,
} from './base';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  createRequestFunction,
  serializeDataIfNeeded,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  toPathString,
} from './common';
import { Configuration } from './configuration';

/**
 *
 * @export
 * @enum {string}
 */

export const ActionDisplayTo = {
  All: 'All',
  Owner: 'Owner',
} as const;

export type ActionDisplayTo =
  typeof ActionDisplayTo[keyof typeof ActionDisplayTo];

/**
 * @type ActionElement
 * @export
 */
export type ActionElement =
  | LinkAction
  | PlayGameAction
  | SendAction
  | ToFragmentAction
  | ToTonDnsAction;

/**
 *
 * @export
 * @interface BaseAction
 */
export interface BaseAction {
  /**
   *
   * @type {ActionDisplayTo}
   * @memberof BaseAction
   */
  displayTo: ActionDisplayTo;
}
/**
 *
 * @export
 * @interface Collectible
 */
export interface Collectible {
  /**
   *
   * @type {string}
   * @memberof Collectible
   */
  address: string;
  /**
   *
   * @type {CollectionPreview}
   * @memberof Collectible
   */
  collectionPreview?: CollectionPreview;
  /**
   *
   * @type {Media}
   * @memberof Collectible
   */
  content?: Media;
  /**
   *
   * @type {string}
   * @memberof Collectible
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof Collectible
   */
  url: string;
  /**
   *
   * @type {string}
   * @memberof Collectible
   */
  index: string;
  /**
   *
   * @type {MetadataSourceType}
   * @memberof Collectible
   */
  metadataSourceType: MetadataSourceType;
  /**
   *
   * @type {string}
   * @memberof Collectible
   */
  description?: string;
  /**
   *
   * @type {Array<ActionElement>}
   * @memberof Collectible
   */
  actions?: Array<ActionElement>;
  /**
   *
   * @type {CollectibleOwner}
   * @memberof Collectible
   */
  owner?: CollectibleOwner;
  /**
   *
   * @type {string}
   * @memberof Collectible
   */
  bagde?: CollectibleBagdeEnum;
  /**
   *
   * @type {Array<CollectibleAttribute>}
   * @memberof Collectible
   */
  attributes?: Array<CollectibleAttribute>;
}

export const CollectibleBagdeEnum = {
  OnSale: 'OnSale',
} as const;

export type CollectibleBagdeEnum =
  typeof CollectibleBagdeEnum[keyof typeof CollectibleBagdeEnum];

/**
 *
 * @export
 * @interface CollectibleAttribute
 */
export interface CollectibleAttribute {
  /**
   *
   * @type {string}
   * @memberof CollectibleAttribute
   */
  traitType: string;
  /**
   *
   * @type {string}
   * @memberof CollectibleAttribute
   */
  value: string;
}
/**
 *
 * @export
 * @interface CollectibleOwner
 */
export interface CollectibleOwner {
  /**
   *
   * @type {string}
   * @memberof CollectibleOwner
   */
  address: string;
  /**
   *
   * @type {string}
   * @memberof CollectibleOwner
   */
  avatar?: string;
  /**
   *
   * @type {string}
   * @memberof CollectibleOwner
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof CollectibleOwner
   */
  url: string;
}
/**
 *
 * @export
 * @interface CollectiblePreview
 */
export interface CollectiblePreview {
  /**
   *
   * @type {string}
   * @memberof CollectiblePreview
   */
  address: string;
  /**
   *
   * @type {Media}
   * @memberof CollectiblePreview
   */
  content?: Media;
}
/**
 *
 * @export
 * @interface CollectiblePreviewWithCursor
 */
export interface CollectiblePreviewWithCursor {
  /**
   *
   * @type {string}
   * @memberof CollectiblePreviewWithCursor
   */
  cursor?: string;
  /**
   *
   * @type {Array<CollectiblePreview>}
   * @memberof CollectiblePreviewWithCursor
   */
  items: Array<CollectiblePreview>;
}
/**
 *
 * @export
 * @interface CollectiblePreviewsByCollectionResponse
 */
export interface CollectiblePreviewsByCollectionResponse {
  /**
   *
   * @type {Array<CollectiblePreview>}
   * @memberof CollectiblePreviewsByCollectionResponse
   */
  collectibles: Array<CollectiblePreview>;
  /**
   *
   * @type {number}
   * @memberof CollectiblePreviewsByCollectionResponse
   */
  collectibleCount: number;
  /**
   *
   * @type {string}
   * @memberof CollectiblePreviewsByCollectionResponse
   */
  cursor?: string;
}
/**
 *
 * @export
 * @interface CollectiblePreviewsNewestResponse
 */
export interface CollectiblePreviewsNewestResponse {
  /**
   *
   * @type {Array<CollectiblePreview>}
   * @memberof CollectiblePreviewsNewestResponse
   */
  collectibles: Array<CollectiblePreview>;
}
/**
 *
 * @export
 * @interface CollectibleResponse
 */
export interface CollectibleResponse {
  /**
   *
   * @type {Collectible}
   * @memberof CollectibleResponse
   */
  collectible?: Collectible;
}
/**
 *
 * @export
 * @interface CollectiblesGrouped
 */
export interface CollectiblesGrouped {
  /**
   *
   * @type {CollectionPreview}
   * @memberof CollectiblesGrouped
   */
  collectionPreview: CollectionPreview;
  /**
   *
   * @type {number}
   * @memberof CollectiblesGrouped
   */
  collectibleCount: number;
  /**
   *
   * @type {CollectiblePreviewWithCursor}
   * @memberof CollectiblesGrouped
   */
  collectiblePreviews: CollectiblePreviewWithCursor;
}
/**
 *
 * @export
 * @interface CollectiblesGroupedResponse
 */
export interface CollectiblesGroupedResponse {
  /**
   *
   * @type {Array<CollectiblesGrouped>}
   * @memberof CollectiblesGroupedResponse
   */
  items: Array<CollectiblesGrouped>;
  /**
   *
   * @type {number}
   * @memberof CollectiblesGroupedResponse
   */
  collectibleCount?: number;
  /**
   *
   * @type {string}
   * @memberof CollectiblesGroupedResponse
   */
  cursor?: string;
}
/**
 *
 * @export
 * @interface CollectionPreview
 */
export interface CollectionPreview {
  /**
   *
   * @type {string}
   * @memberof CollectionPreview
   */
  address: string;
  /**
   *
   * @type {string}
   * @memberof CollectionPreview
   */
  name?: string;
  /**
   *
   * @type {Media}
   * @memberof CollectionPreview
   */
  content?: Media;
  /**
   *
   * @type {string}
   * @memberof CollectionPreview
   */
  url?: string;
}
/**
 *
 * @export
 * @interface DefaultErrorObject
 */
export interface DefaultErrorObject {
  /**
   *
   * @type {string}
   * @memberof DefaultErrorObject
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof DefaultErrorObject
   */
  status: number;
  /**
   *
   * @type {Array<DefaultErrorObjectErrors>}
   * @memberof DefaultErrorObject
   */
  errors: Array<DefaultErrorObjectErrors>;
}
/**
 *
 * @export
 * @interface DefaultErrorObjectErrors
 */
export interface DefaultErrorObjectErrors {
  /**
   *
   * @type {string}
   * @memberof DefaultErrorObjectErrors
   */
  path?: string;
  /**
   *
   * @type {string}
   * @memberof DefaultErrorObjectErrors
   */
  message: string;
}
/**
 *
 * @export
 * @interface Image
 */
export interface Image {
  /**
   *
   * @type {string}
   * @memberof Image
   */
  typename: ImageTypenameEnum;
  /**
   *
   * @type {string}
   * @memberof Image
   */
  image: string;
}

export const ImageTypenameEnum = {
  Image: 'Image',
} as const;

export type ImageTypenameEnum =
  typeof ImageTypenameEnum[keyof typeof ImageTypenameEnum];

/**
 *
 * @export
 * @interface LinkAction
 */
export interface LinkAction {
  /**
   *
   * @type {ActionDisplayTo}
   * @memberof LinkAction
   */
  displayTo: ActionDisplayTo;
  /**
   *
   * @type {string}
   * @memberof LinkAction
   */
  typename: LinkActionTypenameEnum;
  /**
   *
   * @type {string}
   * @memberof LinkAction
   */
  text: string;
  /**
   *
   * @type {string}
   * @memberof LinkAction
   */
  url: string;
}

export const LinkActionTypenameEnum = {
  LinkAction: 'LinkAction',
} as const;

export type LinkActionTypenameEnum =
  typeof LinkActionTypenameEnum[keyof typeof LinkActionTypenameEnum];

/**
 *
 * @export
 * @interface LinkActionAllOf
 */
export interface LinkActionAllOf {
  /**
   *
   * @type {string}
   * @memberof LinkActionAllOf
   */
  typename: LinkActionAllOfTypenameEnum;
  /**
   *
   * @type {string}
   * @memberof LinkActionAllOf
   */
  text: string;
  /**
   *
   * @type {string}
   * @memberof LinkActionAllOf
   */
  url: string;
}

export const LinkActionAllOfTypenameEnum = {
  LinkAction: 'LinkAction',
} as const;

export type LinkActionAllOfTypenameEnum =
  typeof LinkActionAllOfTypenameEnum[keyof typeof LinkActionAllOfTypenameEnum];

/**
 *
 * @export
 * @interface Lottie
 */
export interface Lottie {
  /**
   *
   * @type {string}
   * @memberof Lottie
   */
  typename: LottieTypenameEnum;
  /**
   *
   * @type {string}
   * @memberof Lottie
   */
  preview: string;
  /**
   *
   * @type {string}
   * @memberof Lottie
   */
  lottie: string;
}

export const LottieTypenameEnum = {
  Lottie: 'Lottie',
} as const;

export type LottieTypenameEnum =
  typeof LottieTypenameEnum[keyof typeof LottieTypenameEnum];

/**
 * @type Media
 * @export
 */
export type Media = Image | Lottie | Video;

/**
 *
 * @export
 * @enum {string}
 */

export const MetadataSourceType = {
  Centralized: 'Centralized',
  Decentralized: 'Decentralized',
  GetGems: 'GetGems',
  Ipfs: 'Ipfs',
  OnChain: 'OnChain',
  TonStorage: 'TonStorage',
} as const;

export type MetadataSourceType =
  typeof MetadataSourceType[keyof typeof MetadataSourceType];

/**
 *
 * @export
 * @interface PlayGameAction
 */
export interface PlayGameAction {
  /**
   *
   * @type {ActionDisplayTo}
   * @memberof PlayGameAction
   */
  displayTo: ActionDisplayTo;
  /**
   *
   * @type {string}
   * @memberof PlayGameAction
   */
  typename: PlayGameActionTypenameEnum;
  /**
   *
   * @type {string}
   * @memberof PlayGameAction
   */
  url: string;
}

export const PlayGameActionTypenameEnum = {
  PlayGameAction: 'PlayGameAction',
} as const;

export type PlayGameActionTypenameEnum =
  typeof PlayGameActionTypenameEnum[keyof typeof PlayGameActionTypenameEnum];

/**
 *
 * @export
 * @interface PlayGameActionAllOf
 */
export interface PlayGameActionAllOf {
  /**
   *
   * @type {string}
   * @memberof PlayGameActionAllOf
   */
  typename: PlayGameActionAllOfTypenameEnum;
  /**
   *
   * @type {string}
   * @memberof PlayGameActionAllOf
   */
  url: string;
}

export const PlayGameActionAllOfTypenameEnum = {
  PlayGameAction: 'PlayGameAction',
} as const;

export type PlayGameActionAllOfTypenameEnum =
  typeof PlayGameActionAllOfTypenameEnum[keyof typeof PlayGameActionAllOfTypenameEnum];

/**
 *
 * @export
 * @interface SendAction
 */
export interface SendAction {
  /**
   *
   * @type {ActionDisplayTo}
   * @memberof SendAction
   */
  displayTo: ActionDisplayTo;
  /**
   *
   * @type {string}
   * @memberof SendAction
   */
  typename: SendActionTypenameEnum;
  /**
   *
   * @type {string}
   * @memberof SendAction
   */
  rejectReason?: SendActionRejectReasonEnum;
}

export const SendActionTypenameEnum = {
  SendAction: 'SendAction',
} as const;

export type SendActionTypenameEnum =
  typeof SendActionTypenameEnum[keyof typeof SendActionTypenameEnum];
export const SendActionRejectReasonEnum = {
  OnSale: 'OnSale',
} as const;

export type SendActionRejectReasonEnum =
  typeof SendActionRejectReasonEnum[keyof typeof SendActionRejectReasonEnum];

/**
 *
 * @export
 * @interface SendActionAllOf
 */
export interface SendActionAllOf {
  /**
   *
   * @type {string}
   * @memberof SendActionAllOf
   */
  typename: SendActionAllOfTypenameEnum;
  /**
   *
   * @type {string}
   * @memberof SendActionAllOf
   */
  rejectReason?: SendActionAllOfRejectReasonEnum;
}

export const SendActionAllOfTypenameEnum = {
  SendAction: 'SendAction',
} as const;

export type SendActionAllOfTypenameEnum =
  typeof SendActionAllOfTypenameEnum[keyof typeof SendActionAllOfTypenameEnum];
export const SendActionAllOfRejectReasonEnum = {
  OnSale: 'OnSale',
} as const;

export type SendActionAllOfRejectReasonEnum =
  typeof SendActionAllOfRejectReasonEnum[keyof typeof SendActionAllOfRejectReasonEnum];

/**
 *
 * @export
 * @interface SuggestedAddress
 */
export interface SuggestedAddress {
  /**
   *
   * @type {string}
   * @memberof SuggestedAddress
   */
  address: string;
  /**
   *
   * @type {string}
   * @memberof SuggestedAddress
   */
  date: string;
}
/**
 *
 * @export
 * @interface ToFragmentAction
 */
export interface ToFragmentAction {
  /**
   *
   * @type {ActionDisplayTo}
   * @memberof ToFragmentAction
   */
  displayTo: ActionDisplayTo;
  /**
   *
   * @type {string}
   * @memberof ToFragmentAction
   */
  typename: ToFragmentActionTypenameEnum;
  /**
   *
   * @type {string}
   * @memberof ToFragmentAction
   */
  url: string;
}

export const ToFragmentActionTypenameEnum = {
  ToFragmentAction: 'ToFragmentAction',
} as const;

export type ToFragmentActionTypenameEnum =
  typeof ToFragmentActionTypenameEnum[keyof typeof ToFragmentActionTypenameEnum];

/**
 *
 * @export
 * @interface ToFragmentActionAllOf
 */
export interface ToFragmentActionAllOf {
  /**
   *
   * @type {string}
   * @memberof ToFragmentActionAllOf
   */
  typename: ToFragmentActionAllOfTypenameEnum;
  /**
   *
   * @type {string}
   * @memberof ToFragmentActionAllOf
   */
  url: string;
}

export const ToFragmentActionAllOfTypenameEnum = {
  ToFragmentAction: 'ToFragmentAction',
} as const;

export type ToFragmentActionAllOfTypenameEnum =
  typeof ToFragmentActionAllOfTypenameEnum[keyof typeof ToFragmentActionAllOfTypenameEnum];

/**
 *
 * @export
 * @interface ToTonDnsAction
 */
export interface ToTonDnsAction {
  /**
   *
   * @type {ActionDisplayTo}
   * @memberof ToTonDnsAction
   */
  displayTo: ActionDisplayTo;
  /**
   *
   * @type {string}
   * @memberof ToTonDnsAction
   */
  typename: ToTonDnsActionTypenameEnum;
  /**
   *
   * @type {string}
   * @memberof ToTonDnsAction
   */
  url: string;
}

export const ToTonDnsActionTypenameEnum = {
  ToTonDnsAction: 'ToTonDnsAction',
} as const;

export type ToTonDnsActionTypenameEnum =
  typeof ToTonDnsActionTypenameEnum[keyof typeof ToTonDnsActionTypenameEnum];

/**
 *
 * @export
 * @interface ToTonDnsActionAllOf
 */
export interface ToTonDnsActionAllOf {
  /**
   *
   * @type {string}
   * @memberof ToTonDnsActionAllOf
   */
  typename: ToTonDnsActionAllOfTypenameEnum;
  /**
   *
   * @type {string}
   * @memberof ToTonDnsActionAllOf
   */
  url: string;
}

export const ToTonDnsActionAllOfTypenameEnum = {
  ToTonDnsAction: 'ToTonDnsAction',
} as const;

export type ToTonDnsActionAllOfTypenameEnum =
  typeof ToTonDnsActionAllOfTypenameEnum[keyof typeof ToTonDnsActionAllOfTypenameEnum];

/**
 *
 * @export
 * @interface TonTx
 */
export interface TonTx {
  /**
   *
   * @type {string}
   * @memberof TonTx
   */
  source?: string;
  /**
   *
   * @type {number}
   * @memberof TonTx
   */
  validUntil: number;
  /**
   *
   * @type {Array<TonTxItem>}
   * @memberof TonTx
   */
  messages: Array<TonTxItem>;
}
/**
 *
 * @export
 * @interface TonTxItem
 */
export interface TonTxItem {
  /**
   *
   * @type {string}
   * @memberof TonTxItem
   */
  address: string;
  /**
   *
   * @type {string}
   * @memberof TonTxItem
   */
  amount: string;
  /**
   *
   * @type {string}
   * @memberof TonTxItem
   */
  payload?: string;
  /**
   *
   * @type {string}
   * @memberof TonTxItem
   */
  stateInit?: string;
}
/**
 *
 * @export
 * @interface TransferCollectibleResponse
 */
export interface TransferCollectibleResponse {
  /**
   *
   * @type {TonTx}
   * @memberof TransferCollectibleResponse
   */
  tx: TonTx;
  /**
   *
   * @type {number}
   * @memberof TransferCollectibleResponse
   */
  balanceBefore: number;
  /**
   *
   * @type {number}
   * @memberof TransferCollectibleResponse
   */
  balanceAfter: number;
  /**
   *
   * @type {number}
   * @memberof TransferCollectibleResponse
   */
  fee: number;
  /**
   *
   * @type {Collectible}
   * @memberof TransferCollectibleResponse
   */
  collectibleAfter: Collectible;
}
/**
 *
 * @export
 * @interface UserPreview
 */
export interface UserPreview {
  /**
   *
   * @type {string}
   * @memberof UserPreview
   */
  address: string;
  /**
   *
   * @type {string}
   * @memberof UserPreview
   */
  avatar?: string;
  /**
   *
   * @type {string}
   * @memberof UserPreview
   */
  name?: string;
}
/**
 *
 * @export
 * @interface ValidateAddressResponse
 */
export interface ValidateAddressResponse {
  /**
   *
   * @type {boolean}
   * @memberof ValidateAddressResponse
   */
  valid: boolean;
  /**
   *
   * @type {string}
   * @memberof ValidateAddressResponse
   */
  errorCode?: ValidateAddressResponseErrorCodeEnum;
  /**
   *
   * @type {string}
   * @memberof ValidateAddressResponse
   */
  resolvedAddress?: string;
}

export const ValidateAddressResponseErrorCodeEnum = {
  InvalidDomain: 'invalid_domain',
  InvalidNumberOfCharacters: 'invalid_number_of_characters',
  WithdrawToYourselfIsForbidden: 'withdraw_to_yourself_is_forbidden',
  AddressForbidden: 'address_forbidden',
} as const;

export type ValidateAddressResponseErrorCodeEnum =
  typeof ValidateAddressResponseErrorCodeEnum[keyof typeof ValidateAddressResponseErrorCodeEnum];

/**
 *
 * @export
 * @interface Video
 */
export interface Video {
  /**
   *
   * @type {string}
   * @memberof Video
   */
  typename: VideoTypenameEnum;
  /**
   *
   * @type {string}
   * @memberof Video
   */
  preview: string;
  /**
   *
   * @type {string}
   * @memberof Video
   */
  video: string;
}

export const VideoTypenameEnum = {
  Video: 'Video',
} as const;

export type VideoTypenameEnum =
  typeof VideoTypenameEnum[keyof typeof VideoTypenameEnum];

/**
 * CollectiblesApi - axios parameter creator
 * @export
 */
export const CollectiblesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Returns collectible by address
     * @param {string} address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    collectible: async (
      address: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'address' is not null or undefined
      assertParamExists('collectible', 'address', address);
      const localVarPath = `/collectible/{address}`.replace(
        `{${'address'}}`,
        encodeURIComponent(String(address)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns user`s collectible previews by collection
     * @param {string} userAddress
     * @param {string} [collectionAddress]
     * @param {number} [count]
     * @param {string} [cursor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    collectiblePreviewsByCollection: async (
      userAddress: string,
      collectionAddress?: string,
      count?: number,
      cursor?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userAddress' is not null or undefined
      assertParamExists(
        'collectiblePreviewsByCollection',
        'userAddress',
        userAddress,
      );
      const localVarPath =
        `/collectiblePreviewsByCollection/{userAddress}`.replace(
          `{${'userAddress'}}`,
          encodeURIComponent(String(userAddress)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (collectionAddress !== undefined) {
        localVarQueryParameter['collectionAddress'] = collectionAddress;
      }

      if (count !== undefined) {
        localVarQueryParameter['count'] = count;
      }

      if (cursor !== undefined) {
        localVarQueryParameter['cursor'] = cursor;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns newest user`s collectible previews (3 by default)
     * @param {string} userAddress
     * @param {number} [count]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    collectiblePreviewsNewest: async (
      userAddress: string,
      count?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userAddress' is not null or undefined
      assertParamExists(
        'collectiblePreviewsNewest',
        'userAddress',
        userAddress,
      );
      const localVarPath = `/collectiblePreviewsNewest/{userAddress}`.replace(
        `{${'userAddress'}}`,
        encodeURIComponent(String(userAddress)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (count !== undefined) {
        localVarQueryParameter['count'] = count;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns user`s collectibles grouped by collection
     * @param {string} address
     * @param {number} countColTotal
     * @param {number} countRowPerCollection
     * @param {number} countRowTotal
     * @param {string} [cursor]
     * @param {Array<string>} [skipCollections]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    collectiblesGrouped: async (
      address: string,
      countColTotal: number,
      countRowPerCollection: number,
      countRowTotal: number,
      cursor?: string,
      skipCollections?: Array<string>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'address' is not null or undefined
      assertParamExists('collectiblesGrouped', 'address', address);
      // verify required parameter 'countColTotal' is not null or undefined
      assertParamExists('collectiblesGrouped', 'countColTotal', countColTotal);
      // verify required parameter 'countRowPerCollection' is not null or undefined
      assertParamExists(
        'collectiblesGrouped',
        'countRowPerCollection',
        countRowPerCollection,
      );
      // verify required parameter 'countRowTotal' is not null or undefined
      assertParamExists('collectiblesGrouped', 'countRowTotal', countRowTotal);
      const localVarPath = `/collectiblesGrouped/{address}`.replace(
        `{${'address'}}`,
        encodeURIComponent(String(address)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (countColTotal !== undefined) {
        localVarQueryParameter['countColTotal'] = countColTotal;
      }

      if (countRowPerCollection !== undefined) {
        localVarQueryParameter['countRowPerCollection'] = countRowPerCollection;
      }

      if (countRowTotal !== undefined) {
        localVarQueryParameter['countRowTotal'] = countRowTotal;
      }

      if (cursor !== undefined) {
        localVarQueryParameter['cursor'] = cursor;
      }

      if (skipCollections) {
        localVarQueryParameter['skipCollections'] = skipCollections;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns addresses from previews nft transfers
     * @param {string} userAddress
     * @param {number} [count]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suggestNftTransferAddress: async (
      userAddress: string,
      count?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userAddress' is not null or undefined
      assertParamExists(
        'suggestNftTransferAddress',
        'userAddress',
        userAddress,
      );
      const localVarPath = `/suggestNftTransferAddress/{userAddress}`.replace(
        `{${'userAddress'}}`,
        encodeURIComponent(String(userAddress)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (count !== undefined) {
        localVarQueryParameter['count'] = count;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates unsigned TX transfering collectible to new owner
     * @param {string} collectibleAddress
     * @param {string} newOwnerAddress
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transferCollectible: async (
      collectibleAddress: string,
      newOwnerAddress: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'collectibleAddress' is not null or undefined
      assertParamExists(
        'transferCollectible',
        'collectibleAddress',
        collectibleAddress,
      );
      // verify required parameter 'newOwnerAddress' is not null or undefined
      assertParamExists(
        'transferCollectible',
        'newOwnerAddress',
        newOwnerAddress,
      );
      const localVarPath =
        `/collectible/transfer/{collectibleAddress}/{newOwnerAddress}`
          .replace(
            `{${'collectibleAddress'}}`,
            encodeURIComponent(String(collectibleAddress)),
          )
          .replace(
            `{${'newOwnerAddress'}}`,
            encodeURIComponent(String(newOwnerAddress)),
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Validate address
     * @param {string} address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateAddress: async (
      address: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'address' is not null or undefined
      assertParamExists('validateAddress', 'address', address);
      const localVarPath = `/validateAddress/{address}`.replace(
        `{${'address'}}`,
        encodeURIComponent(String(address)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CollectiblesApi - functional programming interface
 * @export
 */
export const CollectiblesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    CollectiblesApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns collectible by address
     * @param {string} address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async collectible(
      address: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<CollectibleResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.collectible(
        address,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns user`s collectible previews by collection
     * @param {string} userAddress
     * @param {string} [collectionAddress]
     * @param {number} [count]
     * @param {string} [cursor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async collectiblePreviewsByCollection(
      userAddress: string,
      collectionAddress?: string,
      count?: number,
      cursor?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<CollectiblePreviewsByCollectionResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.collectiblePreviewsByCollection(
          userAddress,
          collectionAddress,
          count,
          cursor,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns newest user`s collectible previews (3 by default)
     * @param {string} userAddress
     * @param {number} [count]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async collectiblePreviewsNewest(
      userAddress: string,
      count?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<CollectiblePreviewsNewestResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.collectiblePreviewsNewest(
          userAddress,
          count,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns user`s collectibles grouped by collection
     * @param {string} address
     * @param {number} countColTotal
     * @param {number} countRowPerCollection
     * @param {number} countRowTotal
     * @param {string} [cursor]
     * @param {Array<string>} [skipCollections]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async collectiblesGrouped(
      address: string,
      countColTotal: number,
      countRowPerCollection: number,
      countRowTotal: number,
      cursor?: string,
      skipCollections?: Array<string>,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<CollectiblesGroupedResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.collectiblesGrouped(
          address,
          countColTotal,
          countRowPerCollection,
          countRowTotal,
          cursor,
          skipCollections,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns addresses from previews nft transfers
     * @param {string} userAddress
     * @param {number} [count]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async suggestNftTransferAddress(
      userAddress: string,
      count?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<SuggestedAddress>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.suggestNftTransferAddress(
          userAddress,
          count,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Creates unsigned TX transfering collectible to new owner
     * @param {string} collectibleAddress
     * @param {string} newOwnerAddress
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async transferCollectible(
      collectibleAddress: string,
      newOwnerAddress: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<TransferCollectibleResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.transferCollectible(
          collectibleAddress,
          newOwnerAddress,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Validate address
     * @param {string} address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async validateAddress(
      address: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ValidateAddressResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.validateAddress(
        address,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * CollectiblesApi - factory interface
 * @export
 */
export const CollectiblesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = CollectiblesApiFp(configuration);
  return {
    /**
     * Returns collectible by address
     * @param {string} address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    collectible(
      address: string,
      options?: any,
    ): AxiosPromise<CollectibleResponse> {
      return localVarFp
        .collectible(address, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns user`s collectible previews by collection
     * @param {string} userAddress
     * @param {string} [collectionAddress]
     * @param {number} [count]
     * @param {string} [cursor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    collectiblePreviewsByCollection(
      userAddress: string,
      collectionAddress?: string,
      count?: number,
      cursor?: string,
      options?: any,
    ): AxiosPromise<CollectiblePreviewsByCollectionResponse> {
      return localVarFp
        .collectiblePreviewsByCollection(
          userAddress,
          collectionAddress,
          count,
          cursor,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns newest user`s collectible previews (3 by default)
     * @param {string} userAddress
     * @param {number} [count]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    collectiblePreviewsNewest(
      userAddress: string,
      count?: number,
      options?: any,
    ): AxiosPromise<CollectiblePreviewsNewestResponse> {
      return localVarFp
        .collectiblePreviewsNewest(userAddress, count, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns user`s collectibles grouped by collection
     * @param {string} address
     * @param {number} countColTotal
     * @param {number} countRowPerCollection
     * @param {number} countRowTotal
     * @param {string} [cursor]
     * @param {Array<string>} [skipCollections]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    collectiblesGrouped(
      address: string,
      countColTotal: number,
      countRowPerCollection: number,
      countRowTotal: number,
      cursor?: string,
      skipCollections?: Array<string>,
      options?: any,
    ): AxiosPromise<CollectiblesGroupedResponse> {
      return localVarFp
        .collectiblesGrouped(
          address,
          countColTotal,
          countRowPerCollection,
          countRowTotal,
          cursor,
          skipCollections,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns addresses from previews nft transfers
     * @param {string} userAddress
     * @param {number} [count]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suggestNftTransferAddress(
      userAddress: string,
      count?: number,
      options?: any,
    ): AxiosPromise<Array<SuggestedAddress>> {
      return localVarFp
        .suggestNftTransferAddress(userAddress, count, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates unsigned TX transfering collectible to new owner
     * @param {string} collectibleAddress
     * @param {string} newOwnerAddress
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transferCollectible(
      collectibleAddress: string,
      newOwnerAddress: string,
      options?: any,
    ): AxiosPromise<TransferCollectibleResponse> {
      return localVarFp
        .transferCollectible(collectibleAddress, newOwnerAddress, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Validate address
     * @param {string} address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateAddress(
      address: string,
      options?: any,
    ): AxiosPromise<ValidateAddressResponse> {
      return localVarFp
        .validateAddress(address, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * CollectiblesApi - object-oriented interface
 * @export
 * @class CollectiblesApi
 * @extends {BaseAPI}
 */
export class CollectiblesApi extends BaseAPI {
  /**
   * Returns collectible by address
   * @param {string} address
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CollectiblesApi
   */
  public collectible(address: string, options?: AxiosRequestConfig) {
    return CollectiblesApiFp(this.configuration)
      .collectible(address, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns user`s collectible previews by collection
   * @param {string} userAddress
   * @param {string} [collectionAddress]
   * @param {number} [count]
   * @param {string} [cursor]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CollectiblesApi
   */
  public collectiblePreviewsByCollection(
    userAddress: string,
    collectionAddress?: string,
    count?: number,
    cursor?: string,
    options?: AxiosRequestConfig,
  ) {
    return CollectiblesApiFp(this.configuration)
      .collectiblePreviewsByCollection(
        userAddress,
        collectionAddress,
        count,
        cursor,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns newest user`s collectible previews (3 by default)
   * @param {string} userAddress
   * @param {number} [count]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CollectiblesApi
   */
  public collectiblePreviewsNewest(
    userAddress: string,
    count?: number,
    options?: AxiosRequestConfig,
  ) {
    return CollectiblesApiFp(this.configuration)
      .collectiblePreviewsNewest(userAddress, count, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns user`s collectibles grouped by collection
   * @param {string} address
   * @param {number} countColTotal
   * @param {number} countRowPerCollection
   * @param {number} countRowTotal
   * @param {string} [cursor]
   * @param {Array<string>} [skipCollections]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CollectiblesApi
   */
  public collectiblesGrouped(
    address: string,
    countColTotal: number,
    countRowPerCollection: number,
    countRowTotal: number,
    cursor?: string,
    skipCollections?: Array<string>,
    options?: AxiosRequestConfig,
  ) {
    return CollectiblesApiFp(this.configuration)
      .collectiblesGrouped(
        address,
        countColTotal,
        countRowPerCollection,
        countRowTotal,
        cursor,
        skipCollections,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns addresses from previews nft transfers
   * @param {string} userAddress
   * @param {number} [count]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CollectiblesApi
   */
  public suggestNftTransferAddress(
    userAddress: string,
    count?: number,
    options?: AxiosRequestConfig,
  ) {
    return CollectiblesApiFp(this.configuration)
      .suggestNftTransferAddress(userAddress, count, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates unsigned TX transfering collectible to new owner
   * @param {string} collectibleAddress
   * @param {string} newOwnerAddress
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CollectiblesApi
   */
  public transferCollectible(
    collectibleAddress: string,
    newOwnerAddress: string,
    options?: AxiosRequestConfig,
  ) {
    return CollectiblesApiFp(this.configuration)
      .transferCollectible(collectibleAddress, newOwnerAddress, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Validate address
   * @param {string} address
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CollectiblesApi
   */
  public validateAddress(address: string, options?: AxiosRequestConfig) {
    return CollectiblesApiFp(this.configuration)
      .validateAddress(address, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
