/* tslint:disable */

/* eslint-disable */

/**
 * usdt-raffle
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: DEVELOPMENT
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import globalAxios, {
  AxiosInstance,
  AxiosPromise,
  AxiosRequestConfig,
} from 'axios';

// @ts-ignore
import {
  BASE_PATH,
  BaseAPI,
  COLLECTION_FORMATS,
  RequestArgs,
  RequiredError,
} from './base';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  createRequestFunction,
  serializeDataIfNeeded,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  toPathString,
} from './common';
import { Configuration } from './configuration';

/**
 *
 * @export
 * @interface ApplicationInfo
 */
export interface ApplicationInfo {
  /**
   *
   * @type {string}
   * @memberof ApplicationInfo
   */
  app_name: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationInfo
   */
  app_version: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationInfo
   */
  host_name?: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationInfo
   */
  app_time: string;
}
/**
 *
 * @export
 * @interface Chat
 */
export interface Chat {
  /**
   *
   * @type {number}
   * @memberof Chat
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof Chat
   */
  type: string;
}
/**
 *
 * @export
 * @interface ChatInviteLink
 */
export interface ChatInviteLink {
  /**
   *
   * @type {string}
   * @memberof ChatInviteLink
   */
  invite_link: string;
  /**
   *
   * @type {User}
   * @memberof ChatInviteLink
   */
  creator: User;
}
/**
 *
 * @export
 * @interface ChatMember
 */
export interface ChatMember {
  /**
   *
   * @type {string}
   * @memberof ChatMember
   */
  status: string;
  /**
   *
   * @type {User}
   * @memberof ChatMember
   */
  user: User;
}
/**
 *
 * @export
 * @interface ChatMemberUpdate
 */
export interface ChatMemberUpdate {
  /**
   *
   * @type {Chat}
   * @memberof ChatMemberUpdate
   */
  chat: Chat;
  /**
   *
   * @type {User}
   * @memberof ChatMemberUpdate
   */
  from: User;
  /**
   *
   * @type {number}
   * @memberof ChatMemberUpdate
   */
  date: number;
  /**
   *
   * @type {ChatMember}
   * @memberof ChatMemberUpdate
   */
  old_chat_member: ChatMember;
  /**
   *
   * @type {ChatMember}
   * @memberof ChatMemberUpdate
   */
  new_chat_member: ChatMember;
  /**
   *
   * @type {ChatInviteLink}
   * @memberof ChatMemberUpdate
   */
  invite_link?: ChatInviteLink;
}
/**
 *
 * @export
 * @interface HealthStatus
 */
export interface HealthStatus {
  /**
   *
   * @type {string}
   * @memberof HealthStatus
   */
  state: HealthStatusStateEnum;
  /**
   *
   * @type {boolean}
   * @memberof HealthStatus
   */
  serviceAvailable: boolean;
}

export const HealthStatusStateEnum = {
  Ok: 'OK',
  ConnectionFailed: 'CONNECTION_FAILED',
  NotReady: 'NOT_READY',
} as const;

export type HealthStatusStateEnum =
  typeof HealthStatusStateEnum[keyof typeof HealthStatusStateEnum];

/**
 *
 * @export
 * @interface HealthStatusResponse
 */
export interface HealthStatusResponse {
  /**
   *
   * @type {string}
   * @memberof HealthStatusResponse
   */
  instance_id: string;
  /**
   *
   * @type {{ [key: string]: HealthStatus; }}
   * @memberof HealthStatusResponse
   */
  resources_status: { [key: string]: HealthStatus };
}
/**
 *
 * @export
 * @interface Period
 */
export interface Period {
  /**
   *
   * @type {number}
   * @memberof Period
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof Period
   */
  startInclusive: string;
  /**
   *
   * @type {string}
   * @memberof Period
   */
  endExclusive: string;
  /**
   *
   * @type {number}
   * @memberof Period
   */
  ticketLimit: number;
}
/**
 *
 * @export
 * @interface RecordWinnersRestRequest
 */
export interface RecordWinnersRestRequest {
  /**
   *
   * @type {number}
   * @memberof RecordWinnersRestRequest
   */
  periodId?: number;
  /**
   *
   * @type {string}
   * @memberof RecordWinnersRestRequest
   */
  type: RecordWinnersRestRequestTypeEnum;
  /**
   *
   * @type {string}
   * @memberof RecordWinnersRestRequest
   */
  prizeAmountInTon: string;
  /**
   *
   * @type {Array<number>}
   * @memberof RecordWinnersRestRequest
   */
  tickets: Array<number>;
}

export const RecordWinnersRestRequestTypeEnum = {
  Minor: 'MINOR',
  Grand: 'GRAND',
} as const;

export type RecordWinnersRestRequestTypeEnum =
  typeof RecordWinnersRestRequestTypeEnum[keyof typeof RecordWinnersRestRequestTypeEnum];

/**
 *
 * @export
 * @interface RestDataResponseGetAllUserTicketNumbersRestStatusTicketNumbersRestDto
 */
export interface RestDataResponseGetAllUserTicketNumbersRestStatusTicketNumbersRestDto {
  /**
   * Operation result status, always present
   * @type {string}
   * @memberof RestDataResponseGetAllUserTicketNumbersRestStatusTicketNumbersRestDto
   */
  status?: RestDataResponseGetAllUserTicketNumbersRestStatusTicketNumbersRestDtoStatusEnum;
  /**
   * Verbose reason of non-success result
   * @type {string}
   * @memberof RestDataResponseGetAllUserTicketNumbersRestStatusTicketNumbersRestDto
   */
  message?: string;
  /**
   *
   * @type {TicketNumbersRestDto}
   * @memberof RestDataResponseGetAllUserTicketNumbersRestStatusTicketNumbersRestDto
   */
  data?: TicketNumbersRestDto;
}

export const RestDataResponseGetAllUserTicketNumbersRestStatusTicketNumbersRestDtoStatusEnum =
  {
    Success: 'SUCCESS',
    CampaignNotStartedYet: 'CAMPAIGN_NOT_STARTED_YET',
  } as const;

export type RestDataResponseGetAllUserTicketNumbersRestStatusTicketNumbersRestDtoStatusEnum =
  typeof RestDataResponseGetAllUserTicketNumbersRestStatusTicketNumbersRestDtoStatusEnum[keyof typeof RestDataResponseGetAllUserTicketNumbersRestStatusTicketNumbersRestDtoStatusEnum];

/**
 *
 * @export
 * @interface RestDataResponseGetSettingsRestStatusSettingsRestDto
 */
export interface RestDataResponseGetSettingsRestStatusSettingsRestDto {
  /**
   * Operation result status, always present
   * @type {string}
   * @memberof RestDataResponseGetSettingsRestStatusSettingsRestDto
   */
  status?: RestDataResponseGetSettingsRestStatusSettingsRestDtoStatusEnum;
  /**
   * Verbose reason of non-success result
   * @type {string}
   * @memberof RestDataResponseGetSettingsRestStatusSettingsRestDto
   */
  message?: string;
  /**
   *
   * @type {SettingsRestDto}
   * @memberof RestDataResponseGetSettingsRestStatusSettingsRestDto
   */
  data?: SettingsRestDto;
}

export const RestDataResponseGetSettingsRestStatusSettingsRestDtoStatusEnum = {
  Success: 'SUCCESS',
} as const;

export type RestDataResponseGetSettingsRestStatusSettingsRestDtoStatusEnum =
  typeof RestDataResponseGetSettingsRestStatusSettingsRestDtoStatusEnum[keyof typeof RestDataResponseGetSettingsRestStatusSettingsRestDtoStatusEnum];

/**
 *
 * @export
 * @interface RestDataResponseGetUserTicketCountRestStatusInteger
 */
export interface RestDataResponseGetUserTicketCountRestStatusInteger {
  /**
   * Operation result status, always present
   * @type {string}
   * @memberof RestDataResponseGetUserTicketCountRestStatusInteger
   */
  status?: RestDataResponseGetUserTicketCountRestStatusIntegerStatusEnum;
  /**
   * Verbose reason of non-success result
   * @type {string}
   * @memberof RestDataResponseGetUserTicketCountRestStatusInteger
   */
  message?: string;
  /**
   * Response payload, present if status is SUCCESS
   * @type {number}
   * @memberof RestDataResponseGetUserTicketCountRestStatusInteger
   */
  data?: number;
}

export const RestDataResponseGetUserTicketCountRestStatusIntegerStatusEnum = {
  Success: 'SUCCESS',
  CampaignNotStartedYet: 'CAMPAIGN_NOT_STARTED_YET',
} as const;

export type RestDataResponseGetUserTicketCountRestStatusIntegerStatusEnum =
  typeof RestDataResponseGetUserTicketCountRestStatusIntegerStatusEnum[keyof typeof RestDataResponseGetUserTicketCountRestStatusIntegerStatusEnum];

/**
 *
 * @export
 * @interface RestResponseGetUserOptOutStatusRestStatus
 */
export interface RestResponseGetUserOptOutStatusRestStatus {
  /**
   * Operation result status, always present
   * @type {string}
   * @memberof RestResponseGetUserOptOutStatusRestStatus
   */
  status?: RestResponseGetUserOptOutStatusRestStatusStatusEnum;
  /**
   * Verbose reason of non-success result
   * @type {string}
   * @memberof RestResponseGetUserOptOutStatusRestStatus
   */
  message?: string;
}

export const RestResponseGetUserOptOutStatusRestStatusStatusEnum = {
  Participates: 'PARTICIPATES',
  OptedOut: 'OPTED_OUT',
} as const;

export type RestResponseGetUserOptOutStatusRestStatusStatusEnum =
  typeof RestResponseGetUserOptOutStatusRestStatusStatusEnum[keyof typeof RestResponseGetUserOptOutStatusRestStatusStatusEnum];

/**
 *
 * @export
 * @interface RestResponseImportChatMemberUpdateRestStatus
 */
export interface RestResponseImportChatMemberUpdateRestStatus {
  /**
   * Operation result status, always present
   * @type {string}
   * @memberof RestResponseImportChatMemberUpdateRestStatus
   */
  status?: RestResponseImportChatMemberUpdateRestStatusStatusEnum;
  /**
   * Verbose reason of non-success result
   * @type {string}
   * @memberof RestResponseImportChatMemberUpdateRestStatus
   */
  message?: string;
}

export const RestResponseImportChatMemberUpdateRestStatusStatusEnum = {
  InactiveCampaign: 'INACTIVE_CAMPAIGN',
  WrongToken: 'WRONG_TOKEN',
  WrongUpdateType: 'WRONG_UPDATE_TYPE',
  Imported: 'IMPORTED',
} as const;

export type RestResponseImportChatMemberUpdateRestStatusStatusEnum =
  typeof RestResponseImportChatMemberUpdateRestStatusStatusEnum[keyof typeof RestResponseImportChatMemberUpdateRestStatusStatusEnum];

/**
 *
 * @export
 * @interface RestResponseRecordWinnersRestStatus
 */
export interface RestResponseRecordWinnersRestStatus {
  /**
   * Operation result status, always present
   * @type {string}
   * @memberof RestResponseRecordWinnersRestStatus
   */
  status?: RestResponseRecordWinnersRestStatusStatusEnum;
  /**
   * Verbose reason of non-success result
   * @type {string}
   * @memberof RestResponseRecordWinnersRestStatus
   */
  message?: string;
}

export const RestResponseRecordWinnersRestStatusStatusEnum = {
  Success: 'SUCCESS',
} as const;

export type RestResponseRecordWinnersRestStatusStatusEnum =
  typeof RestResponseRecordWinnersRestStatusStatusEnum[keyof typeof RestResponseRecordWinnersRestStatusStatusEnum];

/**
 *
 * @export
 * @interface RestResponseUserOptOutRestStatus
 */
export interface RestResponseUserOptOutRestStatus {
  /**
   * Operation result status, always present
   * @type {string}
   * @memberof RestResponseUserOptOutRestStatus
   */
  status?: RestResponseUserOptOutRestStatusStatusEnum;
  /**
   * Verbose reason of non-success result
   * @type {string}
   * @memberof RestResponseUserOptOutRestStatus
   */
  message?: string;
}

export const RestResponseUserOptOutRestStatusStatusEnum = {
  Success: 'SUCCESS',
} as const;

export type RestResponseUserOptOutRestStatusStatusEnum =
  typeof RestResponseUserOptOutRestStatusStatusEnum[keyof typeof RestResponseUserOptOutRestStatusStatusEnum];

/**
 *
 * @export
 * @interface Reward
 */
export interface Reward {
  /**
   *
   * @type {number}
   * @memberof Reward
   */
  ticketBatchSize: number;
  /**
   *
   * @type {string}
   * @memberof Reward
   */
  minAmountTON: string;
  /**
   *
   * @type {string}
   * @memberof Reward
   */
  minAmountUSDT: string;
  /**
   *
   * @type {string}
   * @memberof Reward
   */
  minAmountBTC: string;
}
/**
 *
 * @export
 * @interface RewardPerAmount
 */
export interface RewardPerAmount {
  /**
   *
   * @type {number}
   * @memberof RewardPerAmount
   */
  ticketBatchSize: number;
  /**
   *
   * @type {string}
   * @memberof RewardPerAmount
   */
  operationAmountInUSDTPerTicketBatch: string;
  /**
   *
   * @type {string}
   * @memberof RewardPerAmount
   */
  operationAmountInTONPerTicketBatch: string;
  /**
   *
   * @type {string}
   * @memberof RewardPerAmount
   */
  operationAmountInBTCPerTicketBatch: string;
}
/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface SettingsRestDto
 */
export interface SettingsRestDto {
  /**
   *
   * @type {string}
   * @memberof SettingsRestDto
   */
  campaignStartInclusive: string;
  /**
   *
   * @type {string}
   * @memberof SettingsRestDto
   */
  campaignEndExclusive: string;
  /**
   *
   * @type {Array<Period>}
   * @memberof SettingsRestDto
   */
  campaignPeriods: Array<Period>;
  /**
   *
   * @type {boolean}
   * @memberof SettingsRestDto
   */
  isCampaignActive: boolean;
  /**
   *
   * @type {number}
   * @memberof SettingsRestDto
   */
  currentPeriodId?: number;
  /**
   *
   * @type {number}
   * @memberof SettingsRestDto
   */
  ticketLimitIncreasePerPeriod: number;
  /**
   *
   * @type {Tasks}
   * @memberof SettingsRestDto
   */
  settingsPerTask: Tasks;
}
/**
 *
 * @export
 * @interface Tasks
 */
export interface Tasks {
  /**
   *
   * @type {RewardPerAmount}
   * @memberof Tasks
   */
  deposit: RewardPerAmount;
  /**
   *
   * @type {Reward}
   * @memberof Tasks
   */
  transfer: Reward;
  /**
   *
   * @type {RewardPerAmount}
   * @memberof Tasks
   */
  purchase: RewardPerAmount;
  /**
   *
   * @type {RewardPerAmount}
   * @memberof Tasks
   */
  p2pPurchase: RewardPerAmount;
  /**
   *
   * @type {RewardPerAmount}
   * @memberof Tasks
   */
  swap: RewardPerAmount;
}
/**
 *
 * @export
 * @interface TicketNumbersInPeriod
 */
export interface TicketNumbersInPeriod {
  /**
   *
   * @type {number}
   * @memberof TicketNumbersInPeriod
   */
  periodId: number;
  /**
   *
   * @type {Array<number>}
   * @memberof TicketNumbersInPeriod
   */
  ticketNumbers: Array<number>;
}
/**
 * Response payload, present if status is SUCCESS
 * @export
 * @interface TicketNumbersRestDto
 */
export interface TicketNumbersRestDto {
  /**
   *
   * @type {Array<TicketNumbersInPeriod>}
   * @memberof TicketNumbersRestDto
   */
  numbers: Array<TicketNumbersInPeriod>;
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {number}
   * @memberof User
   */
  id: number;
  /**
   *
   * @type {boolean}
   * @memberof User
   */
  is_bot: boolean;
}
/**
 *
 * @export
 * @interface WebhookUpdateRestRequest
 */
export interface WebhookUpdateRestRequest {
  /**
   *
   * @type {number}
   * @memberof WebhookUpdateRestRequest
   */
  update_id: number;
  /**
   *
   * @type {ChatMemberUpdate}
   * @memberof WebhookUpdateRestRequest
   */
  chat_member?: ChatMemberUpdate;
}

/**
 * ApplicationRestApi - axios parameter creator
 * @export
 */
export const ApplicationRestApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatus: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/usdt-raffle/internal-api/v1/info`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ApplicationRestApi - functional programming interface
 * @export
 */
export const ApplicationRestApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ApplicationRestApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStatus(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ApplicationInfo>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStatus(
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * ApplicationRestApi - factory interface
 * @export
 */
export const ApplicationRestApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ApplicationRestApiFp(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatus(options?: any): AxiosPromise<ApplicationInfo> {
      return localVarFp
        .getStatus(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ApplicationRestApi - object-oriented interface
 * @export
 * @class ApplicationRestApi
 * @extends {BaseAPI}
 */
export class ApplicationRestApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApplicationRestApi
   */
  public getStatus(options?: AxiosRequestConfig) {
    return ApplicationRestApiFp(this.configuration)
      .getStatus(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ChatMemberUpdateApi - axios parameter creator
 * @export
 */
export const ChatMemberUpdateApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Receive chat member update from telegram webhook to record wallet chat joins by users wishing to get tickets as a reward.
     * @param {WebhookUpdateRestRequest} webhookUpdateRestRequest
     * @param {string} [xTelegramBotApiSecretToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    importChatMemberUpdate: async (
      webhookUpdateRestRequest: WebhookUpdateRestRequest,
      xTelegramBotApiSecretToken?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'webhookUpdateRestRequest' is not null or undefined
      assertParamExists(
        'importChatMemberUpdate',
        'webhookUpdateRestRequest',
        webhookUpdateRestRequest,
      );
      const localVarPath = `/usdt-raffle/webhook/v1/chat-member-update`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (
        xTelegramBotApiSecretToken !== undefined &&
        xTelegramBotApiSecretToken !== null
      ) {
        localVarHeaderParameter['x-telegram-bot-api-secret-token'] = String(
          xTelegramBotApiSecretToken,
        );
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        webhookUpdateRestRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ChatMemberUpdateApi - functional programming interface
 * @export
 */
export const ChatMemberUpdateApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ChatMemberUpdateApiAxiosParamCreator(configuration);
  return {
    /**
     * Receive chat member update from telegram webhook to record wallet chat joins by users wishing to get tickets as a reward.
     * @param {WebhookUpdateRestRequest} webhookUpdateRestRequest
     * @param {string} [xTelegramBotApiSecretToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async importChatMemberUpdate(
      webhookUpdateRestRequest: WebhookUpdateRestRequest,
      xTelegramBotApiSecretToken?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<RestResponseImportChatMemberUpdateRestStatus>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.importChatMemberUpdate(
          webhookUpdateRestRequest,
          xTelegramBotApiSecretToken,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * ChatMemberUpdateApi - factory interface
 * @export
 */
export const ChatMemberUpdateApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ChatMemberUpdateApiFp(configuration);
  return {
    /**
     * Receive chat member update from telegram webhook to record wallet chat joins by users wishing to get tickets as a reward.
     * @param {WebhookUpdateRestRequest} webhookUpdateRestRequest
     * @param {string} [xTelegramBotApiSecretToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    importChatMemberUpdate(
      webhookUpdateRestRequest: WebhookUpdateRestRequest,
      xTelegramBotApiSecretToken?: string,
      options?: any,
    ): AxiosPromise<RestResponseImportChatMemberUpdateRestStatus> {
      return localVarFp
        .importChatMemberUpdate(
          webhookUpdateRestRequest,
          xTelegramBotApiSecretToken,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ChatMemberUpdateApi - object-oriented interface
 * @export
 * @class ChatMemberUpdateApi
 * @extends {BaseAPI}
 */
export class ChatMemberUpdateApi extends BaseAPI {
  /**
   * Receive chat member update from telegram webhook to record wallet chat joins by users wishing to get tickets as a reward.
   * @param {WebhookUpdateRestRequest} webhookUpdateRestRequest
   * @param {string} [xTelegramBotApiSecretToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatMemberUpdateApi
   */
  public importChatMemberUpdate(
    webhookUpdateRestRequest: WebhookUpdateRestRequest,
    xTelegramBotApiSecretToken?: string,
    options?: AxiosRequestConfig,
  ) {
    return ChatMemberUpdateApiFp(this.configuration)
      .importChatMemberUpdate(
        webhookUpdateRestRequest,
        xTelegramBotApiSecretToken,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * HealthCheckRestApi - axios parameter creator
 * @export
 */
export const HealthCheckRestApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resourcesHealthStatus: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/system/health`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * HealthCheckRestApi - functional programming interface
 * @export
 */
export const HealthCheckRestApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    HealthCheckRestApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async resourcesHealthStatus(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<HealthStatusResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.resourcesHealthStatus(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * HealthCheckRestApi - factory interface
 * @export
 */
export const HealthCheckRestApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = HealthCheckRestApiFp(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resourcesHealthStatus(options?: any): AxiosPromise<HealthStatusResponse> {
      return localVarFp
        .resourcesHealthStatus(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * HealthCheckRestApi - object-oriented interface
 * @export
 * @class HealthCheckRestApi
 * @extends {BaseAPI}
 */
export class HealthCheckRestApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HealthCheckRestApi
   */
  public resourcesHealthStatus(options?: AxiosRequestConfig) {
    return HealthCheckRestApiFp(this.configuration)
      .resourcesHealthStatus(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ParticipationApi - axios parameter creator
 * @export
 */
export const ParticipationApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Get participation status of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getParticipationStatus: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/usdt-raffle/public-api/v1/participation`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Opt out user from participating in campaign
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optOut: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/usdt-raffle/public-api/v1/participation/opt-out`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ParticipationApi - functional programming interface
 * @export
 */
export const ParticipationApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ParticipationApiAxiosParamCreator(configuration);
  return {
    /**
     * Get participation status of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getParticipationStatus(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<RestResponseGetUserOptOutStatusRestStatus>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getParticipationStatus(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Opt out user from participating in campaign
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async optOut(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<RestResponseUserOptOutRestStatus>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.optOut(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * ParticipationApi - factory interface
 * @export
 */
export const ParticipationApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ParticipationApiFp(configuration);
  return {
    /**
     * Get participation status of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getParticipationStatus(
      options?: any,
    ): AxiosPromise<RestResponseGetUserOptOutStatusRestStatus> {
      return localVarFp
        .getParticipationStatus(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Opt out user from participating in campaign
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optOut(options?: any): AxiosPromise<RestResponseUserOptOutRestStatus> {
      return localVarFp
        .optOut(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ParticipationApi - object-oriented interface
 * @export
 * @class ParticipationApi
 * @extends {BaseAPI}
 */
export class ParticipationApi extends BaseAPI {
  /**
   * Get participation status of user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ParticipationApi
   */
  public getParticipationStatus(options?: AxiosRequestConfig) {
    return ParticipationApiFp(this.configuration)
      .getParticipationStatus(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Opt out user from participating in campaign
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ParticipationApi
   */
  public optOut(options?: AxiosRequestConfig) {
    return ParticipationApiFp(this.configuration)
      .optOut(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PrizeApi - axios parameter creator
 * @export
 */
export const PrizeApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Record winning tickets.
     * @param {RecordWinnersRestRequest} recordWinnersRestRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    recordWinners: async (
      recordWinnersRestRequest: RecordWinnersRestRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'recordWinnersRestRequest' is not null or undefined
      assertParamExists(
        'recordWinners',
        'recordWinnersRestRequest',
        recordWinnersRestRequest,
      );
      const localVarPath = `/usdt-raffle/internal-api/v1/prize/record-winners`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        recordWinnersRestRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PrizeApi - functional programming interface
 * @export
 */
export const PrizeApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PrizeApiAxiosParamCreator(configuration);
  return {
    /**
     * Record winning tickets.
     * @param {RecordWinnersRestRequest} recordWinnersRestRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async recordWinners(
      recordWinnersRestRequest: RecordWinnersRestRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<RestResponseRecordWinnersRestStatus>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.recordWinners(
        recordWinnersRestRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * PrizeApi - factory interface
 * @export
 */
export const PrizeApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = PrizeApiFp(configuration);
  return {
    /**
     * Record winning tickets.
     * @param {RecordWinnersRestRequest} recordWinnersRestRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    recordWinners(
      recordWinnersRestRequest: RecordWinnersRestRequest,
      options?: any,
    ): AxiosPromise<RestResponseRecordWinnersRestStatus> {
      return localVarFp
        .recordWinners(recordWinnersRestRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * PrizeApi - object-oriented interface
 * @export
 * @class PrizeApi
 * @extends {BaseAPI}
 */
export class PrizeApi extends BaseAPI {
  /**
   * Record winning tickets.
   * @param {RecordWinnersRestRequest} recordWinnersRestRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PrizeApi
   */
  public recordWinners(
    recordWinnersRestRequest: RecordWinnersRestRequest,
    options?: AxiosRequestConfig,
  ) {
    return PrizeApiFp(this.configuration)
      .recordWinners(recordWinnersRestRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ProfilerReporterRestApi - axios parameter creator
 * @export
 */
export const ProfilerReporterRestApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metrics: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/system/prometheus/metrics`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ProfilerReporterRestApi - functional programming interface
 * @export
 */
export const ProfilerReporterRestApiFp = function (
  configuration?: Configuration,
) {
  const localVarAxiosParamCreator =
    ProfilerReporterRestApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async metrics(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.metrics(
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * ProfilerReporterRestApi - factory interface
 * @export
 */
export const ProfilerReporterRestApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ProfilerReporterRestApiFp(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metrics(options?: any): AxiosPromise<string> {
      return localVarFp
        .metrics(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ProfilerReporterRestApi - object-oriented interface
 * @export
 * @class ProfilerReporterRestApi
 * @extends {BaseAPI}
 */
export class ProfilerReporterRestApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProfilerReporterRestApi
   */
  public metrics(options?: AxiosRequestConfig) {
    return ProfilerReporterRestApiFp(this.configuration)
      .metrics(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SettingsApi - axios parameter creator
 * @export
 */
export const SettingsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Get information about raffle settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSettings: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/usdt-raffle/public-api/v1/settings`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SettingsApi - functional programming interface
 * @export
 */
export const SettingsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SettingsApiAxiosParamCreator(configuration);
  return {
    /**
     * Get information about raffle settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSettings(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<RestDataResponseGetSettingsRestStatusSettingsRestDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSettings(
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * SettingsApi - factory interface
 * @export
 */
export const SettingsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = SettingsApiFp(configuration);
  return {
    /**
     * Get information about raffle settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSettings(
      options?: any,
    ): AxiosPromise<RestDataResponseGetSettingsRestStatusSettingsRestDto> {
      return localVarFp
        .getSettings(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SettingsApi - object-oriented interface
 * @export
 * @class SettingsApi
 * @extends {BaseAPI}
 */
export class SettingsApi extends BaseAPI {
  /**
   * Get information about raffle settings
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SettingsApi
   */
  public getSettings(options?: AxiosRequestConfig) {
    return SettingsApiFp(this.configuration)
      .getSettings(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TicketsApi - axios parameter creator
 * @export
 */
export const TicketsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Get ticket count for user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentTicketCount: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/usdt-raffle/public-api/v1/tickets/count`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get all ticket numbers for user in all periods
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTicketNumbersInAllPeriods: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/usdt-raffle/public-api/v1/tickets/numbers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TicketsApi - functional programming interface
 * @export
 */
export const TicketsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TicketsApiAxiosParamCreator(configuration);
  return {
    /**
     * Get ticket count for user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCurrentTicketCount(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<RestDataResponseGetUserTicketCountRestStatusInteger>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCurrentTicketCount(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get all ticket numbers for user in all periods
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTicketNumbersInAllPeriods(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<RestDataResponseGetAllUserTicketNumbersRestStatusTicketNumbersRestDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getTicketNumbersInAllPeriods(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * TicketsApi - factory interface
 * @export
 */
export const TicketsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = TicketsApiFp(configuration);
  return {
    /**
     * Get ticket count for user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentTicketCount(
      options?: any,
    ): AxiosPromise<RestDataResponseGetUserTicketCountRestStatusInteger> {
      return localVarFp
        .getCurrentTicketCount(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get all ticket numbers for user in all periods
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTicketNumbersInAllPeriods(
      options?: any,
    ): AxiosPromise<RestDataResponseGetAllUserTicketNumbersRestStatusTicketNumbersRestDto> {
      return localVarFp
        .getTicketNumbersInAllPeriods(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * TicketsApi - object-oriented interface
 * @export
 * @class TicketsApi
 * @extends {BaseAPI}
 */
export class TicketsApi extends BaseAPI {
  /**
   * Get ticket count for user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsApi
   */
  public getCurrentTicketCount(options?: AxiosRequestConfig) {
    return TicketsApiFp(this.configuration)
      .getCurrentTicketCount(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get all ticket numbers for user in all periods
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsApi
   */
  public getTicketNumbersInAllPeriods(options?: AxiosRequestConfig) {
    return TicketsApiFp(this.configuration)
      .getTicketNumbersInAllPeriods(options)
      .then((request) => request(this.axios, this.basePath));
  }
}
