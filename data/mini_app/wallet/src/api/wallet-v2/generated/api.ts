/* tslint:disable */

/* eslint-disable */

/**
 * Wallet API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import globalAxios, {
  AxiosInstance,
  AxiosPromise,
  AxiosRequestConfig,
} from 'axios';

// @ts-ignore
import {
  BASE_PATH,
  BaseAPI,
  COLLECTION_FORMATS,
  RequestArgs,
  RequiredError,
} from './base';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  createRequestFunction,
  serializeDataIfNeeded,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  toPathString,
} from './common';
import { Configuration } from './configuration';

/**
 *
 * @export
 * @interface ApiError
 */
export interface ApiError {
  /**
   *
   * @type {string}
   * @memberof ApiError
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof ApiError
   */
  detail: string;
}
/**
 *
 * @export
 * @interface ChangeEmailRequest
 */
export interface ChangeEmailRequest {
  /**
   *
   * @type {string}
   * @memberof ChangeEmailRequest
   */
  currentEmailCode?: string;
  /**
   *
   * @type {string}
   * @memberof ChangeEmailRequest
   */
  passcode?: string;
  /**
   *
   * @type {string}
   * @memberof ChangeEmailRequest
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof ChangeEmailRequest
   */
  emailCode: string;
}
/**
 *
 * @export
 * @interface CheckCodeEmailRequest
 */
export interface CheckCodeEmailRequest {
  /**
   *
   * @type {string}
   * @memberof CheckCodeEmailRequest
   */
  emailCode: string;
  /**
   *
   * @type {EmailCodeReasonEnum}
   * @memberof CheckCodeEmailRequest
   */
  reason: EmailCodeReasonEnum;
}
/**
 *
 * @export
 * @interface CodedResponse
 */
export interface CodedResponse {
  /**
   *
   * @type {string}
   * @memberof CodedResponse
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof CodedResponse
   */
  detail: string;
}
/**
 *
 * @export
 * @interface CreateEmailRequest
 */
export interface CreateEmailRequest {
  /**
   *
   * @type {string}
   * @memberof CreateEmailRequest
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof CreateEmailRequest
   */
  emailCode: string;
}
/**
 *
 * @export
 * @interface CreatePasscodeRequest
 */
export interface CreatePasscodeRequest {
  /**
   *
   * @type {PasscodeTypeEnum}
   * @memberof CreatePasscodeRequest
   */
  newPasscodeType: PasscodeTypeEnum;
  /**
   *
   * @type {string}
   * @memberof CreatePasscodeRequest
   */
  newPasscode?: string;
  /**
   *
   * @type {string}
   * @memberof CreatePasscodeRequest
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof CreatePasscodeRequest
   */
  emailCode?: string;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const EmailCodeReasonEnum = {
  ConfirmEmail: 'confirm-email',
  ChangeEmail: 'change-email',
  ChangePasscode: 'change-passcode',
  GetRecoveryKey: 'get-recovery-key',
} as const;

export type EmailCodeReasonEnum =
  typeof EmailCodeReasonEnum[keyof typeof EmailCodeReasonEnum];

/**
 *
 * @export
 * @interface EmailResponse
 */
export interface EmailResponse {
  /**
   *
   * @type {string}
   * @memberof EmailResponse
   */
  email: string;
}
/**
 *
 * @export
 * @interface GetRecoveryKeyRequest
 */
export interface GetRecoveryKeyRequest {
  /**
   *
   * @type {string}
   * @memberof GetRecoveryKeyRequest
   */
  scwAddressId: string;
  /**
   *
   * @type {string}
   * @memberof GetRecoveryKeyRequest
   */
  emailCode: string;
}
/**
 *
 * @export
 * @interface GetRecoveryKeyResponse
 */
export interface GetRecoveryKeyResponse {
  /**
   *
   * @type {string}
   * @memberof GetRecoveryKeyResponse
   */
  recoveryKey: string;
  /**
   *
   * @type {string}
   * @memberof GetRecoveryKeyResponse
   */
  recoveryIv: string;
}
/**
 *
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
  /**
   *
   * @type {Array<ValidationError>}
   * @memberof HTTPValidationError
   */
  detail?: Array<ValidationError>;
}
/**
 *
 * @export
 * @interface PasscodeError
 */
export interface PasscodeError {
  /**
   *
   * @type {string}
   * @memberof PasscodeError
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof PasscodeError
   */
  detail: string;
  /**
   *
   * @type {number}
   * @memberof PasscodeError
   */
  num_remaining_attempts: number;
}
/**
 *
 * @export
 * @interface PasscodeInfoResponse
 */
export interface PasscodeInfoResponse {
  /**
   *
   * @type {PasscodeTypeEnum}
   * @memberof PasscodeInfoResponse
   */
  passcodeType?: PasscodeTypeEnum;
  /**
   *
   * @type {number}
   * @memberof PasscodeInfoResponse
   */
  unlockDuration?: number;
  /**
   *
   * @type {boolean}
   * @memberof PasscodeInfoResponse
   */
  requiredOnOpen?: boolean;
  /**
   *
   * @type {string}
   * @memberof PasscodeInfoResponse
   */
  recoveryEmail?: string;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const PasscodeTypeEnum = {
  _4Digit: '4-digit',
  _6Digit: '6-digit',
  Alphanumeric: 'alphanumeric',
} as const;

export type PasscodeTypeEnum =
  typeof PasscodeTypeEnum[keyof typeof PasscodeTypeEnum];

/**
 *
 * @export
 * @interface RemovePasscodeRequest
 */
export interface RemovePasscodeRequest {
  /**
   *
   * @type {string}
   * @memberof RemovePasscodeRequest
   */
  passcode: string;
}
/**
 *
 * @export
 * @interface RequestCodeEmailRequest
 */
export interface RequestCodeEmailRequest {
  /**
   *
   * @type {string}
   * @memberof RequestCodeEmailRequest
   */
  email?: string;
  /**
   *
   * @type {EmailCodeReasonEnum}
   * @memberof RequestCodeEmailRequest
   */
  reason: EmailCodeReasonEnum;
}
/**
 *
 * @export
 * @interface SaveRecoveryKeyRequest
 */
export interface SaveRecoveryKeyRequest {
  /**
   *
   * @type {string}
   * @memberof SaveRecoveryKeyRequest
   */
  scwAddressId: string;
  /**
   *
   * @type {string}
   * @memberof SaveRecoveryKeyRequest
   */
  recoveryKey: string;
  /**
   *
   * @type {string}
   * @memberof SaveRecoveryKeyRequest
   */
  recoveryIv: string;
}
/**
 *
 * @export
 * @interface UpdatePasscodeRequest
 */
export interface UpdatePasscodeRequest {
  /**
   *
   * @type {PasscodeTypeEnum}
   * @memberof UpdatePasscodeRequest
   */
  newPasscodeType: PasscodeTypeEnum;
  /**
   *
   * @type {string}
   * @memberof UpdatePasscodeRequest
   */
  newPasscode?: string;
  /**
   *
   * @type {string}
   * @memberof UpdatePasscodeRequest
   */
  passcode?: string;
  /**
   *
   * @type {string}
   * @memberof UpdatePasscodeRequest
   */
  emailCode?: string;
}
/**
 *
 * @export
 * @interface UpdatePasscodeSettingsRequest
 */
export interface UpdatePasscodeSettingsRequest {
  /**
   *
   * @type {string}
   * @memberof UpdatePasscodeSettingsRequest
   */
  passcode: string;
  /**
   *
   * @type {number}
   * @memberof UpdatePasscodeSettingsRequest
   */
  unlockDuration?: number;
  /**
   *
   * @type {boolean}
   * @memberof UpdatePasscodeSettingsRequest
   */
  requiredOnOpen?: boolean;
}
/**
 *
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
  /**
   *
   * @type {Array<string>}
   * @memberof ValidationError
   */
  loc: Array<string>;
  /**
   *
   * @type {string}
   * @memberof ValidationError
   */
  msg: string;
  /**
   *
   * @type {string}
   * @memberof ValidationError
   */
  type: string;
}
/**
 *
 * @export
 * @interface VerifyPasscodeRequest
 */
export interface VerifyPasscodeRequest {
  /**
   *
   * @type {string}
   * @memberof VerifyPasscodeRequest
   */
  passcode?: string;
}

/**
 * PasscodeApi - axios parameter creator
 * @export
 */
export const PasscodeApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Create or re-activate passcode
     * @summary Create Passcode
     * @param {CreatePasscodeRequest} createPasscodeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPasscode: async (
      createPasscodeRequest: CreatePasscodeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createPasscodeRequest' is not null or undefined
      assertParamExists(
        'createPasscode',
        'createPasscodeRequest',
        createPasscodeRequest,
      );
      const localVarPath = `/passcode/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication APIKeyHeader required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createPasscodeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Passcode Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPasscodeInfo: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/passcode/info`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication APIKeyHeader required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Remove Passcode
     * @param {RemovePasscodeRequest} removePasscodeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removePasscode: async (
      removePasscodeRequest: RemovePasscodeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'removePasscodeRequest' is not null or undefined
      assertParamExists(
        'removePasscode',
        'removePasscodeRequest',
        removePasscodeRequest,
      );
      const localVarPath = `/passcode/remove`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication APIKeyHeader required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        removePasscodeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Request Passcode Change
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestPasscodeChange: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/passcode/request-change`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication APIKeyHeader required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update active passcode
     * @summary Update Passcode
     * @param {UpdatePasscodeRequest} updatePasscodeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePasscode: async (
      updatePasscodeRequest: UpdatePasscodeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updatePasscodeRequest' is not null or undefined
      assertParamExists(
        'updatePasscode',
        'updatePasscodeRequest',
        updatePasscodeRequest,
      );
      const localVarPath = `/passcode/update`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication APIKeyHeader required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updatePasscodeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update Passcode Settings
     * @param {UpdatePasscodeSettingsRequest} updatePasscodeSettingsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePasscodeSettings: async (
      updatePasscodeSettingsRequest: UpdatePasscodeSettingsRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updatePasscodeSettingsRequest' is not null or undefined
      assertParamExists(
        'updatePasscodeSettings',
        'updatePasscodeSettingsRequest',
        updatePasscodeSettingsRequest,
      );
      const localVarPath = `/passcode/update/settings`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication APIKeyHeader required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updatePasscodeSettingsRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Verify Passcode
     * @param {VerifyPasscodeRequest} verifyPasscodeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyPasscode: async (
      verifyPasscodeRequest: VerifyPasscodeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'verifyPasscodeRequest' is not null or undefined
      assertParamExists(
        'verifyPasscode',
        'verifyPasscodeRequest',
        verifyPasscodeRequest,
      );
      const localVarPath = `/passcode/verify`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication APIKeyHeader required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        verifyPasscodeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PasscodeApi - functional programming interface
 * @export
 */
export const PasscodeApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PasscodeApiAxiosParamCreator(configuration);
  return {
    /**
     * Create or re-activate passcode
     * @summary Create Passcode
     * @param {CreatePasscodeRequest} createPasscodeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPasscode(
      createPasscodeRequest: CreatePasscodeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CodedResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createPasscode(
        createPasscodeRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Get Passcode Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPasscodeInfo(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PasscodeInfoResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPasscodeInfo(
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Remove Passcode
     * @param {RemovePasscodeRequest} removePasscodeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removePasscode(
      removePasscodeRequest: RemovePasscodeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CodedResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removePasscode(
        removePasscodeRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Request Passcode Change
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async requestPasscodeChange(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CodedResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.requestPasscodeChange(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Update active passcode
     * @summary Update Passcode
     * @param {UpdatePasscodeRequest} updatePasscodeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePasscode(
      updatePasscodeRequest: UpdatePasscodeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CodedResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatePasscode(
        updatePasscodeRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Update Passcode Settings
     * @param {UpdatePasscodeSettingsRequest} updatePasscodeSettingsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePasscodeSettings(
      updatePasscodeSettingsRequest: UpdatePasscodeSettingsRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CodedResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updatePasscodeSettings(
          updatePasscodeSettingsRequest,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Verify Passcode
     * @param {VerifyPasscodeRequest} verifyPasscodeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verifyPasscode(
      verifyPasscodeRequest: VerifyPasscodeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CodedResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.verifyPasscode(
        verifyPasscodeRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * PasscodeApi - factory interface
 * @export
 */
export const PasscodeApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = PasscodeApiFp(configuration);
  return {
    /**
     * Create or re-activate passcode
     * @summary Create Passcode
     * @param {CreatePasscodeRequest} createPasscodeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPasscode(
      createPasscodeRequest: CreatePasscodeRequest,
      options?: any,
    ): AxiosPromise<CodedResponse> {
      return localVarFp
        .createPasscode(createPasscodeRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Passcode Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPasscodeInfo(options?: any): AxiosPromise<PasscodeInfoResponse> {
      return localVarFp
        .getPasscodeInfo(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Remove Passcode
     * @param {RemovePasscodeRequest} removePasscodeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removePasscode(
      removePasscodeRequest: RemovePasscodeRequest,
      options?: any,
    ): AxiosPromise<CodedResponse> {
      return localVarFp
        .removePasscode(removePasscodeRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Request Passcode Change
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestPasscodeChange(options?: any): AxiosPromise<CodedResponse> {
      return localVarFp
        .requestPasscodeChange(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update active passcode
     * @summary Update Passcode
     * @param {UpdatePasscodeRequest} updatePasscodeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePasscode(
      updatePasscodeRequest: UpdatePasscodeRequest,
      options?: any,
    ): AxiosPromise<CodedResponse> {
      return localVarFp
        .updatePasscode(updatePasscodeRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update Passcode Settings
     * @param {UpdatePasscodeSettingsRequest} updatePasscodeSettingsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePasscodeSettings(
      updatePasscodeSettingsRequest: UpdatePasscodeSettingsRequest,
      options?: any,
    ): AxiosPromise<CodedResponse> {
      return localVarFp
        .updatePasscodeSettings(updatePasscodeSettingsRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Verify Passcode
     * @param {VerifyPasscodeRequest} verifyPasscodeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyPasscode(
      verifyPasscodeRequest: VerifyPasscodeRequest,
      options?: any,
    ): AxiosPromise<CodedResponse> {
      return localVarFp
        .verifyPasscode(verifyPasscodeRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * PasscodeApi - object-oriented interface
 * @export
 * @class PasscodeApi
 * @extends {BaseAPI}
 */
export class PasscodeApi extends BaseAPI {
  /**
   * Create or re-activate passcode
   * @summary Create Passcode
   * @param {CreatePasscodeRequest} createPasscodeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PasscodeApi
   */
  public createPasscode(
    createPasscodeRequest: CreatePasscodeRequest,
    options?: AxiosRequestConfig,
  ) {
    return PasscodeApiFp(this.configuration)
      .createPasscode(createPasscodeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Passcode Info
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PasscodeApi
   */
  public getPasscodeInfo(options?: AxiosRequestConfig) {
    return PasscodeApiFp(this.configuration)
      .getPasscodeInfo(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Remove Passcode
   * @param {RemovePasscodeRequest} removePasscodeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PasscodeApi
   */
  public removePasscode(
    removePasscodeRequest: RemovePasscodeRequest,
    options?: AxiosRequestConfig,
  ) {
    return PasscodeApiFp(this.configuration)
      .removePasscode(removePasscodeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Request Passcode Change
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PasscodeApi
   */
  public requestPasscodeChange(options?: AxiosRequestConfig) {
    return PasscodeApiFp(this.configuration)
      .requestPasscodeChange(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update active passcode
   * @summary Update Passcode
   * @param {UpdatePasscodeRequest} updatePasscodeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PasscodeApi
   */
  public updatePasscode(
    updatePasscodeRequest: UpdatePasscodeRequest,
    options?: AxiosRequestConfig,
  ) {
    return PasscodeApiFp(this.configuration)
      .updatePasscode(updatePasscodeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update Passcode Settings
   * @param {UpdatePasscodeSettingsRequest} updatePasscodeSettingsRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PasscodeApi
   */
  public updatePasscodeSettings(
    updatePasscodeSettingsRequest: UpdatePasscodeSettingsRequest,
    options?: AxiosRequestConfig,
  ) {
    return PasscodeApiFp(this.configuration)
      .updatePasscodeSettings(updatePasscodeSettingsRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Verify Passcode
   * @param {VerifyPasscodeRequest} verifyPasscodeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PasscodeApi
   */
  public verifyPasscode(
    verifyPasscodeRequest: VerifyPasscodeRequest,
    options?: AxiosRequestConfig,
  ) {
    return PasscodeApiFp(this.configuration)
      .verifyPasscode(verifyPasscodeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * RecoveryEmailApi - axios parameter creator
 * @export
 */
export const RecoveryEmailApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Change Recovery Email
     * @param {ChangeEmailRequest} changeEmailRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeRecoveryEmail: async (
      changeEmailRequest: ChangeEmailRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'changeEmailRequest' is not null or undefined
      assertParamExists(
        'changeRecoveryEmail',
        'changeEmailRequest',
        changeEmailRequest,
      );
      const localVarPath = `/recovery-email/change`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication APIKeyHeader required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        changeEmailRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Check Email Code
     * @param {CheckCodeEmailRequest} checkCodeEmailRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkEmailCode: async (
      checkCodeEmailRequest: CheckCodeEmailRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'checkCodeEmailRequest' is not null or undefined
      assertParamExists(
        'checkEmailCode',
        'checkCodeEmailRequest',
        checkCodeEmailRequest,
      );
      const localVarPath = `/recovery-email/check-code`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication APIKeyHeader required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        checkCodeEmailRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create recovery email
     * @summary Create Recovery Email
     * @param {CreateEmailRequest} createEmailRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRecoveryEmail: async (
      createEmailRequest: CreateEmailRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createEmailRequest' is not null or undefined
      assertParamExists(
        'createRecoveryEmail',
        'createEmailRequest',
        createEmailRequest,
      );
      const localVarPath = `/recovery-email/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication APIKeyHeader required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createEmailRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Recovery Email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecoveryEmail: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/recovery-email/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication APIKeyHeader required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Request Email Code
     * @param {RequestCodeEmailRequest} requestCodeEmailRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestEmailCode: async (
      requestCodeEmailRequest: RequestCodeEmailRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestCodeEmailRequest' is not null or undefined
      assertParamExists(
        'requestEmailCode',
        'requestCodeEmailRequest',
        requestCodeEmailRequest,
      );
      const localVarPath = `/recovery-email/request-code`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication APIKeyHeader required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestCodeEmailRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RecoveryEmailApi - functional programming interface
 * @export
 */
export const RecoveryEmailApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    RecoveryEmailApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Change Recovery Email
     * @param {ChangeEmailRequest} changeEmailRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async changeRecoveryEmail(
      changeEmailRequest: ChangeEmailRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CodedResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.changeRecoveryEmail(
          changeEmailRequest,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Check Email Code
     * @param {CheckCodeEmailRequest} checkCodeEmailRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async checkEmailCode(
      checkCodeEmailRequest: CheckCodeEmailRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CodedResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.checkEmailCode(
        checkCodeEmailRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Create recovery email
     * @summary Create Recovery Email
     * @param {CreateEmailRequest} createEmailRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRecoveryEmail(
      createEmailRequest: CreateEmailRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CodedResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createRecoveryEmail(
          createEmailRequest,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Get Recovery Email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRecoveryEmail(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRecoveryEmail(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Request Email Code
     * @param {RequestCodeEmailRequest} requestCodeEmailRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async requestEmailCode(
      requestCodeEmailRequest: RequestCodeEmailRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CodedResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.requestEmailCode(
          requestCodeEmailRequest,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * RecoveryEmailApi - factory interface
 * @export
 */
export const RecoveryEmailApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = RecoveryEmailApiFp(configuration);
  return {
    /**
     *
     * @summary Change Recovery Email
     * @param {ChangeEmailRequest} changeEmailRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeRecoveryEmail(
      changeEmailRequest: ChangeEmailRequest,
      options?: any,
    ): AxiosPromise<CodedResponse> {
      return localVarFp
        .changeRecoveryEmail(changeEmailRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Check Email Code
     * @param {CheckCodeEmailRequest} checkCodeEmailRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkEmailCode(
      checkCodeEmailRequest: CheckCodeEmailRequest,
      options?: any,
    ): AxiosPromise<CodedResponse> {
      return localVarFp
        .checkEmailCode(checkCodeEmailRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create recovery email
     * @summary Create Recovery Email
     * @param {CreateEmailRequest} createEmailRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRecoveryEmail(
      createEmailRequest: CreateEmailRequest,
      options?: any,
    ): AxiosPromise<CodedResponse> {
      return localVarFp
        .createRecoveryEmail(createEmailRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Recovery Email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecoveryEmail(options?: any): AxiosPromise<EmailResponse> {
      return localVarFp
        .getRecoveryEmail(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Request Email Code
     * @param {RequestCodeEmailRequest} requestCodeEmailRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestEmailCode(
      requestCodeEmailRequest: RequestCodeEmailRequest,
      options?: any,
    ): AxiosPromise<CodedResponse> {
      return localVarFp
        .requestEmailCode(requestCodeEmailRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * RecoveryEmailApi - object-oriented interface
 * @export
 * @class RecoveryEmailApi
 * @extends {BaseAPI}
 */
export class RecoveryEmailApi extends BaseAPI {
  /**
   *
   * @summary Change Recovery Email
   * @param {ChangeEmailRequest} changeEmailRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecoveryEmailApi
   */
  public changeRecoveryEmail(
    changeEmailRequest: ChangeEmailRequest,
    options?: AxiosRequestConfig,
  ) {
    return RecoveryEmailApiFp(this.configuration)
      .changeRecoveryEmail(changeEmailRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Check Email Code
   * @param {CheckCodeEmailRequest} checkCodeEmailRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecoveryEmailApi
   */
  public checkEmailCode(
    checkCodeEmailRequest: CheckCodeEmailRequest,
    options?: AxiosRequestConfig,
  ) {
    return RecoveryEmailApiFp(this.configuration)
      .checkEmailCode(checkCodeEmailRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create recovery email
   * @summary Create Recovery Email
   * @param {CreateEmailRequest} createEmailRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecoveryEmailApi
   */
  public createRecoveryEmail(
    createEmailRequest: CreateEmailRequest,
    options?: AxiosRequestConfig,
  ) {
    return RecoveryEmailApiFp(this.configuration)
      .createRecoveryEmail(createEmailRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Recovery Email
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecoveryEmailApi
   */
  public getRecoveryEmail(options?: AxiosRequestConfig) {
    return RecoveryEmailApiFp(this.configuration)
      .getRecoveryEmail(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Request Email Code
   * @param {RequestCodeEmailRequest} requestCodeEmailRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecoveryEmailApi
   */
  public requestEmailCode(
    requestCodeEmailRequest: RequestCodeEmailRequest,
    options?: AxiosRequestConfig,
  ) {
    return RecoveryEmailApiFp(this.configuration)
      .requestEmailCode(requestCodeEmailRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * RecoveryKeysApi - axios parameter creator
 * @export
 */
export const RecoveryKeysApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Get Recovery Key
     * @param {GetRecoveryKeyRequest} getRecoveryKeyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecoveryKey: async (
      getRecoveryKeyRequest: GetRecoveryKeyRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getRecoveryKeyRequest' is not null or undefined
      assertParamExists(
        'getRecoveryKey',
        'getRecoveryKeyRequest',
        getRecoveryKeyRequest,
      );
      const localVarPath = `/recovery-keys/recover`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication APIKeyHeader required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getRecoveryKeyRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Save recovery key
     * @summary Save Recovery Key
     * @param {SaveRecoveryKeyRequest} saveRecoveryKeyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveRecoveryKey: async (
      saveRecoveryKeyRequest: SaveRecoveryKeyRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'saveRecoveryKeyRequest' is not null or undefined
      assertParamExists(
        'saveRecoveryKey',
        'saveRecoveryKeyRequest',
        saveRecoveryKeyRequest,
      );
      const localVarPath = `/recovery-keys/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication APIKeyHeader required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        saveRecoveryKeyRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RecoveryKeysApi - functional programming interface
 * @export
 */
export const RecoveryKeysApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    RecoveryKeysApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Get Recovery Key
     * @param {GetRecoveryKeyRequest} getRecoveryKeyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRecoveryKey(
      getRecoveryKeyRequest: GetRecoveryKeyRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GetRecoveryKeyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRecoveryKey(
        getRecoveryKeyRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Save recovery key
     * @summary Save Recovery Key
     * @param {SaveRecoveryKeyRequest} saveRecoveryKeyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async saveRecoveryKey(
      saveRecoveryKeyRequest: SaveRecoveryKeyRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CodedResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.saveRecoveryKey(
        saveRecoveryKeyRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * RecoveryKeysApi - factory interface
 * @export
 */
export const RecoveryKeysApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = RecoveryKeysApiFp(configuration);
  return {
    /**
     *
     * @summary Get Recovery Key
     * @param {GetRecoveryKeyRequest} getRecoveryKeyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecoveryKey(
      getRecoveryKeyRequest: GetRecoveryKeyRequest,
      options?: any,
    ): AxiosPromise<GetRecoveryKeyResponse> {
      return localVarFp
        .getRecoveryKey(getRecoveryKeyRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Save recovery key
     * @summary Save Recovery Key
     * @param {SaveRecoveryKeyRequest} saveRecoveryKeyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveRecoveryKey(
      saveRecoveryKeyRequest: SaveRecoveryKeyRequest,
      options?: any,
    ): AxiosPromise<CodedResponse> {
      return localVarFp
        .saveRecoveryKey(saveRecoveryKeyRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * RecoveryKeysApi - object-oriented interface
 * @export
 * @class RecoveryKeysApi
 * @extends {BaseAPI}
 */
export class RecoveryKeysApi extends BaseAPI {
  /**
   *
   * @summary Get Recovery Key
   * @param {GetRecoveryKeyRequest} getRecoveryKeyRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecoveryKeysApi
   */
  public getRecoveryKey(
    getRecoveryKeyRequest: GetRecoveryKeyRequest,
    options?: AxiosRequestConfig,
  ) {
    return RecoveryKeysApiFp(this.configuration)
      .getRecoveryKey(getRecoveryKeyRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Save recovery key
   * @summary Save Recovery Key
   * @param {SaveRecoveryKeyRequest} saveRecoveryKeyRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecoveryKeysApi
   */
  public saveRecoveryKey(
    saveRecoveryKeyRequest: SaveRecoveryKeyRequest,
    options?: AxiosRequestConfig,
  ) {
    return RecoveryKeysApiFp(this.configuration)
      .saveRecoveryKey(saveRecoveryKeyRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * StatusApi - axios parameter creator
 * @export
 */
export const StatusApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Get Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatus: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/status/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * StatusApi - functional programming interface
 * @export
 */
export const StatusApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = StatusApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Get Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStatus(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CodedResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStatus(
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * StatusApi - factory interface
 * @export
 */
export const StatusApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = StatusApiFp(configuration);
  return {
    /**
     *
     * @summary Get Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatus(options?: any): AxiosPromise<CodedResponse> {
      return localVarFp
        .getStatus(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
export class StatusApi extends BaseAPI {
  /**
   *
   * @summary Get Status
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatusApi
   */
  public getStatus(options?: AxiosRequestConfig) {
    return StatusApiFp(this.configuration)
      .getStatus(options)
      .then((request) => request(this.axios, this.basePath));
  }
}
