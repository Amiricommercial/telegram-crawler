/* tslint:disable */
/* eslint-disable */
/**
 * Telegram Integration API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccessToken
 */
export interface AccessToken {
    /**
     * 
     * @type {number}
     * @memberof AccessToken
     */
    'user_id': number;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    'value': string;
    /**
     * 
     * @type {boolean}
     * @memberof AccessToken
     */
    'is_first_time': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AccessToken
     */
    'is_new_user': boolean;
    /**
     * 
     * @type {FiatCurrency}
     * @memberof AccessToken
     */
    'local_currency': FiatCurrency;
    /**
     * 
     * @type {number}
     * @memberof AccessToken
     */
    'available_balance_total_fiat_amount': number;
    /**
     * 
     * @type {FiatCurrency}
     * @memberof AccessToken
     */
    'available_balance_total_fiat_currency': FiatCurrency;
    /**
     * 
     * @type {Array<UserAccount>}
     * @memberof AccessToken
     */
    'accounts': Array<UserAccount>;
    /**
     * 
     * @type {FeatureFlags}
     * @memberof AccessToken
     */
    'feature_flags': FeatureFlags;
    /**
     * 
     * @type {Permission}
     * @memberof AccessToken
     */
    'permissions': Permission;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    'bot_language': string;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    'bot_username': string;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    'country_alpha2_ip'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    'country_alpha2_phone'?: string;
    /**
     * 
     * @type {XpsProxyServiceMockTgIntegrationApiV1UsersDtoGift}
     * @memberof AccessToken
     */
    'gift'?: XpsProxyServiceMockTgIntegrationApiV1UsersDtoGift;
    /**
     * 
     * @type {CampaignParticipation}
     * @memberof AccessToken
     */
    'campaign_participation'?: CampaignParticipation;
    /**
     * 
     * @type {XpsProxyServiceMockTgIntegrationApiV1UsersDtoWVSettings}
     * @memberof AccessToken
     */
    'wv_settings': XpsProxyServiceMockTgIntegrationApiV1UsersDtoWVSettings;
    /**
     * 
     * @type {boolean}
     * @memberof AccessToken
     */
    'has_available_cashback_binance': boolean;
    /**
     * 
     * @type {number}
     * @memberof AccessToken
     */
    'binance_bonus'?: number;
}
/**
 * 
 * @export
 * @interface AccessTokenQuery
 */
export interface AccessTokenQuery {
    /**
     * 
     * @type {string}
     * @memberof AccessTokenQuery
     */
    'web_view_init_data_raw': string;
}
/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'total_balance': number;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'available_balance': number;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'hold': number;
    /**
     * 
     * @type {boolean}
     * @memberof Account
     */
    'has_transactions': boolean;
}
/**
 * 
 * @export
 * @interface AccountsData
 */
export interface AccountsData {
    /**
     * 
     * @type {number}
     * @memberof AccountsData
     */
    'available_balance_total_fiat_amount': number;
    /**
     * 
     * @type {FiatCurrency}
     * @memberof AccountsData
     */
    'available_balance_total_fiat_currency': FiatCurrency;
    /**
     * 
     * @type {Array<UserAccount>}
     * @memberof AccountsData
     */
    'accounts': Array<UserAccount>;
}
/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'network': string;
}
/**
 * 
 * @export
 * @interface AmountInterval
 */
export interface AmountInterval {
    /**
     * 
     * @type {number}
     * @memberof AmountInterval
     */
    'amount_min': number;
    /**
     * 
     * @type {number}
     * @memberof AmountInterval
     */
    'amount_max'?: number;
    /**
     * 
     * @type {FrontendCryptoCurrencyEnum}
     * @memberof AmountInterval
     */
    'currency': FrontendCryptoCurrencyEnum;
}
/**
 * 
 * @export
 * @interface AmountIntervalQuery
 */
export interface AmountIntervalQuery {
    /**
     * 
     * @type {FrontendCryptoCurrencyEnum}
     * @memberof AmountIntervalQuery
     */
    'from_currency': FrontendCryptoCurrencyEnum;
    /**
     * 
     * @type {FrontendCryptoCurrencyEnum}
     * @memberof AmountIntervalQuery
     */
    'to_currency': FrontendCryptoCurrencyEnum;
}
/**
 * 
 * @export
 * @interface ApiError
 */
export interface ApiError {
    /**
     * 
     * @type {number | string}
     * @memberof ApiError
     */
    'code': number | string;
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    'detail': string;
}
/**
 * 
 * @export
 * @interface AuthTokenRequest
 */
export interface AuthTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthTokenRequest
     */
    'client_id': string;
    /**
     * 
     * @type {Array<ClientScopes>}
     * @memberof AuthTokenRequest
     */
    'scopes': Array<ClientScopes>;
}
/**
 * 
 * @export
 * @interface AuthTokenResponse
 */
export interface AuthTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof AuthTokenResponse
     */
    'jwt': string;
}
/**
 * 
 * @export
 * @interface BoolResponse
 */
export interface BoolResponse {
    /**
     * 
     * @type {boolean}
     * @memberof BoolResponse
     */
    'value': boolean;
}
/**
 * 
 * @export
 * @interface BoolResult
 */
export interface BoolResult {
    /**
     * 
     * @type {boolean}
     * @memberof BoolResult
     */
    'value': boolean;
}
/**
 * 
 * @export
 * @interface BooleanResponse
 */
export interface BooleanResponse {
    /**
     * 
     * @type {boolean}
     * @memberof BooleanResponse
     */
    'value': boolean;
}
/**
 * 
 * @export
 * @interface BotKycPollingQuery
 */
export interface BotKycPollingQuery {
    /**
     * 
     * @type {string}
     * @memberof BotKycPollingQuery
     */
    'btn_kyc_success_url': string;
    /**
     * 
     * @type {string}
     * @memberof BotKycPollingQuery
     */
    'btn_kyc_success_text': string;
    /**
     * 
     * @type {string}
     * @memberof BotKycPollingQuery
     */
    'btn_kyc_retry_url': string;
    /**
     * 
     * @type {string}
     * @memberof BotKycPollingQuery
     */
    'purchase_id'?: string;
}
/**
 * 
 * @export
 * @interface BotKycPollingRequest
 */
export interface BotKycPollingRequest {
    /**
     * 
     * @type {number}
     * @memberof BotKycPollingRequest
     */
    'purchase_internal_id': number;
    /**
     * 
     * @type {string}
     * @memberof BotKycPollingRequest
     */
    'btn_kyc_success_url': string;
    /**
     * 
     * @type {string}
     * @memberof BotKycPollingRequest
     */
    'btn_kyc_success_text': string;
    /**
     * 
     * @type {string}
     * @memberof BotKycPollingRequest
     */
    'btn_kyc_retry_url': string;
}
/**
 * 
 * @export
 * @interface CampaignParticipation
 */
export interface CampaignParticipation {
    /**
     * 
     * @type {number}
     * @memberof CampaignParticipation
     */
    'wave_number': number;
    /**
     * 
     * @type {boolean}
     * @memberof CampaignParticipation
     */
    'is_last_wave': boolean;
    /**
     * 
     * @type {string}
     * @memberof CampaignParticipation
     */
    'campaign_end_date': string;
    /**
     * 
     * @type {number}
     * @memberof CampaignParticipation
     */
    'share_gift_count': number;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const CardPayoutTypeEnum = {
    MasterProcessing: 'master_processing',
    Checkout: 'checkout'
} as const;

export type CardPayoutTypeEnum = typeof CardPayoutTypeEnum[keyof typeof CardPayoutTypeEnum];


/**
 * 
 * @export
 * @interface Cheque
 */
export interface Cheque {
    /**
     * 
     * @type {number}
     * @memberof Cheque
     */
    'cheque_id': number;
    /**
     * 
     * @type {number}
     * @memberof Cheque
     */
    'amount_of_one_cheque': number;
    /**
     * 
     * @type {number}
     * @memberof Cheque
     */
    'total_amount': number;
    /**
     * 
     * @type {CryptoCurrency}
     * @memberof Cheque
     */
    'currency': CryptoCurrency;
    /**
     * 
     * @type {number}
     * @memberof Cheque
     */
    'number_of_cheques': number;
    /**
     * 
     * @type {number}
     * @memberof Cheque
     */
    'number_of_used_cheques': number;
}
/**
 * 
 * @export
 * @interface ChequeRequest
 */
export interface ChequeRequest {
    /**
     * 
     * @type {number}
     * @memberof ChequeRequest
     */
    'amount_of_one_cheque': number;
    /**
     * 
     * @type {CryptoCurrency}
     * @memberof ChequeRequest
     */
    'currency': CryptoCurrency;
    /**
     * 
     * @type {number}
     * @memberof ChequeRequest
     */
    'number_of_cheques'?: number;
}
/**
 * 
 * @export
 * @interface ChequeRequestResponse
 */
export interface ChequeRequestResponse {
    /**
     * 
     * @type {number}
     * @memberof ChequeRequestResponse
     */
    'cheque_id': number;
    /**
     * 
     * @type {number}
     * @memberof ChequeRequestResponse
     */
    'amount_of_one_cheque': number;
    /**
     * 
     * @type {number}
     * @memberof ChequeRequestResponse
     */
    'total_amount': number;
    /**
     * 
     * @type {CryptoCurrency}
     * @memberof ChequeRequestResponse
     */
    'currency': CryptoCurrency;
    /**
     * 
     * @type {number}
     * @memberof ChequeRequestResponse
     */
    'number_of_cheques': number;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const ClientScopes = {
    ProfileRead: 'profile_read',
    MessagesSend: 'messages_send'
} as const;

export type ClientScopes = typeof ClientScopes[keyof typeof ClientScopes];


/**
 * 
 * @export
 * @interface ConvertQuery
 */
export interface ConvertQuery {
    /**
     * 
     * @type {number}
     * @memberof ConvertQuery
     */
    'from_amount'?: number;
    /**
     * 
     * @type {FrontendCryptoCurrencyEnum}
     * @memberof ConvertQuery
     */
    'from_currency': FrontendCryptoCurrencyEnum;
    /**
     * 
     * @type {number}
     * @memberof ConvertQuery
     */
    'to_amount'?: number;
    /**
     * 
     * @type {FrontendCryptoCurrencyEnum}
     * @memberof ConvertQuery
     */
    'to_currency': FrontendCryptoCurrencyEnum;
}
/**
 * 
 * @export
 * @interface ConvertResult
 */
export interface ConvertResult {
    /**
     * 
     * @type {number}
     * @memberof ConvertResult
     */
    'from_amount': number;
    /**
     * 
     * @type {FrontendCryptoCurrencyEnum}
     * @memberof ConvertResult
     */
    'from_currency': FrontendCryptoCurrencyEnum;
    /**
     * 
     * @type {number}
     * @memberof ConvertResult
     */
    'to_amount': number;
    /**
     * 
     * @type {FrontendCryptoCurrencyEnum}
     * @memberof ConvertResult
     */
    'to_currency': FrontendCryptoCurrencyEnum;
    /**
     * 
     * @type {number}
     * @memberof ConvertResult
     */
    'rate': number;
}
/**
 * 
 * @export
 * @interface CreatePurchase
 */
export interface CreatePurchase {
    /**
     * 
     * @type {number}
     * @memberof CreatePurchase
     */
    'purchase_internal_id': number;
    /**
     * 
     * @type {PurchaseExtraData}
     * @memberof CreatePurchase
     */
    'extra_data'?: PurchaseExtraData;
}
/**
 * 
 * @export
 * @interface CreatePurchaseResponse
 */
export interface CreatePurchaseResponse {
    /**
     * 
     * @type {number}
     * @memberof CreatePurchaseResponse
     */
    'purchase_internal_id': number;
    /**
     * 
     * @type {string}
     * @memberof CreatePurchaseResponse
     */
    'purchase_external_id': string;
    /**
     * 
     * @type {number}
     * @memberof CreatePurchaseResponse
     */
    'crypto_amount': number;
    /**
     * 
     * @type {FrontendCryptoCurrencyEnum}
     * @memberof CreatePurchaseResponse
     */
    'crypto_currency': FrontendCryptoCurrencyEnum;
    /**
     * 
     * @type {number}
     * @memberof CreatePurchaseResponse
     */
    'fiat_amount': number;
    /**
     * 
     * @type {FiatCurrency}
     * @memberof CreatePurchaseResponse
     */
    'fiat_currency': FiatCurrency;
    /**
     * 
     * @type {string}
     * @memberof CreatePurchaseResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof CreatePurchaseResponse
     */
    'payment_url': string;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const CryptoCurrency = {
    Btc: 'BTC',
    Bch: 'BCH',
    Ton: 'TON',
    Usdt: 'USDT',
    UsdtTrc20: 'USDT_TRC20',
    Trx: 'TRX'
} as const;

export type CryptoCurrency = typeof CryptoCurrency[keyof typeof CryptoCurrency];


/**
 * 
 * @export
 * @interface CryptocurrencyTransferLimits
 */
export interface CryptocurrencyTransferLimits {
    /**
     * 
     * @type {number}
     * @memberof CryptocurrencyTransferLimits
     */
    'min_limit': number;
    /**
     * 
     * @type {number}
     * @memberof CryptocurrencyTransferLimits
     */
    'max_limit': number;
}
/**
 * 
 * @export
 * @interface Currencies
 */
export interface Currencies {
    /**
     * 
     * @type {Array<FiatCurrency>}
     * @memberof Currencies
     */
    'list': Array<FiatCurrency>;
    /**
     * 
     * @type {Array<CurrencyAvailabilityFlags>}
     * @memberof Currencies
     */
    'availability_flags': Array<CurrencyAvailabilityFlags>;
}
/**
 * 
 * @export
 * @interface CurrencyAmount
 */
export interface CurrencyAmount {
    /**
     * 
     * @type {number}
     * @memberof CurrencyAmount
     */
    'amount': number;
    /**
     * 
     * @type {CurrencyEnum}
     * @memberof CurrencyAmount
     */
    'currency': CurrencyEnum;
}
/**
 * 
 * @export
 * @interface CurrencyAvailabilityFlags
 */
export interface CurrencyAvailabilityFlags {
    /**
     * 
     * @type {FiatCurrency}
     * @memberof CurrencyAvailabilityFlags
     */
    'currency': FiatCurrency;
    /**
     * 
     * @type {boolean}
     * @memberof CurrencyAvailabilityFlags
     */
    'is_available': boolean;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const CurrencyEnum = {
    Usd: 'USD',
    Eur: 'EUR',
    Rub: 'RUB',
    Gbp: 'GBP',
    Uah: 'UAH',
    Kzt: 'KZT',
    Byn: 'BYN',
    Krw: 'KRW',
    Ils: 'ILS',
    Idr: 'IDR',
    Aed: 'AED',
    Gel: 'GEL',
    Twd: 'TWD',
    Try: 'TRY',
    Hkd: 'HKD',
    Inr: 'INR',
    Cad: 'CAD',
    Amd: 'AMD',
    Aud: 'AUD',
    Pln: 'PLN',
    Cop: 'COP',
    Brl: 'BRL',
    Chf: 'CHF',
    Mxn: 'MXN',
    Ars: 'ARS',
    Sgd: 'SGD',
    Sar: 'SAR',
    Mdl: 'MDL',
    Jpy: 'JPY',
    Ron: 'RON',
    Sek: 'SEK',
    Azn: 'AZN',
    Rsd: 'RSD',
    Nok: 'NOK',
    Myr: 'MYR',
    Bgn: 'BGN',
    Egp: 'EGP',
    Gtq: 'GTQ',
    Clp: 'CLP',
    Nzd: 'NZD',
    Bdt: 'BDT',
    Kgs: 'KGS',
    Thb: 'THB',
    Uzs: 'UZS',
    Vnd: 'VND',
    Btc: 'BTC',
    Bch: 'BCH',
    Ton: 'TON',
    Usdt: 'USDT',
    UsdtTrc20: 'USDT_TRC20',
    Trx: 'TRX'
} as const;

export type CurrencyEnum = typeof CurrencyEnum[keyof typeof CurrencyEnum];


/**
 * 
 * @export
 * @interface CurrencyLimits
 */
export interface CurrencyLimits {
    /**
     * 
     * @type {number}
     * @memberof CurrencyLimits
     */
    'min_amount': number;
    /**
     * 
     * @type {number}
     * @memberof CurrencyLimits
     */
    'max_amount': number;
}
/**
 * 
 * @export
 * @interface CurrencySettingsUnit
 */
export interface CurrencySettingsUnit {
    /**
     * 
     * @type {CurrencyEnum}
     * @memberof CurrencySettingsUnit
     */
    'currency': CurrencyEnum;
    /**
     * 
     * @type {number}
     * @memberof CurrencySettingsUnit
     */
    'default_value'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof CurrencySettingsUnit
     */
    'preset_values'?: Array<number>;
}
/**
 * 
 * @export
 * @interface EstimatePrice
 */
export interface EstimatePrice {
    /**
     * 
     * @type {number}
     * @memberof EstimatePrice
     */
    'requested_amount': number;
    /**
     * 
     * @type {CurrencyEnum}
     * @memberof EstimatePrice
     */
    'requested_currency': CurrencyEnum;
    /**
     * 
     * @type {number}
     * @memberof EstimatePrice
     */
    'payable_amount': number;
    /**
     * 
     * @type {CurrencyEnum}
     * @memberof EstimatePrice
     */
    'payable_currency': CurrencyEnum;
}
/**
 * 
 * @export
 * @interface EstimatePriceRequest
 */
export interface EstimatePriceRequest {
    /**
     * 
     * @type {CurrencyEnum}
     * @memberof EstimatePriceRequest
     */
    'base_currency': CurrencyEnum;
    /**
     * 
     * @type {number}
     * @memberof EstimatePriceRequest
     */
    'base_amount': number;
    /**
     * 
     * @type {CurrencyEnum}
     * @memberof EstimatePriceRequest
     */
    'secondary_currency': CurrencyEnum;
    /**
     * 
     * @type {PaymentMethodEnum}
     * @memberof EstimatePriceRequest
     */
    'payment_method': PaymentMethodEnum;
}
/**
 * 
 * @export
 * @interface Exchange
 */
export interface Exchange {
    /**
     * 
     * @type {string}
     * @memberof Exchange
     */
    'uid': string;
    /**
     * 
     * @type {number}
     * @memberof Exchange
     */
    'ttl': number;
    /**
     * 
     * @type {number}
     * @memberof Exchange
     */
    'from_amount': number;
    /**
     * 
     * @type {number}
     * @memberof Exchange
     */
    'from_balance_after': number;
    /**
     * 
     * @type {FrontendCryptoCurrencyEnum}
     * @memberof Exchange
     */
    'from_currency': FrontendCryptoCurrencyEnum;
    /**
     * 
     * @type {number}
     * @memberof Exchange
     */
    'to_amount': number;
    /**
     * 
     * @type {number}
     * @memberof Exchange
     */
    'to_balance_after': number;
    /**
     * 
     * @type {FrontendCryptoCurrencyEnum}
     * @memberof Exchange
     */
    'to_currency': FrontendCryptoCurrencyEnum;
    /**
     * 
     * @type {number}
     * @memberof Exchange
     */
    'from_fiat_amount'?: number;
    /**
     * 
     * @type {FiatCurrency}
     * @memberof Exchange
     */
    'from_fiat_currency'?: FiatCurrency;
    /**
     * 
     * @type {number}
     * @memberof Exchange
     */
    'to_fiat_amount'?: number;
    /**
     * 
     * @type {FiatCurrency}
     * @memberof Exchange
     */
    'to_fiat_currency'?: FiatCurrency;
    /**
     * 
     * @type {number}
     * @memberof Exchange
     */
    'rate': number;
    /**
     * 
     * @type {number}
     * @memberof Exchange
     */
    'fee_amount': number;
    /**
     * 
     * @type {CryptoCurrency}
     * @memberof Exchange
     */
    'fee_currency': CryptoCurrency;
}
/**
 * 
 * @export
 * @interface ExchangeQuery
 */
export interface ExchangeQuery {
    /**
     * 
     * @type {number}
     * @memberof ExchangeQuery
     */
    'from_amount': number;
    /**
     * 
     * @type {FrontendCryptoCurrencyEnum}
     * @memberof ExchangeQuery
     */
    'from_currency': FrontendCryptoCurrencyEnum;
    /**
     * 
     * @type {FrontendCryptoCurrencyEnum}
     * @memberof ExchangeQuery
     */
    'to_currency': FrontendCryptoCurrencyEnum;
    /**
     * 
     * @type {FiatCurrency}
     * @memberof ExchangeQuery
     */
    'local_currency': FiatCurrency;
}
/**
 * 
 * @export
 * @interface ExchangeResult
 */
export interface ExchangeResult {
    /**
     * 
     * @type {number}
     * @memberof ExchangeResult
     */
    'transaction_id': number;
}
/**
 * 
 * @export
 * @interface FeatureFlags
 */
export interface FeatureFlags {
    /**
     * 
     * @type {boolean}
     * @memberof FeatureFlags
     */
    'binance_deposit': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FeatureFlags
     */
    'tg_payments': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FeatureFlags
     */
    'rcards': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FeatureFlags
     */
    'wpay_as_payer': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FeatureFlags
     */
    'wpay_as_merchant': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FeatureFlags
     */
    'multicurrency': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FeatureFlags
     */
    'usdt_raffle': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FeatureFlags
     */
    'scw': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FeatureFlags
     */
    'passcode': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FeatureFlags
     */
    'p2p_express': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FeatureFlags
     */
    'collectibles': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FeatureFlags
     */
    'scw_beta_waitlist': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FeatureFlags
     */
    'kyc': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FeatureFlags
     */
    'usdt_transfer': boolean;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const FiatCurrency = {
    Usd: 'USD',
    Eur: 'EUR',
    Rub: 'RUB',
    Gbp: 'GBP',
    Uah: 'UAH',
    Kzt: 'KZT',
    Byn: 'BYN',
    Krw: 'KRW',
    Ils: 'ILS',
    Idr: 'IDR',
    Aed: 'AED',
    Gel: 'GEL',
    Twd: 'TWD',
    Try: 'TRY',
    Hkd: 'HKD',
    Inr: 'INR',
    Cad: 'CAD',
    Amd: 'AMD',
    Aud: 'AUD',
    Pln: 'PLN',
    Cop: 'COP',
    Brl: 'BRL',
    Chf: 'CHF',
    Mxn: 'MXN',
    Ars: 'ARS',
    Sgd: 'SGD',
    Sar: 'SAR',
    Mdl: 'MDL',
    Jpy: 'JPY',
    Ron: 'RON',
    Sek: 'SEK',
    Azn: 'AZN',
    Rsd: 'RSD',
    Nok: 'NOK',
    Myr: 'MYR',
    Bgn: 'BGN',
    Egp: 'EGP',
    Gtq: 'GTQ',
    Clp: 'CLP',
    Nzd: 'NZD',
    Bdt: 'BDT',
    Kgs: 'KGS',
    Thb: 'THB',
    Uzs: 'UZS',
    Vnd: 'VND'
} as const;

export type FiatCurrency = typeof FiatCurrency[keyof typeof FiatCurrency];


/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const FrontendCryptoCurrencyEnum = {
    Btc: 'BTC',
    Ton: 'TON',
    Usdt: 'USDT'
} as const;

export type FrontendCryptoCurrencyEnum = typeof FrontendCryptoCurrencyEnum[keyof typeof FrontendCryptoCurrencyEnum];


/**
 * 
 * @export
 * @interface GetSavedUserExtraDataRequest
 */
export interface GetSavedUserExtraDataRequest {
    /**
     * 
     * @type {PaymentProviderEnum}
     * @memberof GetSavedUserExtraDataRequest
     */
    'payment_provider_type': PaymentProviderEnum;
}
/**
 * 
 * @export
 * @interface GetSavedUserExtraDataResponse
 */
export interface GetSavedUserExtraDataResponse {
    /**
     * 
     * @type {object}
     * @memberof GetSavedUserExtraDataResponse
     */
    'extra_data'?: object;
}
/**
 * 
 * @export
 * @interface GetUserProfileResponse
 */
export interface GetUserProfileResponse {
    /**
     * 
     * @type {number}
     * @memberof GetUserProfileResponse
     */
    'telegram_id': number;
    /**
     * 
     * @type {string}
     * @memberof GetUserProfileResponse
     */
    'telegram_username'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetUserProfileResponse
     */
    'language': string;
    /**
     * 
     * @type {boolean}
     * @memberof GetUserProfileResponse
     */
    'can_message': boolean;
}
/**
 * 
 * @export
 * @interface GiftCount
 */
export interface GiftCount {
    /**
     * 
     * @type {number}
     * @memberof GiftCount
     */
    'count': number;
    /**
     * 
     * @type {CurrencyEnum}
     * @memberof GiftCount
     */
    'currency': CurrencyEnum;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const GiftStatusEnum = {
    Sent: 'sent',
    Opened: 'opened',
    Canceled: 'canceled',
    Rejected: 'rejected'
} as const;

export type GiftStatusEnum = typeof GiftStatusEnum[keyof typeof GiftStatusEnum];


/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const GiftTypeEnum = {
    Primary: 'primary',
    Share: 'share'
} as const;

export type GiftTypeEnum = typeof GiftTypeEnum[keyof typeof GiftTypeEnum];


/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface InitPurchase
 */
export interface InitPurchase {
    /**
     * 
     * @type {CurrencyEnum}
     * @memberof InitPurchase
     */
    'base_currency': CurrencyEnum;
    /**
     * 
     * @type {number}
     * @memberof InitPurchase
     */
    'base_amount': number;
    /**
     * 
     * @type {CurrencyEnum}
     * @memberof InitPurchase
     */
    'secondary_currency': CurrencyEnum;
    /**
     * 
     * @type {string}
     * @memberof InitPurchase
     */
    'success_return_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof InitPurchase
     */
    'failure_return_url'?: string;
}
/**
 * 
 * @export
 * @interface InitPurchaseResponse
 */
export interface InitPurchaseResponse {
    /**
     * 
     * @type {number}
     * @memberof InitPurchaseResponse
     */
    'purchase_internal_id': number;
    /**
     * 
     * @type {string}
     * @memberof InitPurchaseResponse
     */
    'purchase_external_id': string;
    /**
     * 
     * @type {number}
     * @memberof InitPurchaseResponse
     */
    'crypto_amount': number;
    /**
     * 
     * @type {FrontendCryptoCurrencyEnum}
     * @memberof InitPurchaseResponse
     */
    'crypto_currency': FrontendCryptoCurrencyEnum;
    /**
     * 
     * @type {number}
     * @memberof InitPurchaseResponse
     */
    'fiat_amount': number;
    /**
     * 
     * @type {FiatCurrency}
     * @memberof InitPurchaseResponse
     */
    'fiat_currency': FiatCurrency;
    /**
     * 
     * @type {string}
     * @memberof InitPurchaseResponse
     */
    'draft_at': string;
    /**
     * 
     * @type {PaymentProviderEnum}
     * @memberof InitPurchaseResponse
     */
    'payment_provider': PaymentProviderEnum;
}
/**
 * 
 * @export
 * @interface Language
 */
export interface Language {
    /**
     * 
     * @type {string}
     * @memberof Language
     */
    'language': string;
}
/**
 * 
 * @export
 * @interface Languages
 */
export interface Languages {
    /**
     * 
     * @type {string}
     * @memberof Languages
     */
    'language_name': string;
    /**
     * 
     * @type {string}
     * @memberof Languages
     */
    'language_code': string;
    /**
     * 
     * @type {string}
     * @memberof Languages
     */
    'translation': string;
}
/**
 * 
 * @export
 * @interface LocalCurrency
 */
export interface LocalCurrency {
    /**
     * 
     * @type {CurrencyEnum}
     * @memberof LocalCurrency
     */
    'local_currency': CurrencyEnum;
}
/**
 * 
 * @export
 * @interface PaymentMethodAvailability
 */
export interface PaymentMethodAvailability {
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethodAvailability
     */
    'is_available': boolean;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodAvailability
     */
    'reason_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodAvailability
     */
    'reason_description'?: string;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const PaymentMethodEnum = {
    CardDefault: 'card_default',
    Binance: 'binance'
} as const;

export type PaymentMethodEnum = typeof PaymentMethodEnum[keyof typeof PaymentMethodEnum];


/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const PaymentProviderEnum = {
    Forbidden: 'forbidden',
    Neocrypto: 'neocrypto',
    Mercuryo: 'mercuryo',
    ForkEpos: 'fork_epos',
    ForkBinance: 'fork_binance',
    ForkSmartGlocal: 'fork_smart_glocal',
    ForkMasterProcessing: 'fork_master_processing',
    ForkCheckout: 'fork_checkout',
    ForkPaylama: 'fork_paylama',
    ForkPayassist: 'fork_payassist'
} as const;

export type PaymentProviderEnum = typeof PaymentProviderEnum[keyof typeof PaymentProviderEnum];


/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const PaymentStatusEnum = {
    Pending: 'pending',
    Success: 'success',
    Fail: 'fail'
} as const;

export type PaymentStatusEnum = typeof PaymentStatusEnum[keyof typeof PaymentStatusEnum];


/**
 * 
 * @export
 * @interface Permission
 */
export interface Permission {
    /**
     * 
     * @type {boolean}
     * @memberof Permission
     */
    'can_top_up': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Permission
     */
    'can_exchange': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Permission
     */
    'can_withdraw_inner': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Permission
     */
    'can_withdraw_outer': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Permission
     */
    'can_use_wpay_as_payer': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Permission
     */
    'can_use_wpay_as_merchant': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Permission
     */
    'can_usdt_raffle': boolean;
}
/**
 * 
 * @export
 * @interface Price
 */
export interface Price {
    /**
     * 
     * @type {number}
     * @memberof Price
     */
    'rate': number;
    /**
     * 
     * @type {number}
     * @memberof Price
     */
    'price': number;
    /**
     * 
     * @type {FrontendCryptoCurrencyEnum}
     * @memberof Price
     */
    'currency_from': FrontendCryptoCurrencyEnum;
    /**
     * 
     * @type {FiatCurrency}
     * @memberof Price
     */
    'currency_to': FiatCurrency;
    /**
     * 
     * @type {number}
     * @memberof Price
     */
    'amount_from': number;
}
/**
 * 
 * @export
 * @interface PurchaseExtraData
 */
export interface PurchaseExtraData {
    /**
     * 
     * @type {object}
     * @memberof PurchaseExtraData
     */
    'data': object;
    /**
     * 
     * @type {boolean}
     * @memberof PurchaseExtraData
     */
    'save': boolean;
}
/**
 * 
 * @export
 * @interface PurchaseInfoResponse
 */
export interface PurchaseInfoResponse {
    /**
     * 
     * @type {number}
     * @memberof PurchaseInfoResponse
     */
    'purchase_id': number;
    /**
     * 
     * @type {number}
     * @memberof PurchaseInfoResponse
     */
    'buy_amount': number;
    /**
     * 
     * @type {CurrencyEnum}
     * @memberof PurchaseInfoResponse
     */
    'buy_currency': CurrencyEnum;
    /**
     * 
     * @type {number}
     * @memberof PurchaseInfoResponse
     */
    'pay_amount': number;
    /**
     * 
     * @type {CurrencyEnum}
     * @memberof PurchaseInfoResponse
     */
    'pay_currency': CurrencyEnum;
    /**
     * 
     * @type {string}
     * @memberof PurchaseInfoResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseInfoResponse
     */
    'completed_at'?: string;
    /**
     * 
     * @type {PaymentStatusEnum}
     * @memberof PurchaseInfoResponse
     */
    'status': PaymentStatusEnum;
}
/**
 * 
 * @export
 * @interface RedirectPurchase
 */
export interface RedirectPurchase {
    /**
     * 
     * @type {FrontendCryptoCurrencyEnum}
     * @memberof RedirectPurchase
     */
    'crypto_currency': FrontendCryptoCurrencyEnum;
    /**
     * 
     * @type {number}
     * @memberof RedirectPurchase
     */
    'crypto_amount': number;
}
/**
 * 
 * @export
 * @interface RegistrationData
 */
export interface RegistrationData {
    /**
     * 
     * @type {object}
     * @memberof RegistrationData
     */
    'user': object;
    /**
     * 
     * @type {string}
     * @memberof RegistrationData
     */
    'start_param': string;
}
/**
 * 
 * @export
 * @interface RegistrationResult
 */
export interface RegistrationResult {
    /**
     * 
     * @type {RegistrationStatusEnum}
     * @memberof RegistrationResult
     */
    'status': RegistrationStatusEnum;
    /**
     * 
     * @type {UserData}
     * @memberof RegistrationResult
     */
    'user': UserData;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const RegistrationStatusEnum = {
    Success: 'success',
    Already: 'already'
} as const;

export type RegistrationStatusEnum = typeof RegistrationStatusEnum[keyof typeof RegistrationStatusEnum];


/**
 * 
 * @export
 * @interface RequestTransferRequest
 */
export interface RequestTransferRequest {
    /**
     * 
     * @type {number}
     * @memberof RequestTransferRequest
     */
    'amount': number;
    /**
     * 
     * @type {FrontendCryptoCurrencyEnum}
     * @memberof RequestTransferRequest
     */
    'currency': FrontendCryptoCurrencyEnum;
}
/**
 * 
 * @export
 * @interface ReturnTransactions
 */
export interface ReturnTransactions {
    /**
     * 
     * @type {Array<Transaction>}
     * @memberof ReturnTransactions
     */
    'transactions': Array<Transaction>;
    /**
     * 
     * @type {number}
     * @memberof ReturnTransactions
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof ReturnTransactions
     */
    'offset': number;
    /**
     * 
     * @type {number}
     * @memberof ReturnTransactions
     */
    'size': number;
}
/**
 * 
 * @export
 * @interface RuBankCardPurchase
 */
export interface RuBankCardPurchase {
    /**
     * 
     * @type {FiatCurrency}
     * @memberof RuBankCardPurchase
     */
    'fiat_currency': FiatCurrency;
    /**
     * 
     * @type {FrontendCryptoCurrencyEnum}
     * @memberof RuBankCardPurchase
     */
    'crypto_currency': FrontendCryptoCurrencyEnum;
}
/**
 * 
 * @export
 * @interface SuccessResponse
 */
export interface SuccessResponse {
    /**
     * 
     * @type {boolean}
     * @memberof SuccessResponse
     */
    'success': boolean;
}
/**
 * 
 * @export
 * @interface TelegramPaymentResponse
 */
export interface TelegramPaymentResponse {
    /**
     * 
     * @type {number}
     * @memberof TelegramPaymentResponse
     */
    'purchase_id': number;
    /**
     * 
     * @type {string}
     * @memberof TelegramPaymentResponse
     */
    'payment_url': string;
    /**
     * 
     * @type {string}
     * @memberof TelegramPaymentResponse
     */
    'payment_id': string;
    /**
     * 
     * @type {number}
     * @memberof TelegramPaymentResponse
     */
    'amount': number;
    /**
     * 
     * @type {number}
     * @memberof TelegramPaymentResponse
     */
    'pay_amount': number;
    /**
     * 
     * @type {CurrencyEnum}
     * @memberof TelegramPaymentResponse
     */
    'pay_currency': CurrencyEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegramPaymentResponse
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface TgTransferWithdrawPayload
 */
export interface TgTransferWithdrawPayload {
    /**
     * 
     * @type {number}
     * @memberof TgTransferWithdrawPayload
     */
    'sum': number;
    /**
     * 
     * @type {CurrencyEnum}
     * @memberof TgTransferWithdrawPayload
     */
    'currency': CurrencyEnum;
    /**
     * 
     * @type {number}
     * @memberof TgTransferWithdrawPayload
     */
    'tg_transfer_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof TgTransferWithdrawPayload
     */
    'recipient_tg_id': number;
    /**
     * 
     * @type {WithdrawSourceEnum}
     * @memberof TgTransferWithdrawPayload
     */
    'withdraw_source': WithdrawSourceEnum;
}
/**
 * 
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * 
     * @type {number}
     * @memberof Transaction
     */
    'id': number;
    /**
     * 
     * @type {TransactionTypeEnum}
     * @memberof Transaction
     */
    'type': TransactionTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'created_at': string;
    /**
     * 
     * @type {number}
     * @memberof Transaction
     */
    'amount': number;
    /**
     * 
     * @type {CurrencyEnum}
     * @memberof Transaction
     */
    'currency': CurrencyEnum;
    /**
     * 
     * @type {TransactionStatusEnum}
     * @memberof Transaction
     */
    'status': TransactionStatusEnum;
    /**
     * 
     * @type {TransactionGateway}
     * @memberof Transaction
     */
    'gateway': TransactionGateway;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'username'?: string;
    /**
     * 
     * @type {number}
     * @memberof Transaction
     */
    'tg_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'mention'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'input_addresses'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'recipient_wallet_address'?: string;
    /**
     * 
     * @type {number}
     * @memberof Transaction
     */
    'activated_amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Transaction
     */
    'remaining_amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'purchase_external_id'?: string;
    /**
     * 
     * @type {GiftTypeEnum}
     * @memberof Transaction
     */
    'gift_type'?: GiftTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'photo_url'?: string;
    /**
     * 
     * @type {WPayListDetails}
     * @memberof Transaction
     */
    'details_for_user'?: WPayListDetails;
    /**
     * 
     * @type {number}
     * @memberof Transaction
     */
    'pair_transaction_amount'?: number;
    /**
     * 
     * @type {CurrencyEnum}
     * @memberof Transaction
     */
    'pair_transaction_currency'?: CurrencyEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Transaction
     */
    'is_blocked': boolean;
    /**
     * 
     * @type {TransactionBlockKycRequired | TransactionBlockDummy}
     * @memberof Transaction
     */
    'block': TransactionBlockKycRequired | TransactionBlockDummy;
    /**
     * 
     * @type {boolean}
     * @memberof Transaction
     */
    'is_cancellable': boolean;
}
/**
 * 
 * @export
 * @interface TransactionBlockDummy
 */
export interface TransactionBlockDummy {
    /**
     * 
     * @type {string}
     * @memberof TransactionBlockDummy
     */
    'type': TransactionBlockDummyTypeEnum;
}

export const TransactionBlockDummyTypeEnum = {
    Dummy: 'dummy'
} as const;

export type TransactionBlockDummyTypeEnum = typeof TransactionBlockDummyTypeEnum[keyof typeof TransactionBlockDummyTypeEnum];

/**
 * 
 * @export
 * @interface TransactionBlockKycRequired
 */
export interface TransactionBlockKycRequired {
    /**
     * 
     * @type {string}
     * @memberof TransactionBlockKycRequired
     */
    'type': TransactionBlockKycRequiredTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TransactionBlockKycRequired
     */
    'kyc_level': string;
}

export const TransactionBlockKycRequiredTypeEnum = {
    KycRequired: 'kyc_required'
} as const;

export type TransactionBlockKycRequiredTypeEnum = typeof TransactionBlockKycRequiredTypeEnum[keyof typeof TransactionBlockKycRequiredTypeEnum];

/**
 * 
 * @export
 * @interface TransactionDetails
 */
export interface TransactionDetails {
    /**
     * 
     * @type {number}
     * @memberof TransactionDetails
     */
    'id': number;
    /**
     * 
     * @type {TransactionTypeEnum}
     * @memberof TransactionDetails
     */
    'type': TransactionTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TransactionDetails
     */
    'created_at': string;
    /**
     * 
     * @type {number}
     * @memberof TransactionDetails
     */
    'crypto_amount': number;
    /**
     * 
     * @type {number}
     * @memberof TransactionDetails
     */
    'fiat_amount'?: number;
    /**
     * 
     * @type {FrontendCryptoCurrencyEnum}
     * @memberof TransactionDetails
     */
    'crypto_currency': FrontendCryptoCurrencyEnum;
    /**
     * 
     * @type {FiatCurrency}
     * @memberof TransactionDetails
     */
    'fiat_currency'?: FiatCurrency;
    /**
     * 
     * @type {number}
     * @memberof TransactionDetails
     */
    'value_at_time'?: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionDetails
     */
    'username'?: string;
    /**
     * 
     * @type {number}
     * @memberof TransactionDetails
     */
    'tg_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionDetails
     */
    'mention'?: string;
    /**
     * 
     * @type {TransactionStatusEnum}
     * @memberof TransactionDetails
     */
    'status': TransactionStatusEnum;
    /**
     * 
     * @type {TransactionGateway}
     * @memberof TransactionDetails
     */
    'gateway': TransactionGateway;
    /**
     * 
     * @type {string}
     * @memberof TransactionDetails
     */
    'input_addresses'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDetails
     */
    'recipient_wallet_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDetails
     */
    'transaction_link'?: string;
    /**
     * 
     * @type {number}
     * @memberof TransactionDetails
     */
    'full_number_of_activations'?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionDetails
     */
    'number_of_activations'?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionDetails
     */
    'amount_of_activations'?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionDetails
     */
    'remaining_amount'?: number;
    /**
     * 
     * @type {CryptoCurrency}
     * @memberof TransactionDetails
     */
    'fee_currency'?: CryptoCurrency;
    /**
     * 
     * @type {number}
     * @memberof TransactionDetails
     */
    'fee_amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionDetails
     */
    'activation_channel_title'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDetails
     */
    'activation_channel_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDetails
     */
    'check_url'?: string;
    /**
     * 
     * @type {GiftTypeEnum}
     * @memberof TransactionDetails
     */
    'gift_type'?: GiftTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TransactionDetails
     */
    'seller'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDetails
     */
    'buyer'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDetails
     */
    'avatar_code'?: string;
    /**
     * 
     * @type {number}
     * @memberof TransactionDetails
     */
    'entity_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionDetails
     */
    'photo_url'?: string;
    /**
     * 
     * @type {WPayDetails}
     * @memberof TransactionDetails
     */
    'details_for_user'?: WPayDetails;
    /**
     * 
     * @type {number}
     * @memberof TransactionDetails
     */
    'pair_transaction_amount'?: number;
    /**
     * 
     * @type {FrontendCryptoCurrencyEnum}
     * @memberof TransactionDetails
     */
    'pair_transaction_currency'?: FrontendCryptoCurrencyEnum;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionDetails
     */
    'is_blocked': boolean;
    /**
     * 
     * @type {TransactionBlockKycRequired | TransactionBlockDummy}
     * @memberof TransactionDetails
     */
    'block': TransactionBlockKycRequired | TransactionBlockDummy;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionDetails
     */
    'is_cancellable': boolean;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const TransactionGateway = {
    Card: 'card',
    Internal: 'internal',
    Btc: 'btc',
    Manual: 'manual',
    CryptoExchange: 'crypto_exchange',
    TgTransfer: 'tg_transfer',
    Binance: 'binance',
    Bonus: 'bonus',
    TopUp: 'top_up',
    WithdrawOnchain: 'withdraw_onchain',
    SingleUse: 'single_use',
    MultiUse: 'multi_use',
    PartMultiUse: 'part_multi_use',
    Campaign: 'campaign',
    P2pOrder: 'p2p_order',
    P2pOffer: 'p2p_offer',
    P2pRefund: 'p2p_refund',
    BinanceBonus: 'binance_bonus',
    WpayPayment: 'wpay_payment',
    WpayPayout: 'wpay_payout',
    Payouts: 'payouts',
    BonusAny: 'bonus_any'
} as const;

export type TransactionGateway = typeof TransactionGateway[keyof typeof TransactionGateway];


/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const TransactionStatusEnum = {
    Created: 'created',
    Pending: 'pending',
    Success: 'success',
    Fail: 'fail',
    New: 'new',
    Canceled: 'canceled',
    Void: 'void',
    PartiallyFilled: 'partially_filled',
    Filled: 'filled'
} as const;

export type TransactionStatusEnum = typeof TransactionStatusEnum[keyof typeof TransactionStatusEnum];


/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const TransactionTypeEnum = {
    Deposit: 'deposit',
    Withdraw: 'withdraw'
} as const;

export type TransactionTypeEnum = typeof TransactionTypeEnum[keyof typeof TransactionTypeEnum];


/**
 * 
 * @export
 * @interface TransferRequestResponse
 */
export interface TransferRequestResponse {
    /**
     * 
     * @type {string}
     * @memberof TransferRequestResponse
     */
    'transfer_request_id': string;
    /**
     * 
     * @type {string}
     * @memberof TransferRequestResponse
     */
    'transfer_type': string;
    /**
     * 
     * @type {number}
     * @memberof TransferRequestResponse
     */
    'amount_gross': number;
    /**
     * 
     * @type {FrontendCryptoCurrencyEnum}
     * @memberof TransferRequestResponse
     */
    'amount_gross_currency': FrontendCryptoCurrencyEnum;
    /**
     * 
     * @type {number}
     * @memberof TransferRequestResponse
     */
    'amount_net': number;
    /**
     * 
     * @type {FrontendCryptoCurrencyEnum}
     * @memberof TransferRequestResponse
     */
    'amount_net_currency': FrontendCryptoCurrencyEnum;
}
/**
 * 
 * @export
 * @interface TypeformAnswer
 */
export interface TypeformAnswer {
    /**
     * 
     * @type {string}
     * @memberof TypeformAnswer
     */
    'type': string;
    /**
     * 
     * @type {boolean}
     * @memberof TypeformAnswer
     */
    'boolean'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TypeformAnswer
     */
    'text'?: string;
    /**
     * 
     * @type {object}
     * @memberof TypeformAnswer
     */
    'choices'?: object;
    /**
     * 
     * @type {string}
     * @memberof TypeformAnswer
     */
    'date'?: string;
    /**
     * 
     * @type {string}
     * @memberof TypeformAnswer
     */
    'email'?: string;
    /**
     * 
     * @type {number}
     * @memberof TypeformAnswer
     */
    'number'?: number;
    /**
     * 
     * @type {string}
     * @memberof TypeformAnswer
     */
    'url'?: string;
    /**
     * 
     * @type {TypeformAnswerField}
     * @memberof TypeformAnswer
     */
    'field': TypeformAnswerField;
}
/**
 * 
 * @export
 * @interface TypeformAnswerField
 */
export interface TypeformAnswerField {
    /**
     * 
     * @type {string}
     * @memberof TypeformAnswerField
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TypeformAnswerField
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof TypeformAnswerField
     */
    'ref': string;
}
/**
 * 
 * @export
 * @interface TypeformCallback
 */
export interface TypeformCallback {
    /**
     * 
     * @type {string}
     * @memberof TypeformCallback
     */
    'event_id': string;
    /**
     * 
     * @type {string}
     * @memberof TypeformCallback
     */
    'event_type': string;
    /**
     * 
     * @type {TypeformFormResponse}
     * @memberof TypeformCallback
     */
    'form_response': TypeformFormResponse;
}
/**
 * 
 * @export
 * @interface TypeformDefinition
 */
export interface TypeformDefinition {
    /**
     * 
     * @type {string}
     * @memberof TypeformDefinition
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TypeformDefinition
     */
    'title': string;
    /**
     * 
     * @type {Array<TypeformField>}
     * @memberof TypeformDefinition
     */
    'fields': Array<TypeformField>;
    /**
     * 
     * @type {Array<object>}
     * @memberof TypeformDefinition
     */
    'endings': Array<object>;
}
/**
 * 
 * @export
 * @interface TypeformEnding
 */
export interface TypeformEnding {
    /**
     * 
     * @type {string}
     * @memberof TypeformEnding
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TypeformEnding
     */
    'ref': string;
}
/**
 * 
 * @export
 * @interface TypeformField
 */
export interface TypeformField {
    /**
     * 
     * @type {string}
     * @memberof TypeformField
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TypeformField
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof TypeformField
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof TypeformField
     */
    'ref': string;
    /**
     * 
     * @type {boolean}
     * @memberof TypeformField
     */
    'allow_multiple_selections'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TypeformField
     */
    'allow_other_choice'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof TypeformField
     */
    'properties'?: object;
}
/**
 * 
 * @export
 * @interface TypeformFormResponse
 */
export interface TypeformFormResponse {
    /**
     * 
     * @type {string}
     * @memberof TypeformFormResponse
     */
    'form_id': string;
    /**
     * 
     * @type {string}
     * @memberof TypeformFormResponse
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof TypeformFormResponse
     */
    'submitted_at': string;
    /**
     * 
     * @type {string}
     * @memberof TypeformFormResponse
     */
    'landed_at': string;
    /**
     * 
     * @type {object}
     * @memberof TypeformFormResponse
     */
    'calculated'?: object;
    /**
     * 
     * @type {Array<TypeformVariable>}
     * @memberof TypeformFormResponse
     */
    'variables'?: Array<TypeformVariable>;
    /**
     * 
     * @type {object}
     * @memberof TypeformFormResponse
     */
    'hidden'?: object;
    /**
     * 
     * @type {TypeformDefinition}
     * @memberof TypeformFormResponse
     */
    'definition': TypeformDefinition;
    /**
     * 
     * @type {Array<TypeformAnswer>}
     * @memberof TypeformFormResponse
     */
    'answers': Array<TypeformAnswer>;
    /**
     * 
     * @type {TypeformEnding}
     * @memberof TypeformFormResponse
     */
    'ending': TypeformEnding;
}
/**
 * 
 * @export
 * @interface TypeformVariable
 */
export interface TypeformVariable {
    /**
     * 
     * @type {string}
     * @memberof TypeformVariable
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof TypeformVariable
     */
    'type': string;
    /**
     * 
     * @type {boolean}
     * @memberof TypeformVariable
     */
    'boolean'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TypeformVariable
     */
    'text'?: string;
    /**
     * 
     * @type {object}
     * @memberof TypeformVariable
     */
    'choices'?: object;
    /**
     * 
     * @type {string}
     * @memberof TypeformVariable
     */
    'date'?: string;
    /**
     * 
     * @type {string}
     * @memberof TypeformVariable
     */
    'email'?: string;
    /**
     * 
     * @type {number}
     * @memberof TypeformVariable
     */
    'number'?: number;
    /**
     * 
     * @type {string}
     * @memberof TypeformVariable
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface UserAccount
 */
export interface UserAccount {
    /**
     * 
     * @type {CurrencyEnum}
     * @memberof UserAccount
     */
    'currency': CurrencyEnum;
    /**
     * 
     * @type {number}
     * @memberof UserAccount
     */
    'available_balance': number;
    /**
     * 
     * @type {number}
     * @memberof UserAccount
     */
    'available_balance_fiat_amount'?: number;
    /**
     * 
     * @type {FiatCurrency}
     * @memberof UserAccount
     */
    'available_balance_fiat_currency': FiatCurrency;
    /**
     * 
     * @type {boolean}
     * @memberof UserAccount
     */
    'has_transactions': boolean;
    /**
     * 
     * @type {Array<Address>}
     * @memberof UserAccount
     */
    'addresses': Array<Address>;
}
/**
 * 
 * @export
 * @interface UserCurrency
 */
export interface UserCurrency {
    /**
     * 
     * @type {FiatCurrency}
     * @memberof UserCurrency
     */
    'currency': FiatCurrency;
}
/**
 * 
 * @export
 * @interface UserData
 */
export interface UserData {
    /**
     * 
     * @type {number}
     * @memberof UserData
     */
    'tg_id': number;
}
/**
 * 
 * @export
 * @interface UserKycStatus
 */
export interface UserKycStatus {
    /**
     * 
     * @type {boolean}
     * @memberof UserKycStatus
     */
    'is_passed'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserKycStatus
     */
    'reject_status'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserKycStatus
     */
    'provider'?: string;
}
/**
 * 
 * @export
 * @interface UserKycStatusRequest
 */
export interface UserKycStatusRequest {
    /**
     * 
     * @type {number}
     * @memberof UserKycStatusRequest
     */
    'purchase_internal_id': number;
}
/**
 * 
 * @export
 * @interface UserKycStatusResponse
 */
export interface UserKycStatusResponse {
    /**
     * 
     * @type {boolean}
     * @memberof UserKycStatusResponse
     */
    'is_passed'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserKycStatusResponse
     */
    'reject_status'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserKycStatusResponse
     */
    'provider'?: string;
}
/**
 * 
 * @export
 * @interface UserKycUrl
 */
export interface UserKycUrl {
    /**
     * 
     * @type {string}
     * @memberof UserKycUrl
     */
    'kyc_url': string;
}
/**
 * 
 * @export
 * @interface UserKycUrlResponse
 */
export interface UserKycUrlResponse {
    /**
     * 
     * @type {string}
     * @memberof UserKycUrlResponse
     */
    'kyc_url': string;
}
/**
 * 
 * @export
 * @interface UserState
 */
export interface UserState {
    /**
     * 
     * @type {string}
     * @memberof UserState
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface ValidateAmountResult
 */
export interface ValidateAmountResult {
    /**
     * 
     * @type {ValidateAmountStatusEnum}
     * @memberof ValidateAmountResult
     */
    'status': ValidateAmountStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof ValidateAmountResult
     */
    'min_limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof ValidateAmountResult
     */
    'max_limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof ValidateAmountResult
     */
    'fee': number;
    /**
     * 
     * @type {number}
     * @memberof ValidateAmountResult
     */
    'need_to_buy'?: number;
    /**
     * 
     * @type {number}
     * @memberof ValidateAmountResult
     */
    'fixed_amount'?: number;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const ValidateAmountStatusEnum = {
    Ok: 'OK',
    MinLimitExceeded: 'MIN_LIMIT_EXCEEDED',
    MaxLimitExceeded: 'MAX_LIMIT_EXCEEDED',
    InsufficientFunds: 'INSUFFICIENT_FUNDS',
    InvalidAmount: 'INVALID_AMOUNT'
} as const;

export type ValidateAmountStatusEnum = typeof ValidateAmountStatusEnum[keyof typeof ValidateAmountStatusEnum];


/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<string>}
     * @memberof ValidationError
     */
    'loc': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface WPayDetails
 */
export interface WPayDetails {
    /**
     * 
     * @type {string}
     * @memberof WPayDetails
     */
    'store_name': string;
    /**
     * 
     * @type {string}
     * @memberof WPayDetails
     */
    'order_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof WPayDetails
     */
    'payout_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof WPayDetails
     */
    'store_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof WPayDetails
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof WPayDetails
     */
    'order_number'?: string;
}
/**
 * 
 * @export
 * @interface WPayListDetails
 */
export interface WPayListDetails {
    /**
     * 
     * @type {string}
     * @memberof WPayListDetails
     */
    'store_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof WPayListDetails
     */
    'store_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof WPayListDetails
     */
    'payout_id'?: string;
}
/**
 * 
 * @export
 * @interface WithdrawFee
 */
export interface WithdrawFee {
    /**
     * 
     * @type {number}
     * @memberof WithdrawFee
     */
    'amount': number;
    /**
     * 
     * @type {CryptoCurrency}
     * @memberof WithdrawFee
     */
    'currency': CryptoCurrency;
    /**
     * 
     * @type {number}
     * @memberof WithdrawFee
     */
    'fiat_amount': number;
    /**
     * 
     * @type {FiatCurrency}
     * @memberof WithdrawFee
     */
    'fiat_currency': FiatCurrency;
}
/**
 * 
 * @export
 * @interface WithdrawRequestData
 */
export interface WithdrawRequestData {
    /**
     * 
     * @type {string}
     * @memberof WithdrawRequestData
     */
    'uid': string;
    /**
     * 
     * @type {CurrencyAmount}
     * @memberof WithdrawRequestData
     */
    'sender_amount': CurrencyAmount;
    /**
     * 
     * @type {CurrencyAmount}
     * @memberof WithdrawRequestData
     */
    'recipient_amount': CurrencyAmount;
    /**
     * 
     * @type {WithdrawFee}
     * @memberof WithdrawRequestData
     */
    'fee': WithdrawFee;
    /**
     * 
     * @type {number}
     * @memberof WithdrawRequestData
     */
    'balance_after': number;
    /**
     * 
     * @type {Address}
     * @memberof WithdrawRequestData
     */
    'address': Address;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const WithdrawSourceEnum = {
    BonusScript: 'bonus_script',
    BotDialog: 'bot_dialog',
    WebView: 'web_view'
} as const;

export type WithdrawSourceEnum = typeof WithdrawSourceEnum[keyof typeof WithdrawSourceEnum];


/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const WithdrawStatusEnum = {
    New: 'new',
    Success: 'success',
    Filed: 'filed',
    PartiallySuccess: 'partially success',
    UnsupportedCardProvider: 'Unsupported card provider'
} as const;

export type WithdrawStatusEnum = typeof WithdrawStatusEnum[keyof typeof WithdrawStatusEnum];


/**
 * 
 * @export
 * @interface WithdrawalRequestResult
 */
export interface WithdrawalRequestResult {
    /**
     * 
     * @type {number}
     * @memberof WithdrawalRequestResult
     */
    'transaction_id': number;
}
/**
 * 
 * @export
 * @interface XpsProxyServiceMockTgIntegrationApiV1CampaignsDtoGift
 */
export interface XpsProxyServiceMockTgIntegrationApiV1CampaignsDtoGift {
    /**
     * 
     * @type {number}
     * @memberof XpsProxyServiceMockTgIntegrationApiV1CampaignsDtoGift
     */
    'amount': number;
    /**
     * 
     * @type {CurrencyEnum}
     * @memberof XpsProxyServiceMockTgIntegrationApiV1CampaignsDtoGift
     */
    'currency': CurrencyEnum;
    /**
     * 
     * @type {GiftStatusEnum}
     * @memberof XpsProxyServiceMockTgIntegrationApiV1CampaignsDtoGift
     */
    'status': GiftStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof XpsProxyServiceMockTgIntegrationApiV1CampaignsDtoGift
     */
    'share_gift_count': number;
}
/**
 * 
 * @export
 * @interface XpsProxyServiceMockTgIntegrationApiV1PurchasesKycDtoUserKycUrlRequest
 */
export interface XpsProxyServiceMockTgIntegrationApiV1PurchasesKycDtoUserKycUrlRequest {
    /**
     * 
     * @type {number}
     * @memberof XpsProxyServiceMockTgIntegrationApiV1PurchasesKycDtoUserKycUrlRequest
     */
    'purchase_internal_id': number;
    /**
     * 
     * @type {string}
     * @memberof XpsProxyServiceMockTgIntegrationApiV1PurchasesKycDtoUserKycUrlRequest
     */
    'postmessage_target'?: string;
    /**
     * 
     * @type {string}
     * @memberof XpsProxyServiceMockTgIntegrationApiV1PurchasesKycDtoUserKycUrlRequest
     */
    'custom_body_class'?: string;
    /**
     * 
     * @type {string}
     * @memberof XpsProxyServiceMockTgIntegrationApiV1PurchasesKycDtoUserKycUrlRequest
     */
    'custom_css_url'?: string;
}
/**
 * 
 * @export
 * @interface XpsProxyServiceMockTgIntegrationApiV1SettingsDtoWVSettings
 */
export interface XpsProxyServiceMockTgIntegrationApiV1SettingsDtoWVSettings {
    /**
     * 
     * @type {boolean}
     * @memberof XpsProxyServiceMockTgIntegrationApiV1SettingsDtoWVSettings
     */
    'display_ru_card_option'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof XpsProxyServiceMockTgIntegrationApiV1SettingsDtoWVSettings
     */
    'display_ru_card_restriction'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof XpsProxyServiceMockTgIntegrationApiV1SettingsDtoWVSettings
     */
    'display_share_gift_is_over'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof XpsProxyServiceMockTgIntegrationApiV1SettingsDtoWVSettings
     */
    'display_what_are_dollars'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof XpsProxyServiceMockTgIntegrationApiV1SettingsDtoWVSettings
     */
    'display_scw'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof XpsProxyServiceMockTgIntegrationApiV1SettingsDtoWVSettings
     */
    'p2p_onboarding_completed'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof XpsProxyServiceMockTgIntegrationApiV1SettingsDtoWVSettings
     */
    'p2p_usdt_info_hidden'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof XpsProxyServiceMockTgIntegrationApiV1SettingsDtoWVSettings
     */
    'has_scw_address'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof XpsProxyServiceMockTgIntegrationApiV1SettingsDtoWVSettings
     */
    'expand_cryptocurrency'?: boolean;
}
/**
 * 
 * @export
 * @interface XpsProxyServiceMockTgIntegrationApiV1UsersDtoGift
 */
export interface XpsProxyServiceMockTgIntegrationApiV1UsersDtoGift {
    /**
     * 
     * @type {number}
     * @memberof XpsProxyServiceMockTgIntegrationApiV1UsersDtoGift
     */
    'amount': number;
    /**
     * 
     * @type {CurrencyEnum}
     * @memberof XpsProxyServiceMockTgIntegrationApiV1UsersDtoGift
     */
    'currency': CurrencyEnum;
    /**
     * 
     * @type {GiftStatusEnum}
     * @memberof XpsProxyServiceMockTgIntegrationApiV1UsersDtoGift
     */
    'status': GiftStatusEnum;
}
/**
 * 
 * @export
 * @interface XpsProxyServiceMockTgIntegrationApiV1UsersDtoUserKycUrlRequest
 */
export interface XpsProxyServiceMockTgIntegrationApiV1UsersDtoUserKycUrlRequest {
    /**
     * 
     * @type {string}
     * @memberof XpsProxyServiceMockTgIntegrationApiV1UsersDtoUserKycUrlRequest
     */
    'purchase_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof XpsProxyServiceMockTgIntegrationApiV1UsersDtoUserKycUrlRequest
     */
    'postmessage_target'?: string;
    /**
     * 
     * @type {string}
     * @memberof XpsProxyServiceMockTgIntegrationApiV1UsersDtoUserKycUrlRequest
     */
    'custom_body_class'?: string;
    /**
     * 
     * @type {string}
     * @memberof XpsProxyServiceMockTgIntegrationApiV1UsersDtoUserKycUrlRequest
     */
    'custom_css_url'?: string;
}
/**
 * 
 * @export
 * @interface XpsProxyServiceMockTgIntegrationApiV1UsersDtoWVSettings
 */
export interface XpsProxyServiceMockTgIntegrationApiV1UsersDtoWVSettings {
    /**
     * 
     * @type {boolean}
     * @memberof XpsProxyServiceMockTgIntegrationApiV1UsersDtoWVSettings
     */
    'display_ru_card_option': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof XpsProxyServiceMockTgIntegrationApiV1UsersDtoWVSettings
     */
    'display_ru_card_restriction': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof XpsProxyServiceMockTgIntegrationApiV1UsersDtoWVSettings
     */
    'display_share_gift_is_over': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof XpsProxyServiceMockTgIntegrationApiV1UsersDtoWVSettings
     */
    'display_what_are_dollars': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof XpsProxyServiceMockTgIntegrationApiV1UsersDtoWVSettings
     */
    'display_scw': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof XpsProxyServiceMockTgIntegrationApiV1UsersDtoWVSettings
     */
    'p2p_onboarding_completed': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof XpsProxyServiceMockTgIntegrationApiV1UsersDtoWVSettings
     */
    'p2p_usdt_info_hidden': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof XpsProxyServiceMockTgIntegrationApiV1UsersDtoWVSettings
     */
    'has_scw_address': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof XpsProxyServiceMockTgIntegrationApiV1UsersDtoWVSettings
     */
    'expand_cryptocurrency': boolean;
}
/**
 * 
 * @export
 * @interface XpsProxyServiceMockTgIntegrationApiV1UsersDtoWalletAddress
 */
export interface XpsProxyServiceMockTgIntegrationApiV1UsersDtoWalletAddress {
    /**
     * 
     * @type {string}
     * @memberof XpsProxyServiceMockTgIntegrationApiV1UsersDtoWalletAddress
     */
    'address': string;
    /**
     * 
     * @type {boolean}
     * @memberof XpsProxyServiceMockTgIntegrationApiV1UsersDtoWalletAddress
     */
    'is_wallet_created': boolean;
}
/**
 * 
 * @export
 * @interface XpsProxyServiceMockTgIntegrationApiV1WalletsDtoWalletAddress
 */
export interface XpsProxyServiceMockTgIntegrationApiV1WalletsDtoWalletAddress {
    /**
     * 
     * @type {string}
     * @memberof XpsProxyServiceMockTgIntegrationApiV1WalletsDtoWalletAddress
     */
    'address': string;
    /**
     * 
     * @type {FrontendCryptoCurrencyEnum}
     * @memberof XpsProxyServiceMockTgIntegrationApiV1WalletsDtoWalletAddress
     */
    'currency': FrontendCryptoCurrencyEnum;
}

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Accounts Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsData: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/accounts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Account
         * @param {FrontendCryptoCurrencyEnum} cryptoCurrency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: async (cryptoCurrency: FrontendCryptoCurrencyEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cryptoCurrency' is not null or undefined
            assertParamExists('getAccount', 'cryptoCurrency', cryptoCurrency)
            const localVarPath = `/api/v1/accounts/{crypto_currency}/`
                .replace(`{${"crypto_currency"}}`, encodeURIComponent(String(cryptoCurrency)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Accounts Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsData(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsData(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Account
         * @param {FrontendCryptoCurrencyEnum} cryptoCurrency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccount(cryptoCurrency: FrontendCryptoCurrencyEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(cryptoCurrency, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * 
         * @summary Accounts Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsData(options?: any): AxiosPromise<AccountsData> {
            return localVarFp.accountsData(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Account
         * @param {FrontendCryptoCurrencyEnum} cryptoCurrency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(cryptoCurrency: FrontendCryptoCurrencyEnum, options?: any): AxiosPromise<Account> {
            return localVarFp.getAccount(cryptoCurrency, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * 
     * @summary Accounts Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsData(options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsData(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Account
     * @param {FrontendCryptoCurrencyEnum} cryptoCurrency 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccount(cryptoCurrency: FrontendCryptoCurrencyEnum, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccount(cryptoCurrency, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BinancePaymentsApi - axios parameter creator
 * @export
 */
export const BinancePaymentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Purchase With Binance Payments
         * @param {CreatePurchase} createPurchase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPurchaseWithBinancePayments: async (createPurchase: CreatePurchase, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPurchase' is not null or undefined
            assertParamExists('createPurchaseWithBinancePayments', 'createPurchase', createPurchase)
            const localVarPath = `/api/v1/purchases/binance-payment/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CountryCodeHeader required
            await setApiKeyToObject(localVarHeaderParameter, "CF-IPCOUNTRY", configuration)

            // authentication IPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-REAL-IP", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPurchase, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BinancePaymentsApi - functional programming interface
 * @export
 */
export const BinancePaymentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BinancePaymentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Purchase With Binance Payments
         * @param {CreatePurchase} createPurchase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPurchaseWithBinancePayments(createPurchase: CreatePurchase, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePurchaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPurchaseWithBinancePayments(createPurchase, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BinancePaymentsApi - factory interface
 * @export
 */
export const BinancePaymentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BinancePaymentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Purchase With Binance Payments
         * @param {CreatePurchase} createPurchase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPurchaseWithBinancePayments(createPurchase: CreatePurchase, options?: any): AxiosPromise<CreatePurchaseResponse> {
            return localVarFp.createPurchaseWithBinancePayments(createPurchase, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BinancePaymentsApi - object-oriented interface
 * @export
 * @class BinancePaymentsApi
 * @extends {BaseAPI}
 */
export class BinancePaymentsApi extends BaseAPI {
    /**
     * 
     * @summary Create Purchase With Binance Payments
     * @param {CreatePurchase} createPurchase 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BinancePaymentsApi
     */
    public createPurchaseWithBinancePayments(createPurchase: CreatePurchase, options?: AxiosRequestConfig) {
        return BinancePaymentsApiFp(this.configuration).createPurchaseWithBinancePayments(createPurchase, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CampaignsApi - axios parameter creator
 * @export
 */
export const CampaignsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Gift Count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGiftCount: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/campaigns/gifts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Open Gift
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openGift: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/campaigns/gifts/open/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send Gift
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendGift: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/campaigns/gifts/send/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CampaignsApi - functional programming interface
 * @export
 */
export const CampaignsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CampaignsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Gift Count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGiftCount(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GiftCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGiftCount(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Open Gift
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async openGift(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<XpsProxyServiceMockTgIntegrationApiV1CampaignsDtoGift>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.openGift(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Send Gift
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendGift(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendGift(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CampaignsApi - factory interface
 * @export
 */
export const CampaignsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CampaignsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Gift Count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGiftCount(options?: any): AxiosPromise<GiftCount> {
            return localVarFp.getGiftCount(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Open Gift
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openGift(options?: any): AxiosPromise<XpsProxyServiceMockTgIntegrationApiV1CampaignsDtoGift> {
            return localVarFp.openGift(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send Gift
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendGift(options?: any): AxiosPromise<BooleanResponse> {
            return localVarFp.sendGift(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CampaignsApi - object-oriented interface
 * @export
 * @class CampaignsApi
 * @extends {BaseAPI}
 */
export class CampaignsApi extends BaseAPI {
    /**
     * 
     * @summary Get Gift Count
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public getGiftCount(options?: AxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).getGiftCount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Open Gift
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public openGift(options?: AxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).openGift(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send Gift
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public sendGift(options?: AxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).sendGift(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ChequesApi - axios parameter creator
 * @export
 */
export const ChequesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Cheque
         * @param {ChequeRequest} chequeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheque: async (chequeRequest: ChequeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chequeRequest' is not null or undefined
            assertParamExists('createCheque', 'chequeRequest', chequeRequest)
            const localVarPath = `/api/v1/cheques/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chequeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Create Cheques
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveCheques: async (offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/cheques/active/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChequesApi - functional programming interface
 * @export
 */
export const ChequesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChequesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Cheque
         * @param {ChequeRequest} chequeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCheque(chequeRequest: ChequeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChequeRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCheque(chequeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Create Cheques
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveCheques(offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Cheque>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveCheques(offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ChequesApi - factory interface
 * @export
 */
export const ChequesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChequesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Cheque
         * @param {ChequeRequest} chequeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheque(chequeRequest: ChequeRequest, options?: any): AxiosPromise<ChequeRequestResponse> {
            return localVarFp.createCheque(chequeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Create Cheques
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveCheques(offset?: number, limit?: number, options?: any): AxiosPromise<Array<Cheque>> {
            return localVarFp.getActiveCheques(offset, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChequesApi - object-oriented interface
 * @export
 * @class ChequesApi
 * @extends {BaseAPI}
 */
export class ChequesApi extends BaseAPI {
    /**
     * 
     * @summary Create Cheque
     * @param {ChequeRequest} chequeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChequesApi
     */
    public createCheque(chequeRequest: ChequeRequest, options?: AxiosRequestConfig) {
        return ChequesApiFp(this.configuration).createCheque(chequeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Create Cheques
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChequesApi
     */
    public getActiveCheques(offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return ChequesApiFp(this.configuration).getActiveCheques(offset, limit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ClientsApi - axios parameter creator
 * @export
 */
export const ClientsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Auth Token
         * @param {AuthTokenRequest} authTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthToken: async (authTokenRequest: AuthTokenRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authTokenRequest' is not null or undefined
            assertParamExists('createAuthToken', 'authTokenRequest', authTokenRequest)
            const localVarPath = `/api/v1/clients/create_auth_token/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get User Profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserProfile: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/clients/get_profile/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientAuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication ClientSecretHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Client-Secret", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientsApi - functional programming interface
 * @export
 */
export const ClientsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClientsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Auth Token
         * @param {AuthTokenRequest} authTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAuthToken(authTokenRequest: AuthTokenRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAuthToken(authTokenRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get User Profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserProfile(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserProfile(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ClientsApi - factory interface
 * @export
 */
export const ClientsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClientsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Auth Token
         * @param {AuthTokenRequest} authTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthToken(authTokenRequest: AuthTokenRequest, options?: any): AxiosPromise<AuthTokenResponse> {
            return localVarFp.createAuthToken(authTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get User Profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserProfile(options?: any): AxiosPromise<GetUserProfileResponse> {
            return localVarFp.getUserProfile(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClientsApi - object-oriented interface
 * @export
 * @class ClientsApi
 * @extends {BaseAPI}
 */
export class ClientsApi extends BaseAPI {
    /**
     * 
     * @summary Create Auth Token
     * @param {AuthTokenRequest} authTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public createAuthToken(authTokenRequest: AuthTokenRequest, options?: AxiosRequestConfig) {
        return ClientsApiFp(this.configuration).createAuthToken(authTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get User Profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public getUserProfile(options?: AxiosRequestConfig) {
        return ClientsApiFp(this.configuration).getUserProfile(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CurrenciesApi - axios parameter creator
 * @export
 */
export const CurrenciesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Available Fiat Currencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableFiatCurrencies: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/settings/currencies/fiat/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Country Currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountryCurrency: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/currencies/country_currency/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Currency Limits
         * @param {CurrencyEnum} baseCurrency 
         * @param {CurrencyEnum} secondaryCurrency 
         * @param {PaymentMethodEnum} paymentMethod 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrencyLimits: async (baseCurrency: CurrencyEnum, secondaryCurrency: CurrencyEnum, paymentMethod: PaymentMethodEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseCurrency' is not null or undefined
            assertParamExists('getCurrencyLimits', 'baseCurrency', baseCurrency)
            // verify required parameter 'secondaryCurrency' is not null or undefined
            assertParamExists('getCurrencyLimits', 'secondaryCurrency', secondaryCurrency)
            // verify required parameter 'paymentMethod' is not null or undefined
            assertParamExists('getCurrencyLimits', 'paymentMethod', paymentMethod)
            const localVarPath = `/api/v1/settings/limits/base_currency/{base_currency}/secondary_currency/{secondary_currency}/payment_method/{payment_method}/`
                .replace(`{${"base_currency"}}`, encodeURIComponent(String(baseCurrency)))
                .replace(`{${"secondary_currency"}}`, encodeURIComponent(String(secondaryCurrency)))
                .replace(`{${"payment_method"}}`, encodeURIComponent(String(paymentMethod)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Local Currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocalCurrency: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/currencies/local_currency/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Use /Webview/Fiat-Availability/ Instead
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getWebviewFiatCurrency: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/currencies/webview/fiat/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CurrenciesApi - functional programming interface
 * @export
 */
export const CurrenciesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CurrenciesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Available Fiat Currencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvailableFiatCurrencies(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FiatCurrency>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvailableFiatCurrencies(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Country Currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCountryCurrency(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: FiatCurrency; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCountryCurrency(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Currency Limits
         * @param {CurrencyEnum} baseCurrency 
         * @param {CurrencyEnum} secondaryCurrency 
         * @param {PaymentMethodEnum} paymentMethod 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrencyLimits(baseCurrency: CurrencyEnum, secondaryCurrency: CurrencyEnum, paymentMethod: PaymentMethodEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencyLimits>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrencyLimits(baseCurrency, secondaryCurrency, paymentMethod, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Local Currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLocalCurrency(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocalCurrency>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLocalCurrency(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Use /Webview/Fiat-Availability/ Instead
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getWebviewFiatCurrency(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FiatCurrency>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebviewFiatCurrency(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CurrenciesApi - factory interface
 * @export
 */
export const CurrenciesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CurrenciesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Available Fiat Currencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableFiatCurrencies(options?: any): AxiosPromise<Array<FiatCurrency>> {
            return localVarFp.getAvailableFiatCurrencies(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Country Currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountryCurrency(options?: any): AxiosPromise<{ [key: string]: FiatCurrency; }> {
            return localVarFp.getCountryCurrency(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Currency Limits
         * @param {CurrencyEnum} baseCurrency 
         * @param {CurrencyEnum} secondaryCurrency 
         * @param {PaymentMethodEnum} paymentMethod 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrencyLimits(baseCurrency: CurrencyEnum, secondaryCurrency: CurrencyEnum, paymentMethod: PaymentMethodEnum, options?: any): AxiosPromise<CurrencyLimits> {
            return localVarFp.getCurrencyLimits(baseCurrency, secondaryCurrency, paymentMethod, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Local Currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocalCurrency(options?: any): AxiosPromise<LocalCurrency> {
            return localVarFp.getLocalCurrency(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Use /Webview/Fiat-Availability/ Instead
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getWebviewFiatCurrency(options?: any): AxiosPromise<Array<FiatCurrency>> {
            return localVarFp.getWebviewFiatCurrency(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CurrenciesApi - object-oriented interface
 * @export
 * @class CurrenciesApi
 * @extends {BaseAPI}
 */
export class CurrenciesApi extends BaseAPI {
    /**
     * 
     * @summary Get Available Fiat Currencies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public getAvailableFiatCurrencies(options?: AxiosRequestConfig) {
        return CurrenciesApiFp(this.configuration).getAvailableFiatCurrencies(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Country Currency
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public getCountryCurrency(options?: AxiosRequestConfig) {
        return CurrenciesApiFp(this.configuration).getCountryCurrency(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Currency Limits
     * @param {CurrencyEnum} baseCurrency 
     * @param {CurrencyEnum} secondaryCurrency 
     * @param {PaymentMethodEnum} paymentMethod 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public getCurrencyLimits(baseCurrency: CurrencyEnum, secondaryCurrency: CurrencyEnum, paymentMethod: PaymentMethodEnum, options?: AxiosRequestConfig) {
        return CurrenciesApiFp(this.configuration).getCurrencyLimits(baseCurrency, secondaryCurrency, paymentMethod, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Local Currency
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public getLocalCurrency(options?: AxiosRequestConfig) {
        return CurrenciesApiFp(this.configuration).getLocalCurrency(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Use /Webview/Fiat-Availability/ Instead
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public getWebviewFiatCurrency(options?: AxiosRequestConfig) {
        return CurrenciesApiFp(this.configuration).getWebviewFiatCurrency(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CurrencyApi - axios parameter creator
 * @export
 */
export const CurrencyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get User Currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCurrency: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/settings/user_currency/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set User Currency
         * @param {UserCurrency} userCurrency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserCurrency: async (userCurrency: UserCurrency, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCurrency' is not null or undefined
            assertParamExists('setUserCurrency', 'userCurrency', userCurrency)
            const localVarPath = `/api/v1/settings/user_currency/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCurrency, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CurrencyApi - functional programming interface
 * @export
 */
export const CurrencyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CurrencyApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get User Currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserCurrency(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCurrency>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserCurrency(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set User Currency
         * @param {UserCurrency} userCurrency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setUserCurrency(userCurrency: UserCurrency, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setUserCurrency(userCurrency, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CurrencyApi - factory interface
 * @export
 */
export const CurrencyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CurrencyApiFp(configuration)
    return {
        /**
         * 
         * @summary Get User Currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCurrency(options?: any): AxiosPromise<UserCurrency> {
            return localVarFp.getUserCurrency(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set User Currency
         * @param {UserCurrency} userCurrency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserCurrency(userCurrency: UserCurrency, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.setUserCurrency(userCurrency, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CurrencyApi - object-oriented interface
 * @export
 * @class CurrencyApi
 * @extends {BaseAPI}
 */
export class CurrencyApi extends BaseAPI {
    /**
     * 
     * @summary Get User Currency
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public getUserCurrency(options?: AxiosRequestConfig) {
        return CurrencyApiFp(this.configuration).getUserCurrency(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set User Currency
     * @param {UserCurrency} userCurrency 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public setUserCurrency(userCurrency: UserCurrency, options?: AxiosRequestConfig) {
        return CurrencyApiFp(this.configuration).setUserCurrency(userCurrency, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ExchangesApi - axios parameter creator
 * @export
 */
export const ExchangesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Convert
         * @param {ConvertQuery} convertQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        convert: async (convertQuery: ConvertQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'convertQuery' is not null or undefined
            assertParamExists('convert', 'convertQuery', convertQuery)
            const localVarPath = `/api/v1/exchange/convert/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(convertQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Exchange
         * @param {ExchangeQuery} exchangeQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExchange: async (exchangeQuery: ExchangeQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exchangeQuery' is not null or undefined
            assertParamExists('createExchange', 'exchangeQuery', exchangeQuery)
            const localVarPath = `/api/v1/exchange/create_exchange/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exchangeQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Amount Interval
         * @param {AmountIntervalQuery} amountIntervalQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAmountInterval: async (amountIntervalQuery: AmountIntervalQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'amountIntervalQuery' is not null or undefined
            assertParamExists('getAmountInterval', 'amountIntervalQuery', amountIntervalQuery)
            const localVarPath = `/api/v1/exchange/amount_interval/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(amountIntervalQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Exchange
         * @param {string} exchangeUid 
         * @param {FiatCurrency} localCurrency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchange: async (exchangeUid: string, localCurrency: FiatCurrency, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exchangeUid' is not null or undefined
            assertParamExists('getExchange', 'exchangeUid', exchangeUid)
            // verify required parameter 'localCurrency' is not null or undefined
            assertParamExists('getExchange', 'localCurrency', localCurrency)
            const localVarPath = `/api/v1/exchange/{exchange_uid}/{local_currency}`
                .replace(`{${"exchange_uid"}}`, encodeURIComponent(String(exchangeUid)))
                .replace(`{${"local_currency"}}`, encodeURIComponent(String(localCurrency)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Submit Exchange
         * @param {string} exchangeUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitExchange: async (exchangeUid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exchangeUid' is not null or undefined
            assertParamExists('submitExchange', 'exchangeUid', exchangeUid)
            const localVarPath = `/api/v1/exchange/submit_exchange/{exchange_uid}/`
                .replace(`{${"exchange_uid"}}`, encodeURIComponent(String(exchangeUid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExchangesApi - functional programming interface
 * @export
 */
export const ExchangesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExchangesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Convert
         * @param {ConvertQuery} convertQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async convert(convertQuery: ConvertQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConvertResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.convert(convertQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create Exchange
         * @param {ExchangeQuery} exchangeQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createExchange(exchangeQuery: ExchangeQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Exchange>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createExchange(exchangeQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Amount Interval
         * @param {AmountIntervalQuery} amountIntervalQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAmountInterval(amountIntervalQuery: AmountIntervalQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AmountInterval>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAmountInterval(amountIntervalQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Exchange
         * @param {string} exchangeUid 
         * @param {FiatCurrency} localCurrency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExchange(exchangeUid: string, localCurrency: FiatCurrency, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Exchange>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExchange(exchangeUid, localCurrency, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Submit Exchange
         * @param {string} exchangeUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitExchange(exchangeUid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExchangeResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitExchange(exchangeUid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ExchangesApi - factory interface
 * @export
 */
export const ExchangesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExchangesApiFp(configuration)
    return {
        /**
         * 
         * @summary Convert
         * @param {ConvertQuery} convertQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        convert(convertQuery: ConvertQuery, options?: any): AxiosPromise<ConvertResult> {
            return localVarFp.convert(convertQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Exchange
         * @param {ExchangeQuery} exchangeQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExchange(exchangeQuery: ExchangeQuery, options?: any): AxiosPromise<Exchange> {
            return localVarFp.createExchange(exchangeQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Amount Interval
         * @param {AmountIntervalQuery} amountIntervalQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAmountInterval(amountIntervalQuery: AmountIntervalQuery, options?: any): AxiosPromise<AmountInterval> {
            return localVarFp.getAmountInterval(amountIntervalQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Exchange
         * @param {string} exchangeUid 
         * @param {FiatCurrency} localCurrency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchange(exchangeUid: string, localCurrency: FiatCurrency, options?: any): AxiosPromise<Exchange> {
            return localVarFp.getExchange(exchangeUid, localCurrency, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Submit Exchange
         * @param {string} exchangeUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitExchange(exchangeUid: string, options?: any): AxiosPromise<ExchangeResult> {
            return localVarFp.submitExchange(exchangeUid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExchangesApi - object-oriented interface
 * @export
 * @class ExchangesApi
 * @extends {BaseAPI}
 */
export class ExchangesApi extends BaseAPI {
    /**
     * 
     * @summary Convert
     * @param {ConvertQuery} convertQuery 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangesApi
     */
    public convert(convertQuery: ConvertQuery, options?: AxiosRequestConfig) {
        return ExchangesApiFp(this.configuration).convert(convertQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Exchange
     * @param {ExchangeQuery} exchangeQuery 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangesApi
     */
    public createExchange(exchangeQuery: ExchangeQuery, options?: AxiosRequestConfig) {
        return ExchangesApiFp(this.configuration).createExchange(exchangeQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Amount Interval
     * @param {AmountIntervalQuery} amountIntervalQuery 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangesApi
     */
    public getAmountInterval(amountIntervalQuery: AmountIntervalQuery, options?: AxiosRequestConfig) {
        return ExchangesApiFp(this.configuration).getAmountInterval(amountIntervalQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Exchange
     * @param {string} exchangeUid 
     * @param {FiatCurrency} localCurrency 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangesApi
     */
    public getExchange(exchangeUid: string, localCurrency: FiatCurrency, options?: AxiosRequestConfig) {
        return ExchangesApiFp(this.configuration).getExchange(exchangeUid, localCurrency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Submit Exchange
     * @param {string} exchangeUid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangesApi
     */
    public submitExchange(exchangeUid: string, options?: AxiosRequestConfig) {
        return ExchangesApiFp(this.configuration).submitExchange(exchangeUid, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LanguageApi - axios parameter creator
 * @export
 */
export const LanguageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Set User Language
         * @param {Language} language 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserLanguage: async (language: Language, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('setUserLanguage', 'language', language)
            const localVarPath = `/api/v1/settings/user_language/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(language, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LanguageApi - functional programming interface
 * @export
 */
export const LanguageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LanguageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Set User Language
         * @param {Language} language 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setUserLanguage(language: Language, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setUserLanguage(language, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LanguageApi - factory interface
 * @export
 */
export const LanguageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LanguageApiFp(configuration)
    return {
        /**
         * 
         * @summary Set User Language
         * @param {Language} language 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserLanguage(language: Language, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.setUserLanguage(language, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LanguageApi - object-oriented interface
 * @export
 * @class LanguageApi
 * @extends {BaseAPI}
 */
export class LanguageApi extends BaseAPI {
    /**
     * 
     * @summary Set User Language
     * @param {Language} language 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguageApi
     */
    public setUserLanguage(language: Language, options?: AxiosRequestConfig) {
        return LanguageApiFp(this.configuration).setUserLanguage(language, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LanguagesApi - axios parameter creator
 * @export
 */
export const LanguagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get-Available-Languages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableLanguages: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/settings/languages/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LanguagesApi - functional programming interface
 * @export
 */
export const LanguagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LanguagesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get-Available-Languages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvailableLanguages(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Languages>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvailableLanguages(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LanguagesApi - factory interface
 * @export
 */
export const LanguagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LanguagesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get-Available-Languages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableLanguages(options?: any): AxiosPromise<Array<Languages>> {
            return localVarFp.getAvailableLanguages(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LanguagesApi - object-oriented interface
 * @export
 * @class LanguagesApi
 * @extends {BaseAPI}
 */
export class LanguagesApi extends BaseAPI {
    /**
     * 
     * @summary Get-Available-Languages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguagesApi
     */
    public getAvailableLanguages(options?: AxiosRequestConfig) {
        return LanguagesApiFp(this.configuration).getAvailableLanguages(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PricesApi - axios parameter creator
 * @export
 */
export const PricesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return estimate price for buying cryptocurrency
         * @summary Get Estimate Price
         * @param {EstimatePriceRequest} estimatePriceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEstimatePrice: async (estimatePriceRequest: EstimatePriceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'estimatePriceRequest' is not null or undefined
            assertParamExists('getEstimatePrice', 'estimatePriceRequest', estimatePriceRequest)
            const localVarPath = `/api/v1/prices/estimate/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(estimatePriceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PricesApi - functional programming interface
 * @export
 */
export const PricesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PricesApiAxiosParamCreator(configuration)
    return {
        /**
         * Return estimate price for buying cryptocurrency
         * @summary Get Estimate Price
         * @param {EstimatePriceRequest} estimatePriceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEstimatePrice(estimatePriceRequest: EstimatePriceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EstimatePrice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEstimatePrice(estimatePriceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PricesApi - factory interface
 * @export
 */
export const PricesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PricesApiFp(configuration)
    return {
        /**
         * Return estimate price for buying cryptocurrency
         * @summary Get Estimate Price
         * @param {EstimatePriceRequest} estimatePriceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEstimatePrice(estimatePriceRequest: EstimatePriceRequest, options?: any): AxiosPromise<EstimatePrice> {
            return localVarFp.getEstimatePrice(estimatePriceRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PricesApi - object-oriented interface
 * @export
 * @class PricesApi
 * @extends {BaseAPI}
 */
export class PricesApi extends BaseAPI {
    /**
     * Return estimate price for buying cryptocurrency
     * @summary Get Estimate Price
     * @param {EstimatePriceRequest} estimatePriceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricesApi
     */
    public getEstimatePrice(estimatePriceRequest: EstimatePriceRequest, options?: AxiosRequestConfig) {
        return PricesApiFp(this.configuration).getEstimatePrice(estimatePriceRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PurchasesApi - axios parameter creator
 * @export
 */
export const PurchasesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancel Purchase
         * @param {number} purchaseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPurchase: async (purchaseId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'purchaseId' is not null or undefined
            assertParamExists('cancelPurchase', 'purchaseId', purchaseId)
            const localVarPath = `/api/v1/purchases/{purchase_id}/cancel`
                .replace(`{${"purchase_id"}}`, encodeURIComponent(String(purchaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Purchase
         * @param {CreatePurchase} createPurchase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPurchase: async (createPurchase: CreatePurchase, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPurchase' is not null or undefined
            assertParamExists('createPurchase', 'createPurchase', createPurchase)
            const localVarPath = `/api/v1/purchases/create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CountryCodeHeader required
            await setApiKeyToObject(localVarHeaderParameter, "CF-IPCOUNTRY", configuration)

            // authentication IPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-REAL-IP", configuration)

            // authentication UserAgentHeader required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPurchase, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Purchase By Payment Method
         * @param {InitPurchase} initPurchase 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createPurchaseByPaymentMethod: async (initPurchase: InitPurchase, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'initPurchase' is not null or undefined
            assertParamExists('createPurchaseByPaymentMethod', 'initPurchase', initPurchase)
            const localVarPath = `/api/v1/purchases/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CountryCodeHeader required
            await setApiKeyToObject(localVarHeaderParameter, "CF-IPCOUNTRY", configuration)

            // authentication IPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-REAL-IP", configuration)

            // authentication UserAgentHeader required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(initPurchase, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Purchase With Binance Payments
         * @param {CreatePurchase} createPurchase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPurchaseWithBinancePayments: async (createPurchase: CreatePurchase, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPurchase' is not null or undefined
            assertParamExists('createPurchaseWithBinancePayments', 'createPurchase', createPurchase)
            const localVarPath = `/api/v1/purchases/binance-payment/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CountryCodeHeader required
            await setApiKeyToObject(localVarHeaderParameter, "CF-IPCOUNTRY", configuration)

            // authentication IPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-REAL-IP", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPurchase, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Purchase With Ru Bank Card
         * @param {RuBankCardPurchase} ruBankCardPurchase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPurchaseWithRuBankCard: async (ruBankCardPurchase: RuBankCardPurchase, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ruBankCardPurchase' is not null or undefined
            assertParamExists('createPurchaseWithRuBankCard', 'ruBankCardPurchase', ruBankCardPurchase)
            const localVarPath = `/api/v1/purchases/ru-bank-card/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ruBankCardPurchase, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Purchase With Telegram Payments
         * @param {InitPurchase} initPurchase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPurchaseWithTelegramPayments: async (initPurchase: InitPurchase, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'initPurchase' is not null or undefined
            assertParamExists('createPurchaseWithTelegramPayments', 'initPurchase', initPurchase)
            const localVarPath = `/api/v1/purchases/telegram-payment/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CountryCodeHeader required
            await setApiKeyToObject(localVarHeaderParameter, "CF-IPCOUNTRY", configuration)

            // authentication IPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-REAL-IP", configuration)

            // authentication UserAgentHeader required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(initPurchase, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Kyc Status Of Purchase
         * @param {UserKycStatusRequest} userKycStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKycStatusOfPurchase: async (userKycStatusRequest: UserKycStatusRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userKycStatusRequest' is not null or undefined
            assertParamExists('getKycStatusOfPurchase', 'userKycStatusRequest', userKycStatusRequest)
            const localVarPath = `/api/v1/purchases/kyc/status/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userKycStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Kyc Url Of Purchase
         * @param {XpsProxyServiceMockTgIntegrationApiV1PurchasesKycDtoUserKycUrlRequest} xpsProxyServiceMockTgIntegrationApiV1PurchasesKycDtoUserKycUrlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKycUrlOfPurchase: async (xpsProxyServiceMockTgIntegrationApiV1PurchasesKycDtoUserKycUrlRequest: XpsProxyServiceMockTgIntegrationApiV1PurchasesKycDtoUserKycUrlRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xpsProxyServiceMockTgIntegrationApiV1PurchasesKycDtoUserKycUrlRequest' is not null or undefined
            assertParamExists('getKycUrlOfPurchase', 'xpsProxyServiceMockTgIntegrationApiV1PurchasesKycDtoUserKycUrlRequest', xpsProxyServiceMockTgIntegrationApiV1PurchasesKycDtoUserKycUrlRequest)
            const localVarPath = `/api/v1/purchases/kyc/url/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(xpsProxyServiceMockTgIntegrationApiV1PurchasesKycDtoUserKycUrlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Saved User Input
         * @param {GetSavedUserExtraDataRequest} getSavedUserExtraDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSavedUserInput: async (getSavedUserExtraDataRequest: GetSavedUserExtraDataRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getSavedUserExtraDataRequest' is not null or undefined
            assertParamExists('getSavedUserInput', 'getSavedUserExtraDataRequest', getSavedUserExtraDataRequest)
            const localVarPath = `/api/v1/purchases/get-saved-user-extra-data/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CountryCodeHeader required
            await setApiKeyToObject(localVarHeaderParameter, "CF-IPCOUNTRY", configuration)

            // authentication IPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-REAL-IP", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSavedUserExtraDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Webview Available Fiat Currencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebviewAvailableFiatCurrencies: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/purchases/available-fiat/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Init Bot Kyc Poll Of Purchase
         * @param {BotKycPollingRequest} botKycPollingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initBotKycPollOfPurchase: async (botKycPollingRequest: BotKycPollingRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botKycPollingRequest' is not null or undefined
            assertParamExists('initBotKycPollOfPurchase', 'botKycPollingRequest', botKycPollingRequest)
            const localVarPath = `/api/v1/purchases/kyc/init_bot_poll/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(botKycPollingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Init Purchase
         * @param {InitPurchase} initPurchase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initPurchase: async (initPurchase: InitPurchase, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'initPurchase' is not null or undefined
            assertParamExists('initPurchase', 'initPurchase', initPurchase)
            const localVarPath = `/api/v1/purchases/init/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CountryCodeHeader required
            await setApiKeyToObject(localVarHeaderParameter, "CF-IPCOUNTRY", configuration)

            // authentication IPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-REAL-IP", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(initPurchase, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Offer Via Text Bot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        offerViaTextBot: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/purchases/offer_via_text_bot/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CountryCodeHeader required
            await setApiKeyToObject(localVarHeaderParameter, "CF-IPCOUNTRY", configuration)

            // authentication IPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-REAL-IP", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Purchase Info
         * @param {string} purchaseExternalId 
         * @param {PaymentMethodEnum} paymentMethod 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseInfo: async (purchaseExternalId: string, paymentMethod: PaymentMethodEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'purchaseExternalId' is not null or undefined
            assertParamExists('purchaseInfo', 'purchaseExternalId', purchaseExternalId)
            // verify required parameter 'paymentMethod' is not null or undefined
            assertParamExists('purchaseInfo', 'paymentMethod', paymentMethod)
            const localVarPath = `/api/v1/purchases/{purchase_external_id}`
                .replace(`{${"purchase_external_id"}}`, encodeURIComponent(String(purchaseExternalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (paymentMethod !== undefined) {
                localVarQueryParameter['payment_method'] = paymentMethod;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Purchase Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseSettings: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/purchases/settings/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Purchase Invoice In Text Bot
         * @param {RedirectPurchase} redirectPurchase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redirectToTextBot: async (redirectPurchase: RedirectPurchase, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'redirectPurchase' is not null or undefined
            assertParamExists('redirectToTextBot', 'redirectPurchase', redirectPurchase)
            const localVarPath = `/api/v1/purchases/redirect_to_text_bot/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(redirectPurchase, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PurchasesApi - functional programming interface
 * @export
 */
export const PurchasesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PurchasesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Cancel Purchase
         * @param {number} purchaseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelPurchase(purchaseId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePurchaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelPurchase(purchaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create Purchase
         * @param {CreatePurchase} createPurchase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPurchase(createPurchase: CreatePurchase, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePurchaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPurchase(createPurchase, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create Purchase By Payment Method
         * @param {InitPurchase} initPurchase 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async createPurchaseByPaymentMethod(initPurchase: InitPurchase, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePurchaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPurchaseByPaymentMethod(initPurchase, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create Purchase With Binance Payments
         * @param {CreatePurchase} createPurchase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPurchaseWithBinancePayments(createPurchase: CreatePurchase, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePurchaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPurchaseWithBinancePayments(createPurchase, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create Purchase With Ru Bank Card
         * @param {RuBankCardPurchase} ruBankCardPurchase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPurchaseWithRuBankCard(ruBankCardPurchase: RuBankCardPurchase, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPurchaseWithRuBankCard(ruBankCardPurchase, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create Purchase With Telegram Payments
         * @param {InitPurchase} initPurchase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPurchaseWithTelegramPayments(initPurchase: InitPurchase, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TelegramPaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPurchaseWithTelegramPayments(initPurchase, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Kyc Status Of Purchase
         * @param {UserKycStatusRequest} userKycStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKycStatusOfPurchase(userKycStatusRequest: UserKycStatusRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserKycStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKycStatusOfPurchase(userKycStatusRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Kyc Url Of Purchase
         * @param {XpsProxyServiceMockTgIntegrationApiV1PurchasesKycDtoUserKycUrlRequest} xpsProxyServiceMockTgIntegrationApiV1PurchasesKycDtoUserKycUrlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKycUrlOfPurchase(xpsProxyServiceMockTgIntegrationApiV1PurchasesKycDtoUserKycUrlRequest: XpsProxyServiceMockTgIntegrationApiV1PurchasesKycDtoUserKycUrlRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserKycUrlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKycUrlOfPurchase(xpsProxyServiceMockTgIntegrationApiV1PurchasesKycDtoUserKycUrlRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Saved User Input
         * @param {GetSavedUserExtraDataRequest} getSavedUserExtraDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSavedUserInput(getSavedUserExtraDataRequest: GetSavedUserExtraDataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSavedUserExtraDataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSavedUserInput(getSavedUserExtraDataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Webview Available Fiat Currencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebviewAvailableFiatCurrencies(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Currencies>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebviewAvailableFiatCurrencies(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Init Bot Kyc Poll Of Purchase
         * @param {BotKycPollingRequest} botKycPollingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initBotKycPollOfPurchase(botKycPollingRequest: BotKycPollingRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BoolResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initBotKycPollOfPurchase(botKycPollingRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Init Purchase
         * @param {InitPurchase} initPurchase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initPurchase(initPurchase: InitPurchase, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InitPurchaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initPurchase(initPurchase, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Offer Via Text Bot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async offerViaTextBot(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.offerViaTextBot(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Purchase Info
         * @param {string} purchaseExternalId 
         * @param {PaymentMethodEnum} paymentMethod 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchaseInfo(purchaseExternalId: string, paymentMethod: PaymentMethodEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PurchaseInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchaseInfo(purchaseExternalId, paymentMethod, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Purchase Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchaseSettings(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CurrencySettingsUnit>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchaseSettings(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create Purchase Invoice In Text Bot
         * @param {RedirectPurchase} redirectPurchase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redirectToTextBot(redirectPurchase: RedirectPurchase, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redirectToTextBot(redirectPurchase, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PurchasesApi - factory interface
 * @export
 */
export const PurchasesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PurchasesApiFp(configuration)
    return {
        /**
         * 
         * @summary Cancel Purchase
         * @param {number} purchaseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPurchase(purchaseId: number, options?: any): AxiosPromise<CreatePurchaseResponse> {
            return localVarFp.cancelPurchase(purchaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Purchase
         * @param {CreatePurchase} createPurchase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPurchase(createPurchase: CreatePurchase, options?: any): AxiosPromise<CreatePurchaseResponse> {
            return localVarFp.createPurchase(createPurchase, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Purchase By Payment Method
         * @param {InitPurchase} initPurchase 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createPurchaseByPaymentMethod(initPurchase: InitPurchase, options?: any): AxiosPromise<CreatePurchaseResponse> {
            return localVarFp.createPurchaseByPaymentMethod(initPurchase, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Purchase With Binance Payments
         * @param {CreatePurchase} createPurchase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPurchaseWithBinancePayments(createPurchase: CreatePurchase, options?: any): AxiosPromise<CreatePurchaseResponse> {
            return localVarFp.createPurchaseWithBinancePayments(createPurchase, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Purchase With Ru Bank Card
         * @param {RuBankCardPurchase} ruBankCardPurchase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPurchaseWithRuBankCard(ruBankCardPurchase: RuBankCardPurchase, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.createPurchaseWithRuBankCard(ruBankCardPurchase, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Purchase With Telegram Payments
         * @param {InitPurchase} initPurchase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPurchaseWithTelegramPayments(initPurchase: InitPurchase, options?: any): AxiosPromise<TelegramPaymentResponse> {
            return localVarFp.createPurchaseWithTelegramPayments(initPurchase, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Kyc Status Of Purchase
         * @param {UserKycStatusRequest} userKycStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKycStatusOfPurchase(userKycStatusRequest: UserKycStatusRequest, options?: any): AxiosPromise<UserKycStatusResponse> {
            return localVarFp.getKycStatusOfPurchase(userKycStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Kyc Url Of Purchase
         * @param {XpsProxyServiceMockTgIntegrationApiV1PurchasesKycDtoUserKycUrlRequest} xpsProxyServiceMockTgIntegrationApiV1PurchasesKycDtoUserKycUrlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKycUrlOfPurchase(xpsProxyServiceMockTgIntegrationApiV1PurchasesKycDtoUserKycUrlRequest: XpsProxyServiceMockTgIntegrationApiV1PurchasesKycDtoUserKycUrlRequest, options?: any): AxiosPromise<UserKycUrlResponse> {
            return localVarFp.getKycUrlOfPurchase(xpsProxyServiceMockTgIntegrationApiV1PurchasesKycDtoUserKycUrlRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Saved User Input
         * @param {GetSavedUserExtraDataRequest} getSavedUserExtraDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSavedUserInput(getSavedUserExtraDataRequest: GetSavedUserExtraDataRequest, options?: any): AxiosPromise<GetSavedUserExtraDataResponse> {
            return localVarFp.getSavedUserInput(getSavedUserExtraDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Webview Available Fiat Currencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebviewAvailableFiatCurrencies(options?: any): AxiosPromise<Currencies> {
            return localVarFp.getWebviewAvailableFiatCurrencies(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Init Bot Kyc Poll Of Purchase
         * @param {BotKycPollingRequest} botKycPollingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initBotKycPollOfPurchase(botKycPollingRequest: BotKycPollingRequest, options?: any): AxiosPromise<BoolResponse> {
            return localVarFp.initBotKycPollOfPurchase(botKycPollingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Init Purchase
         * @param {InitPurchase} initPurchase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initPurchase(initPurchase: InitPurchase, options?: any): AxiosPromise<InitPurchaseResponse> {
            return localVarFp.initPurchase(initPurchase, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Offer Via Text Bot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        offerViaTextBot(options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.offerViaTextBot(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Purchase Info
         * @param {string} purchaseExternalId 
         * @param {PaymentMethodEnum} paymentMethod 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseInfo(purchaseExternalId: string, paymentMethod: PaymentMethodEnum, options?: any): AxiosPromise<PurchaseInfoResponse> {
            return localVarFp.purchaseInfo(purchaseExternalId, paymentMethod, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Purchase Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseSettings(options?: any): AxiosPromise<Array<CurrencySettingsUnit>> {
            return localVarFp.purchaseSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Purchase Invoice In Text Bot
         * @param {RedirectPurchase} redirectPurchase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redirectToTextBot(redirectPurchase: RedirectPurchase, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.redirectToTextBot(redirectPurchase, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PurchasesApi - object-oriented interface
 * @export
 * @class PurchasesApi
 * @extends {BaseAPI}
 */
export class PurchasesApi extends BaseAPI {
    /**
     * 
     * @summary Cancel Purchase
     * @param {number} purchaseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchasesApi
     */
    public cancelPurchase(purchaseId: number, options?: AxiosRequestConfig) {
        return PurchasesApiFp(this.configuration).cancelPurchase(purchaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Purchase
     * @param {CreatePurchase} createPurchase 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchasesApi
     */
    public createPurchase(createPurchase: CreatePurchase, options?: AxiosRequestConfig) {
        return PurchasesApiFp(this.configuration).createPurchase(createPurchase, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Purchase By Payment Method
     * @param {InitPurchase} initPurchase 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof PurchasesApi
     */
    public createPurchaseByPaymentMethod(initPurchase: InitPurchase, options?: AxiosRequestConfig) {
        return PurchasesApiFp(this.configuration).createPurchaseByPaymentMethod(initPurchase, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Purchase With Binance Payments
     * @param {CreatePurchase} createPurchase 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchasesApi
     */
    public createPurchaseWithBinancePayments(createPurchase: CreatePurchase, options?: AxiosRequestConfig) {
        return PurchasesApiFp(this.configuration).createPurchaseWithBinancePayments(createPurchase, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Purchase With Ru Bank Card
     * @param {RuBankCardPurchase} ruBankCardPurchase 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchasesApi
     */
    public createPurchaseWithRuBankCard(ruBankCardPurchase: RuBankCardPurchase, options?: AxiosRequestConfig) {
        return PurchasesApiFp(this.configuration).createPurchaseWithRuBankCard(ruBankCardPurchase, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Purchase With Telegram Payments
     * @param {InitPurchase} initPurchase 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchasesApi
     */
    public createPurchaseWithTelegramPayments(initPurchase: InitPurchase, options?: AxiosRequestConfig) {
        return PurchasesApiFp(this.configuration).createPurchaseWithTelegramPayments(initPurchase, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Kyc Status Of Purchase
     * @param {UserKycStatusRequest} userKycStatusRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchasesApi
     */
    public getKycStatusOfPurchase(userKycStatusRequest: UserKycStatusRequest, options?: AxiosRequestConfig) {
        return PurchasesApiFp(this.configuration).getKycStatusOfPurchase(userKycStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Kyc Url Of Purchase
     * @param {XpsProxyServiceMockTgIntegrationApiV1PurchasesKycDtoUserKycUrlRequest} xpsProxyServiceMockTgIntegrationApiV1PurchasesKycDtoUserKycUrlRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchasesApi
     */
    public getKycUrlOfPurchase(xpsProxyServiceMockTgIntegrationApiV1PurchasesKycDtoUserKycUrlRequest: XpsProxyServiceMockTgIntegrationApiV1PurchasesKycDtoUserKycUrlRequest, options?: AxiosRequestConfig) {
        return PurchasesApiFp(this.configuration).getKycUrlOfPurchase(xpsProxyServiceMockTgIntegrationApiV1PurchasesKycDtoUserKycUrlRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Saved User Input
     * @param {GetSavedUserExtraDataRequest} getSavedUserExtraDataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchasesApi
     */
    public getSavedUserInput(getSavedUserExtraDataRequest: GetSavedUserExtraDataRequest, options?: AxiosRequestConfig) {
        return PurchasesApiFp(this.configuration).getSavedUserInput(getSavedUserExtraDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Webview Available Fiat Currencies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchasesApi
     */
    public getWebviewAvailableFiatCurrencies(options?: AxiosRequestConfig) {
        return PurchasesApiFp(this.configuration).getWebviewAvailableFiatCurrencies(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Init Bot Kyc Poll Of Purchase
     * @param {BotKycPollingRequest} botKycPollingRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchasesApi
     */
    public initBotKycPollOfPurchase(botKycPollingRequest: BotKycPollingRequest, options?: AxiosRequestConfig) {
        return PurchasesApiFp(this.configuration).initBotKycPollOfPurchase(botKycPollingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Init Purchase
     * @param {InitPurchase} initPurchase 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchasesApi
     */
    public initPurchase(initPurchase: InitPurchase, options?: AxiosRequestConfig) {
        return PurchasesApiFp(this.configuration).initPurchase(initPurchase, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Offer Via Text Bot
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchasesApi
     */
    public offerViaTextBot(options?: AxiosRequestConfig) {
        return PurchasesApiFp(this.configuration).offerViaTextBot(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Purchase Info
     * @param {string} purchaseExternalId 
     * @param {PaymentMethodEnum} paymentMethod 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchasesApi
     */
    public purchaseInfo(purchaseExternalId: string, paymentMethod: PaymentMethodEnum, options?: AxiosRequestConfig) {
        return PurchasesApiFp(this.configuration).purchaseInfo(purchaseExternalId, paymentMethod, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Purchase Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchasesApi
     */
    public purchaseSettings(options?: AxiosRequestConfig) {
        return PurchasesApiFp(this.configuration).purchaseSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Purchase Invoice In Text Bot
     * @param {RedirectPurchase} redirectPurchase 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchasesApi
     */
    public redirectToTextBot(redirectPurchase: RedirectPurchase, options?: AxiosRequestConfig) {
        return PurchasesApiFp(this.configuration).redirectToTextBot(redirectPurchase, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TelegramPaymentsApi - axios parameter creator
 * @export
 */
export const TelegramPaymentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Purchase
         * @param {CreatePurchase} createPurchase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPurchase: async (createPurchase: CreatePurchase, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPurchase' is not null or undefined
            assertParamExists('createPurchase', 'createPurchase', createPurchase)
            const localVarPath = `/api/v1/purchases/create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CountryCodeHeader required
            await setApiKeyToObject(localVarHeaderParameter, "CF-IPCOUNTRY", configuration)

            // authentication IPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-REAL-IP", configuration)

            // authentication UserAgentHeader required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPurchase, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Purchase With Telegram Payments
         * @param {InitPurchase} initPurchase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPurchaseWithTelegramPayments: async (initPurchase: InitPurchase, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'initPurchase' is not null or undefined
            assertParamExists('createPurchaseWithTelegramPayments', 'initPurchase', initPurchase)
            const localVarPath = `/api/v1/purchases/telegram-payment/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CountryCodeHeader required
            await setApiKeyToObject(localVarHeaderParameter, "CF-IPCOUNTRY", configuration)

            // authentication IPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-REAL-IP", configuration)

            // authentication UserAgentHeader required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(initPurchase, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Saved User Input
         * @param {GetSavedUserExtraDataRequest} getSavedUserExtraDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSavedUserInput: async (getSavedUserExtraDataRequest: GetSavedUserExtraDataRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getSavedUserExtraDataRequest' is not null or undefined
            assertParamExists('getSavedUserInput', 'getSavedUserExtraDataRequest', getSavedUserExtraDataRequest)
            const localVarPath = `/api/v1/purchases/get-saved-user-extra-data/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CountryCodeHeader required
            await setApiKeyToObject(localVarHeaderParameter, "CF-IPCOUNTRY", configuration)

            // authentication IPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-REAL-IP", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSavedUserExtraDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Init Purchase
         * @param {InitPurchase} initPurchase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initPurchase: async (initPurchase: InitPurchase, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'initPurchase' is not null or undefined
            assertParamExists('initPurchase', 'initPurchase', initPurchase)
            const localVarPath = `/api/v1/purchases/init/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CountryCodeHeader required
            await setApiKeyToObject(localVarHeaderParameter, "CF-IPCOUNTRY", configuration)

            // authentication IPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-REAL-IP", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(initPurchase, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TelegramPaymentsApi - functional programming interface
 * @export
 */
export const TelegramPaymentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TelegramPaymentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Purchase
         * @param {CreatePurchase} createPurchase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPurchase(createPurchase: CreatePurchase, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePurchaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPurchase(createPurchase, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create Purchase With Telegram Payments
         * @param {InitPurchase} initPurchase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPurchaseWithTelegramPayments(initPurchase: InitPurchase, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TelegramPaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPurchaseWithTelegramPayments(initPurchase, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Saved User Input
         * @param {GetSavedUserExtraDataRequest} getSavedUserExtraDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSavedUserInput(getSavedUserExtraDataRequest: GetSavedUserExtraDataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSavedUserExtraDataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSavedUserInput(getSavedUserExtraDataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Init Purchase
         * @param {InitPurchase} initPurchase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initPurchase(initPurchase: InitPurchase, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InitPurchaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initPurchase(initPurchase, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TelegramPaymentsApi - factory interface
 * @export
 */
export const TelegramPaymentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TelegramPaymentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Purchase
         * @param {CreatePurchase} createPurchase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPurchase(createPurchase: CreatePurchase, options?: any): AxiosPromise<CreatePurchaseResponse> {
            return localVarFp.createPurchase(createPurchase, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Purchase With Telegram Payments
         * @param {InitPurchase} initPurchase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPurchaseWithTelegramPayments(initPurchase: InitPurchase, options?: any): AxiosPromise<TelegramPaymentResponse> {
            return localVarFp.createPurchaseWithTelegramPayments(initPurchase, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Saved User Input
         * @param {GetSavedUserExtraDataRequest} getSavedUserExtraDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSavedUserInput(getSavedUserExtraDataRequest: GetSavedUserExtraDataRequest, options?: any): AxiosPromise<GetSavedUserExtraDataResponse> {
            return localVarFp.getSavedUserInput(getSavedUserExtraDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Init Purchase
         * @param {InitPurchase} initPurchase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initPurchase(initPurchase: InitPurchase, options?: any): AxiosPromise<InitPurchaseResponse> {
            return localVarFp.initPurchase(initPurchase, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TelegramPaymentsApi - object-oriented interface
 * @export
 * @class TelegramPaymentsApi
 * @extends {BaseAPI}
 */
export class TelegramPaymentsApi extends BaseAPI {
    /**
     * 
     * @summary Create Purchase
     * @param {CreatePurchase} createPurchase 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegramPaymentsApi
     */
    public createPurchase(createPurchase: CreatePurchase, options?: AxiosRequestConfig) {
        return TelegramPaymentsApiFp(this.configuration).createPurchase(createPurchase, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Purchase With Telegram Payments
     * @param {InitPurchase} initPurchase 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegramPaymentsApi
     */
    public createPurchaseWithTelegramPayments(initPurchase: InitPurchase, options?: AxiosRequestConfig) {
        return TelegramPaymentsApiFp(this.configuration).createPurchaseWithTelegramPayments(initPurchase, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Saved User Input
     * @param {GetSavedUserExtraDataRequest} getSavedUserExtraDataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegramPaymentsApi
     */
    public getSavedUserInput(getSavedUserExtraDataRequest: GetSavedUserExtraDataRequest, options?: AxiosRequestConfig) {
        return TelegramPaymentsApiFp(this.configuration).getSavedUserInput(getSavedUserExtraDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Init Purchase
     * @param {InitPurchase} initPurchase 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegramPaymentsApi
     */
    public initPurchase(initPurchase: InitPurchase, options?: AxiosRequestConfig) {
        return TelegramPaymentsApiFp(this.configuration).initPurchase(initPurchase, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancel Pending Transaction
         * @param {number} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPendingTransaction: async (transactionId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('cancelPendingTransaction', 'transactionId', transactionId)
            const localVarPath = `/api/v1/transactions/cancel/pending/{transaction_id}/`
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancel Tgtransfer Transaction
         * @param {number} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTgtransferTransaction: async (transactionId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('cancelTgtransferTransaction', 'transactionId', transactionId)
            const localVarPath = `/api/v1/transactions/cancel/{transaction_id}/`
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Reference Transaction Details
         * @param {number} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferenceTransactionDetails: async (transactionId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('getReferenceTransactionDetails', 'transactionId', transactionId)
            const localVarPath = `/api/v1/transactions/reference_transaction_details/{transaction_id}/`
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Transaction Details
         * @param {number} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionDetails: async (transactionId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('getTransactionDetails', 'transactionId', transactionId)
            const localVarPath = `/api/v1/transactions/details/{transaction_id}/`
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Transactions
         * @param {FrontendCryptoCurrencyEnum} [cryptoCurrency] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {number} [lastId] 
         * @param {TransactionTypeEnum} [transactionType] 
         * @param {Array<TransactionGateway>} [transactionGateway] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions: async (cryptoCurrency?: FrontendCryptoCurrencyEnum, offset?: number, limit?: number, lastId?: number, transactionType?: TransactionTypeEnum, transactionGateway?: Array<TransactionGateway>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/transactions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (cryptoCurrency !== undefined) {
                localVarQueryParameter['crypto_currency'] = cryptoCurrency;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (lastId !== undefined) {
                localVarQueryParameter['last_id'] = lastId;
            }

            if (transactionType !== undefined) {
                localVarQueryParameter['transaction_type'] = transactionType;
            }

            if (transactionGateway) {
                localVarQueryParameter['transaction_gateway'] = transactionGateway;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Cancel Pending Transaction
         * @param {number} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelPendingTransaction(transactionId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelPendingTransaction(transactionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Cancel Tgtransfer Transaction
         * @param {number} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelTgtransferTransaction(transactionId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelTgtransferTransaction(transactionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Reference Transaction Details
         * @param {number} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReferenceTransactionDetails(transactionId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReferenceTransactionDetails(transactionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Transaction Details
         * @param {number} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionDetails(transactionId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionDetails(transactionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Transactions
         * @param {FrontendCryptoCurrencyEnum} [cryptoCurrency] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {number} [lastId] 
         * @param {TransactionTypeEnum} [transactionType] 
         * @param {Array<TransactionGateway>} [transactionGateway] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactions(cryptoCurrency?: FrontendCryptoCurrencyEnum, offset?: number, limit?: number, lastId?: number, transactionType?: TransactionTypeEnum, transactionGateway?: Array<TransactionGateway>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReturnTransactions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactions(cryptoCurrency, offset, limit, lastId, transactionType, transactionGateway, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Cancel Pending Transaction
         * @param {number} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPendingTransaction(transactionId: number, options?: any): AxiosPromise<BooleanResponse> {
            return localVarFp.cancelPendingTransaction(transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancel Tgtransfer Transaction
         * @param {number} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTgtransferTransaction(transactionId: number, options?: any): AxiosPromise<BooleanResponse> {
            return localVarFp.cancelTgtransferTransaction(transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Reference Transaction Details
         * @param {number} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferenceTransactionDetails(transactionId: number, options?: any): AxiosPromise<TransactionDetails> {
            return localVarFp.getReferenceTransactionDetails(transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Transaction Details
         * @param {number} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionDetails(transactionId: number, options?: any): AxiosPromise<TransactionDetails> {
            return localVarFp.getTransactionDetails(transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Transactions
         * @param {FrontendCryptoCurrencyEnum} [cryptoCurrency] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {number} [lastId] 
         * @param {TransactionTypeEnum} [transactionType] 
         * @param {Array<TransactionGateway>} [transactionGateway] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions(cryptoCurrency?: FrontendCryptoCurrencyEnum, offset?: number, limit?: number, lastId?: number, transactionType?: TransactionTypeEnum, transactionGateway?: Array<TransactionGateway>, options?: any): AxiosPromise<ReturnTransactions> {
            return localVarFp.getTransactions(cryptoCurrency, offset, limit, lastId, transactionType, transactionGateway, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
    /**
     * 
     * @summary Cancel Pending Transaction
     * @param {number} transactionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public cancelPendingTransaction(transactionId: number, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).cancelPendingTransaction(transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancel Tgtransfer Transaction
     * @param {number} transactionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public cancelTgtransferTransaction(transactionId: number, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).cancelTgtransferTransaction(transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Reference Transaction Details
     * @param {number} transactionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getReferenceTransactionDetails(transactionId: number, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).getReferenceTransactionDetails(transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Transaction Details
     * @param {number} transactionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactionDetails(transactionId: number, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).getTransactionDetails(transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Transactions
     * @param {FrontendCryptoCurrencyEnum} [cryptoCurrency] 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {number} [lastId] 
     * @param {TransactionTypeEnum} [transactionType] 
     * @param {Array<TransactionGateway>} [transactionGateway] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactions(cryptoCurrency?: FrontendCryptoCurrencyEnum, offset?: number, limit?: number, lastId?: number, transactionType?: TransactionTypeEnum, transactionGateway?: Array<TransactionGateway>, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).getTransactions(cryptoCurrency, offset, limit, lastId, transactionType, transactionGateway, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TransfersApi - axios parameter creator
 * @export
 */
export const TransfersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Transfer Request
         * @param {RequestTransferRequest} requestTransferRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransferRequest: async (requestTransferRequest: RequestTransferRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestTransferRequest' is not null or undefined
            assertParamExists('createTransferRequest', 'requestTransferRequest', requestTransferRequest)
            const localVarPath = `/api/v1/transfers/create_transfer_request/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CountryCodeHeader required
            await setApiKeyToObject(localVarHeaderParameter, "CF-IPCOUNTRY", configuration)

            // authentication IPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-REAL-IP", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestTransferRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Limit
         * @param {FrontendCryptoCurrencyEnum} cryptoCurrency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLimit: async (cryptoCurrency: FrontendCryptoCurrencyEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cryptoCurrency' is not null or undefined
            assertParamExists('getLimit', 'cryptoCurrency', cryptoCurrency)
            const localVarPath = `/api/v1/transfers/get_limit/{crypto_currency}/`
                .replace(`{${"crypto_currency"}}`, encodeURIComponent(String(cryptoCurrency)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Price For Fiat
         * @param {FrontendCryptoCurrencyEnum} cryptoCurrency 
         * @param {FiatCurrency} localCurrency 
         * @param {number} amount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPriceForFiat: async (cryptoCurrency: FrontendCryptoCurrencyEnum, localCurrency: FiatCurrency, amount: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cryptoCurrency' is not null or undefined
            assertParamExists('getPriceForFiat', 'cryptoCurrency', cryptoCurrency)
            // verify required parameter 'localCurrency' is not null or undefined
            assertParamExists('getPriceForFiat', 'localCurrency', localCurrency)
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('getPriceForFiat', 'amount', amount)
            const localVarPath = `/api/v1/transfers/price_for_fiat/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (cryptoCurrency !== undefined) {
                localVarQueryParameter['crypto_currency'] = cryptoCurrency;
            }

            if (localCurrency !== undefined) {
                localVarQueryParameter['local_currency'] = localCurrency;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Process Transfer
         * @param {string} transferRequestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequest: async (transferRequestId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transferRequestId' is not null or undefined
            assertParamExists('processRequest', 'transferRequestId', transferRequestId)
            const localVarPath = `/api/v1/transfers/process_transfer/{transfer_request_id}/`
                .replace(`{${"transfer_request_id"}}`, encodeURIComponent(String(transferRequestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CountryCodeHeader required
            await setApiKeyToObject(localVarHeaderParameter, "CF-IPCOUNTRY", configuration)

            // authentication IPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-REAL-IP", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransfersApi - functional programming interface
 * @export
 */
export const TransfersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransfersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Transfer Request
         * @param {RequestTransferRequest} requestTransferRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransferRequest(requestTransferRequest: RequestTransferRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransferRequest(requestTransferRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Limit
         * @param {FrontendCryptoCurrencyEnum} cryptoCurrency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLimit(cryptoCurrency: FrontendCryptoCurrencyEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CryptocurrencyTransferLimits>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLimit(cryptoCurrency, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Price For Fiat
         * @param {FrontendCryptoCurrencyEnum} cryptoCurrency 
         * @param {FiatCurrency} localCurrency 
         * @param {number} amount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPriceForFiat(cryptoCurrency: FrontendCryptoCurrencyEnum, localCurrency: FiatCurrency, amount: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Price>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPriceForFiat(cryptoCurrency, localCurrency, amount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Process Transfer
         * @param {string} transferRequestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processRequest(transferRequestId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.processRequest(transferRequestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransfersApi - factory interface
 * @export
 */
export const TransfersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransfersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Transfer Request
         * @param {RequestTransferRequest} requestTransferRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransferRequest(requestTransferRequest: RequestTransferRequest, options?: any): AxiosPromise<TransferRequestResponse> {
            return localVarFp.createTransferRequest(requestTransferRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Limit
         * @param {FrontendCryptoCurrencyEnum} cryptoCurrency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLimit(cryptoCurrency: FrontendCryptoCurrencyEnum, options?: any): AxiosPromise<CryptocurrencyTransferLimits> {
            return localVarFp.getLimit(cryptoCurrency, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Price For Fiat
         * @param {FrontendCryptoCurrencyEnum} cryptoCurrency 
         * @param {FiatCurrency} localCurrency 
         * @param {number} amount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPriceForFiat(cryptoCurrency: FrontendCryptoCurrencyEnum, localCurrency: FiatCurrency, amount: number, options?: any): AxiosPromise<Price> {
            return localVarFp.getPriceForFiat(cryptoCurrency, localCurrency, amount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Process Transfer
         * @param {string} transferRequestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processRequest(transferRequestId: string, options?: any): AxiosPromise<BooleanResponse> {
            return localVarFp.processRequest(transferRequestId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransfersApi - object-oriented interface
 * @export
 * @class TransfersApi
 * @extends {BaseAPI}
 */
export class TransfersApi extends BaseAPI {
    /**
     * 
     * @summary Create Transfer Request
     * @param {RequestTransferRequest} requestTransferRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public createTransferRequest(requestTransferRequest: RequestTransferRequest, options?: AxiosRequestConfig) {
        return TransfersApiFp(this.configuration).createTransferRequest(requestTransferRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Limit
     * @param {FrontendCryptoCurrencyEnum} cryptoCurrency 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public getLimit(cryptoCurrency: FrontendCryptoCurrencyEnum, options?: AxiosRequestConfig) {
        return TransfersApiFp(this.configuration).getLimit(cryptoCurrency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Price For Fiat
     * @param {FrontendCryptoCurrencyEnum} cryptoCurrency 
     * @param {FiatCurrency} localCurrency 
     * @param {number} amount 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public getPriceForFiat(cryptoCurrency: FrontendCryptoCurrencyEnum, localCurrency: FiatCurrency, amount: number, options?: AxiosRequestConfig) {
        return TransfersApiFp(this.configuration).getPriceForFiat(cryptoCurrency, localCurrency, amount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Process Transfer
     * @param {string} transferRequestId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public processRequest(transferRequestId: string, options?: AxiosRequestConfig) {
        return TransfersApiFp(this.configuration).processRequest(transferRequestId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Auth User
         * @param {AccessTokenQuery} accessTokenQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUser: async (accessTokenQuery: AccessTokenQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessTokenQuery' is not null or undefined
            assertParamExists('authUser', 'accessTokenQuery', accessTokenQuery)
            const localVarPath = `/api/v1/users/auth/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CountryCodeHeader required
            await setApiKeyToObject(localVarHeaderParameter, "CF-IPCOUNTRY", configuration)

            // authentication IPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-REAL-IP", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessTokenQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check Available Payment Method
         * @param {PaymentMethodEnum} paymentMethod 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAvailablePaymentMethod: async (paymentMethod: PaymentMethodEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentMethod' is not null or undefined
            assertParamExists('checkAvailablePaymentMethod', 'paymentMethod', paymentMethod)
            const localVarPath = `/api/v1/users/available_acquiring/{payment_method}/`
                .replace(`{${"payment_method"}}`, encodeURIComponent(String(paymentMethod)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CountryCodeHeader required
            await setApiKeyToObject(localVarHeaderParameter, "CF-IPCOUNTRY", configuration)

            // authentication IPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-REAL-IP", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Disable Is New User Flag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableIsNewUserFlag: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/is_new_user/disable/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Kyc Status
         * @param {string} [purchaseId] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getKycStatus: async (purchaseId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/kyc/status/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (purchaseId !== undefined) {
                localVarQueryParameter['purchase_id'] = purchaseId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Kyc Url
         * @param {XpsProxyServiceMockTgIntegrationApiV1UsersDtoUserKycUrlRequest} xpsProxyServiceMockTgIntegrationApiV1UsersDtoUserKycUrlRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getKycUrl: async (xpsProxyServiceMockTgIntegrationApiV1UsersDtoUserKycUrlRequest: XpsProxyServiceMockTgIntegrationApiV1UsersDtoUserKycUrlRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xpsProxyServiceMockTgIntegrationApiV1UsersDtoUserKycUrlRequest' is not null or undefined
            assertParamExists('getKycUrl', 'xpsProxyServiceMockTgIntegrationApiV1UsersDtoUserKycUrlRequest', xpsProxyServiceMockTgIntegrationApiV1UsersDtoUserKycUrlRequest)
            const localVarPath = `/api/v1/users/kyc/url/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(xpsProxyServiceMockTgIntegrationApiV1UsersDtoUserKycUrlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Or Create Wallet
         * @param {CurrencyEnum} currency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrCreateWallet: async (currency: CurrencyEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'currency' is not null or undefined
            assertParamExists('getOrCreateWallet', 'currency', currency)
            const localVarPath = `/api/v1/users/get_or_create_wallet/{currency}`
                .replace(`{${"currency"}}`, encodeURIComponent(String(currency)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Payment Currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentCurrency: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/get_payment_currency/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Payment Methods
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethods: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/payment_methods/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CountryCodeHeader required
            await setApiKeyToObject(localVarHeaderParameter, "CF-IPCOUNTRY", configuration)

            // authentication IPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-REAL-IP", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get User State
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserState: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/state/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Init Bot Kyc Poll
         * @param {BotKycPollingQuery} botKycPollingQuery 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        initBotKycPoll: async (botKycPollingQuery: BotKycPollingQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botKycPollingQuery' is not null or undefined
            assertParamExists('initBotKycPoll', 'botKycPollingQuery', botKycPollingQuery)
            const localVarPath = `/api/v1/users/kyc/init_bot_poll/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(botKycPollingQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set Payment Currency
         * @param {string} fiatCurrency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPaymentCurrency: async (fiatCurrency: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fiatCurrency' is not null or undefined
            assertParamExists('setPaymentCurrency', 'fiatCurrency', fiatCurrency)
            const localVarPath = `/api/v1/users/set_payment_currency/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (fiatCurrency !== undefined) {
                localVarQueryParameter['fiat_currency'] = fiatCurrency;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Typeform Webhook
         * @param {TypeformCallback} typeformCallback 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typeformWebhook: async (typeformCallback: TypeformCallback, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typeformCallback' is not null or undefined
            assertParamExists('typeformWebhook', 'typeformCallback', typeformCallback)
            const localVarPath = `/api/v1/webhooks/typeform/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typeformCallback, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Has Purchases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userHasPurchases: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/has_purchases/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Registration
         * @param {RegistrationData} registrationData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRegistration: async (registrationData: RegistrationData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registrationData' is not null or undefined
            assertParamExists('userRegistration', 'registrationData', registrationData)
            const localVarPath = `/api/v1/users/registration/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CountryCodeHeader required
            await setApiKeyToObject(localVarHeaderParameter, "CF-IPCOUNTRY", configuration)

            // authentication IPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-REAL-IP", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registrationData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Auth User
         * @param {AccessTokenQuery} accessTokenQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authUser(accessTokenQuery: AccessTokenQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authUser(accessTokenQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check Available Payment Method
         * @param {PaymentMethodEnum} paymentMethod 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkAvailablePaymentMethod(paymentMethod: PaymentMethodEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentMethodAvailability>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkAvailablePaymentMethod(paymentMethod, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Disable Is New User Flag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableIsNewUserFlag(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableIsNewUserFlag(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Kyc Status
         * @param {string} [purchaseId] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getKycStatus(purchaseId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserKycStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKycStatus(purchaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Kyc Url
         * @param {XpsProxyServiceMockTgIntegrationApiV1UsersDtoUserKycUrlRequest} xpsProxyServiceMockTgIntegrationApiV1UsersDtoUserKycUrlRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getKycUrl(xpsProxyServiceMockTgIntegrationApiV1UsersDtoUserKycUrlRequest: XpsProxyServiceMockTgIntegrationApiV1UsersDtoUserKycUrlRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserKycUrl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKycUrl(xpsProxyServiceMockTgIntegrationApiV1UsersDtoUserKycUrlRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Or Create Wallet
         * @param {CurrencyEnum} currency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrCreateWallet(currency: CurrencyEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<XpsProxyServiceMockTgIntegrationApiV1UsersDtoWalletAddress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrCreateWallet(currency, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Payment Currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentCurrency(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FiatCurrency>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentCurrency(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Payment Methods
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentMethods(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: PaymentMethodAvailability; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentMethods(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get User State
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserState(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserState(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Init Bot Kyc Poll
         * @param {BotKycPollingQuery} botKycPollingQuery 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async initBotKycPoll(botKycPollingQuery: BotKycPollingQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BoolResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initBotKycPoll(botKycPollingQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set Payment Currency
         * @param {string} fiatCurrency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setPaymentCurrency(fiatCurrency: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPaymentCurrency(fiatCurrency, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Typeform Webhook
         * @param {TypeformCallback} typeformCallback 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async typeformWebhook(typeformCallback: TypeformCallback, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.typeformWebhook(typeformCallback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary User Has Purchases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userHasPurchases(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userHasPurchases(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary User Registration
         * @param {RegistrationData} registrationData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userRegistration(registrationData: RegistrationData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistrationResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userRegistration(registrationData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Auth User
         * @param {AccessTokenQuery} accessTokenQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUser(accessTokenQuery: AccessTokenQuery, options?: any): AxiosPromise<AccessToken> {
            return localVarFp.authUser(accessTokenQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check Available Payment Method
         * @param {PaymentMethodEnum} paymentMethod 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAvailablePaymentMethod(paymentMethod: PaymentMethodEnum, options?: any): AxiosPromise<PaymentMethodAvailability> {
            return localVarFp.checkAvailablePaymentMethod(paymentMethod, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Disable Is New User Flag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableIsNewUserFlag(options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.disableIsNewUserFlag(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Kyc Status
         * @param {string} [purchaseId] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getKycStatus(purchaseId?: string, options?: any): AxiosPromise<UserKycStatus> {
            return localVarFp.getKycStatus(purchaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Kyc Url
         * @param {XpsProxyServiceMockTgIntegrationApiV1UsersDtoUserKycUrlRequest} xpsProxyServiceMockTgIntegrationApiV1UsersDtoUserKycUrlRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getKycUrl(xpsProxyServiceMockTgIntegrationApiV1UsersDtoUserKycUrlRequest: XpsProxyServiceMockTgIntegrationApiV1UsersDtoUserKycUrlRequest, options?: any): AxiosPromise<UserKycUrl> {
            return localVarFp.getKycUrl(xpsProxyServiceMockTgIntegrationApiV1UsersDtoUserKycUrlRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Or Create Wallet
         * @param {CurrencyEnum} currency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrCreateWallet(currency: CurrencyEnum, options?: any): AxiosPromise<XpsProxyServiceMockTgIntegrationApiV1UsersDtoWalletAddress> {
            return localVarFp.getOrCreateWallet(currency, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Payment Currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentCurrency(options?: any): AxiosPromise<Array<FiatCurrency>> {
            return localVarFp.getPaymentCurrency(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Payment Methods
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethods(options?: any): AxiosPromise<{ [key: string]: PaymentMethodAvailability; }> {
            return localVarFp.getPaymentMethods(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get User State
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserState(options?: any): AxiosPromise<UserState> {
            return localVarFp.getUserState(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Init Bot Kyc Poll
         * @param {BotKycPollingQuery} botKycPollingQuery 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        initBotKycPoll(botKycPollingQuery: BotKycPollingQuery, options?: any): AxiosPromise<BoolResult> {
            return localVarFp.initBotKycPoll(botKycPollingQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set Payment Currency
         * @param {string} fiatCurrency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPaymentCurrency(fiatCurrency: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.setPaymentCurrency(fiatCurrency, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Typeform Webhook
         * @param {TypeformCallback} typeformCallback 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typeformWebhook(typeformCallback: TypeformCallback, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.typeformWebhook(typeformCallback, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary User Has Purchases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userHasPurchases(options?: any): AxiosPromise<BooleanResponse> {
            return localVarFp.userHasPurchases(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary User Registration
         * @param {RegistrationData} registrationData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRegistration(registrationData: RegistrationData, options?: any): AxiosPromise<RegistrationResult> {
            return localVarFp.userRegistration(registrationData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Auth User
     * @param {AccessTokenQuery} accessTokenQuery 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public authUser(accessTokenQuery: AccessTokenQuery, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).authUser(accessTokenQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check Available Payment Method
     * @param {PaymentMethodEnum} paymentMethod 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public checkAvailablePaymentMethod(paymentMethod: PaymentMethodEnum, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).checkAvailablePaymentMethod(paymentMethod, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Disable Is New User Flag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public disableIsNewUserFlag(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).disableIsNewUserFlag(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Kyc Status
     * @param {string} [purchaseId] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getKycStatus(purchaseId?: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getKycStatus(purchaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Kyc Url
     * @param {XpsProxyServiceMockTgIntegrationApiV1UsersDtoUserKycUrlRequest} xpsProxyServiceMockTgIntegrationApiV1UsersDtoUserKycUrlRequest 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getKycUrl(xpsProxyServiceMockTgIntegrationApiV1UsersDtoUserKycUrlRequest: XpsProxyServiceMockTgIntegrationApiV1UsersDtoUserKycUrlRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getKycUrl(xpsProxyServiceMockTgIntegrationApiV1UsersDtoUserKycUrlRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Or Create Wallet
     * @param {CurrencyEnum} currency 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getOrCreateWallet(currency: CurrencyEnum, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getOrCreateWallet(currency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Payment Currency
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getPaymentCurrency(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getPaymentCurrency(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Payment Methods
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getPaymentMethods(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getPaymentMethods(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get User State
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserState(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserState(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Init Bot Kyc Poll
     * @param {BotKycPollingQuery} botKycPollingQuery 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public initBotKycPoll(botKycPollingQuery: BotKycPollingQuery, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).initBotKycPoll(botKycPollingQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set Payment Currency
     * @param {string} fiatCurrency 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public setPaymentCurrency(fiatCurrency: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).setPaymentCurrency(fiatCurrency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Typeform Webhook
     * @param {TypeformCallback} typeformCallback 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public typeformWebhook(typeformCallback: TypeformCallback, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).typeformWebhook(typeformCallback, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary User Has Purchases
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userHasPurchases(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).userHasPurchases(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary User Registration
     * @param {RegistrationData} registrationData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userRegistration(registrationData: RegistrationData, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).userRegistration(registrationData, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WVSettingsApi - axios parameter creator
 * @export
 */
export const WVSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Set User Wv Settings
         * @param {XpsProxyServiceMockTgIntegrationApiV1SettingsDtoWVSettings} xpsProxyServiceMockTgIntegrationApiV1SettingsDtoWVSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserWvSettings: async (xpsProxyServiceMockTgIntegrationApiV1SettingsDtoWVSettings: XpsProxyServiceMockTgIntegrationApiV1SettingsDtoWVSettings, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xpsProxyServiceMockTgIntegrationApiV1SettingsDtoWVSettings' is not null or undefined
            assertParamExists('setUserWvSettings', 'xpsProxyServiceMockTgIntegrationApiV1SettingsDtoWVSettings', xpsProxyServiceMockTgIntegrationApiV1SettingsDtoWVSettings)
            const localVarPath = `/api/v1/settings/user_wv_settings/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(xpsProxyServiceMockTgIntegrationApiV1SettingsDtoWVSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WVSettingsApi - functional programming interface
 * @export
 */
export const WVSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WVSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Set User Wv Settings
         * @param {XpsProxyServiceMockTgIntegrationApiV1SettingsDtoWVSettings} xpsProxyServiceMockTgIntegrationApiV1SettingsDtoWVSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setUserWvSettings(xpsProxyServiceMockTgIntegrationApiV1SettingsDtoWVSettings: XpsProxyServiceMockTgIntegrationApiV1SettingsDtoWVSettings, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setUserWvSettings(xpsProxyServiceMockTgIntegrationApiV1SettingsDtoWVSettings, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WVSettingsApi - factory interface
 * @export
 */
export const WVSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WVSettingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Set User Wv Settings
         * @param {XpsProxyServiceMockTgIntegrationApiV1SettingsDtoWVSettings} xpsProxyServiceMockTgIntegrationApiV1SettingsDtoWVSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserWvSettings(xpsProxyServiceMockTgIntegrationApiV1SettingsDtoWVSettings: XpsProxyServiceMockTgIntegrationApiV1SettingsDtoWVSettings, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.setUserWvSettings(xpsProxyServiceMockTgIntegrationApiV1SettingsDtoWVSettings, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WVSettingsApi - object-oriented interface
 * @export
 * @class WVSettingsApi
 * @extends {BaseAPI}
 */
export class WVSettingsApi extends BaseAPI {
    /**
     * 
     * @summary Set User Wv Settings
     * @param {XpsProxyServiceMockTgIntegrationApiV1SettingsDtoWVSettings} xpsProxyServiceMockTgIntegrationApiV1SettingsDtoWVSettings 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WVSettingsApi
     */
    public setUserWvSettings(xpsProxyServiceMockTgIntegrationApiV1SettingsDtoWVSettings: XpsProxyServiceMockTgIntegrationApiV1SettingsDtoWVSettings, options?: AxiosRequestConfig) {
        return WVSettingsApiFp(this.configuration).setUserWvSettings(xpsProxyServiceMockTgIntegrationApiV1SettingsDtoWVSettings, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WalletsApi - axios parameter creator
 * @export
 */
export const WalletsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Validate Wallet Address
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateWalletAddress: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('validateWalletAddress', 'address', address)
            const localVarPath = `/api/v1/wallets/validate/{address}/`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletsApi - functional programming interface
 * @export
 */
export const WalletsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WalletsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Validate Wallet Address
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateWalletAddress(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<XpsProxyServiceMockTgIntegrationApiV1WalletsDtoWalletAddress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateWalletAddress(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WalletsApi - factory interface
 * @export
 */
export const WalletsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WalletsApiFp(configuration)
    return {
        /**
         * 
         * @summary Validate Wallet Address
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateWalletAddress(address: string, options?: any): AxiosPromise<XpsProxyServiceMockTgIntegrationApiV1WalletsDtoWalletAddress> {
            return localVarFp.validateWalletAddress(address, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WalletsApi - object-oriented interface
 * @export
 * @class WalletsApi
 * @extends {BaseAPI}
 */
export class WalletsApi extends BaseAPI {
    /**
     * 
     * @summary Validate Wallet Address
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApi
     */
    public validateWalletAddress(address: string, options?: AxiosRequestConfig) {
        return WalletsApiFp(this.configuration).validateWalletAddress(address, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WithdrawalsApi - axios parameter creator
 * @export
 */
export const WithdrawalsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Withdraw Request
         * @param {number} amount 
         * @param {CurrencyEnum} currency 
         * @param {boolean} maxValue 
         * @param {string} address 
         * @param {string} [comment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWithdrawRequest: async (amount: number, currency: CurrencyEnum, maxValue: boolean, address: string, comment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('createWithdrawRequest', 'amount', amount)
            // verify required parameter 'currency' is not null or undefined
            assertParamExists('createWithdrawRequest', 'currency', currency)
            // verify required parameter 'maxValue' is not null or undefined
            assertParamExists('createWithdrawRequest', 'maxValue', maxValue)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('createWithdrawRequest', 'address', address)
            const localVarPath = `/api/v1/withdrawals/create_withdraw_request/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = currency;
            }

            if (maxValue !== undefined) {
                localVarQueryParameter['max_value'] = maxValue;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (comment !== undefined) {
                localVarQueryParameter['comment'] = comment;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Process Withdraw Request
         * @param {string} withdrawRequestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processWithdrawRequest: async (withdrawRequestId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawRequestId' is not null or undefined
            assertParamExists('processWithdrawRequest', 'withdrawRequestId', withdrawRequestId)
            const localVarPath = `/api/v1/withdrawals/process_withdraw_request/{withdraw_request_id}/`
                .replace(`{${"withdraw_request_id"}}`, encodeURIComponent(String(withdrawRequestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validate Amount
         * @param {number} amount 
         * @param {CurrencyEnum} currency 
         * @param {string} [address] 
         * @param {number} [receiverTgId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateAmount: async (amount: number, currency: CurrencyEnum, address?: string, receiverTgId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('validateAmount', 'amount', amount)
            // verify required parameter 'currency' is not null or undefined
            assertParamExists('validateAmount', 'currency', currency)
            const localVarPath = `/api/v1/withdrawals/validate_amount/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = currency;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (receiverTgId !== undefined) {
                localVarQueryParameter['receiver_tg_id'] = receiverTgId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WithdrawalsApi - functional programming interface
 * @export
 */
export const WithdrawalsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WithdrawalsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Withdraw Request
         * @param {number} amount 
         * @param {CurrencyEnum} currency 
         * @param {boolean} maxValue 
         * @param {string} address 
         * @param {string} [comment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWithdrawRequest(amount: number, currency: CurrencyEnum, maxValue: boolean, address: string, comment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WithdrawRequestData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWithdrawRequest(amount, currency, maxValue, address, comment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Process Withdraw Request
         * @param {string} withdrawRequestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processWithdrawRequest(withdrawRequestId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WithdrawalRequestResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.processWithdrawRequest(withdrawRequestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Validate Amount
         * @param {number} amount 
         * @param {CurrencyEnum} currency 
         * @param {string} [address] 
         * @param {number} [receiverTgId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateAmount(amount: number, currency: CurrencyEnum, address?: string, receiverTgId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidateAmountResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateAmount(amount, currency, address, receiverTgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WithdrawalsApi - factory interface
 * @export
 */
export const WithdrawalsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WithdrawalsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Withdraw Request
         * @param {number} amount 
         * @param {CurrencyEnum} currency 
         * @param {boolean} maxValue 
         * @param {string} address 
         * @param {string} [comment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWithdrawRequest(amount: number, currency: CurrencyEnum, maxValue: boolean, address: string, comment?: string, options?: any): AxiosPromise<WithdrawRequestData> {
            return localVarFp.createWithdrawRequest(amount, currency, maxValue, address, comment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Process Withdraw Request
         * @param {string} withdrawRequestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processWithdrawRequest(withdrawRequestId: string, options?: any): AxiosPromise<WithdrawalRequestResult> {
            return localVarFp.processWithdrawRequest(withdrawRequestId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Validate Amount
         * @param {number} amount 
         * @param {CurrencyEnum} currency 
         * @param {string} [address] 
         * @param {number} [receiverTgId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateAmount(amount: number, currency: CurrencyEnum, address?: string, receiverTgId?: number, options?: any): AxiosPromise<ValidateAmountResult> {
            return localVarFp.validateAmount(amount, currency, address, receiverTgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WithdrawalsApi - object-oriented interface
 * @export
 * @class WithdrawalsApi
 * @extends {BaseAPI}
 */
export class WithdrawalsApi extends BaseAPI {
    /**
     * 
     * @summary Create Withdraw Request
     * @param {number} amount 
     * @param {CurrencyEnum} currency 
     * @param {boolean} maxValue 
     * @param {string} address 
     * @param {string} [comment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalsApi
     */
    public createWithdrawRequest(amount: number, currency: CurrencyEnum, maxValue: boolean, address: string, comment?: string, options?: AxiosRequestConfig) {
        return WithdrawalsApiFp(this.configuration).createWithdrawRequest(amount, currency, maxValue, address, comment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Process Withdraw Request
     * @param {string} withdrawRequestId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalsApi
     */
    public processWithdrawRequest(withdrawRequestId: string, options?: AxiosRequestConfig) {
        return WithdrawalsApiFp(this.configuration).processWithdrawRequest(withdrawRequestId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Validate Amount
     * @param {number} amount 
     * @param {CurrencyEnum} currency 
     * @param {string} [address] 
     * @param {number} [receiverTgId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalsApi
     */
    public validateAmount(amount: number, currency: CurrencyEnum, address?: string, receiverTgId?: number, options?: AxiosRequestConfig) {
        return WithdrawalsApiFp(this.configuration).validateAmount(amount, currency, address, receiverTgId, options).then((request) => request(this.axios, this.basePath));
    }
}


